#ifndef image_header
#define image_header

#include <windows.h>
#include <vector>
#include <conio.h>
#include <iostream>
#include <gdiplus.h>

#include "Tokenhackdll.h"

using namespace std;
using namespace Gdiplus;

#define GRAYSCALE_AVGERAGE				1
#define GRAYSCALE_LUMINOSITY			2
#define GRAYSCALE_DESATURATION			3
#define GRAYSCALE_DECOMPOSITION_MIN		4
#define GRAYSCALE_DECOMPOSITION_MAX		5
#define GRAYSCALE_COLOR_CHANNEL_RED		6
#define GRAYSCALE_COLOR_CHANNEL_GREEN	7
#define GRAYSCALE_COLOR_CHANNEL_BLUE	8
#define GRAYSCLAE_COLOR_COUNT			9
#define GRAYSCLAE_COLOR_COUNT_DITHER	10
#define GRAYSCALE_BINARY				11
#define GRAYSCALE_INVERSE_BINARY		12

#define BRIGHTNESS_FLAT					1
#define BRIGHTNESS_HSV					2

vector<string> stats_in_file;
vector<string> spam_text_in_file;

vector<int> isolate_letters(BYTE* newbuf, int width, int top, int bottom);
vector<int> find_lines(BYTE* newbuf, int x, int y);

#pragma region statfile color struct

struct my_RGB;
vector<my_RGB> statcolors;

struct my_RGB{
	int red;
	int green;
	int blue;
	string text_in_file;
	my_RGB(): text_in_file(""), red(-1), green(-1), blue(-1) {}
	my_RGB(string text_in_file) : text_in_file(text_in_file), red(-1), green(-1), blue(-1) {
		statcolors.push_back(*this);
	}
	my_RGB(int red, int green, int blue): red(red), green(green), blue(blue) {}
};

my_RGB blue_text_RGB("bluergbvalue");
my_RGB white_text_RGB("whitergbvalue");
my_RGB yellow_text_RGB("yellowrgbvalue");
my_RGB gray_text_RGB("grayrgbvalue");
my_RGB gold_text_RGB("goldrgbvalue");
my_RGB green_text_RGB("greenrgbvalue");
my_RGB orange_text_RGB("orangergbvalue");
my_RGB red_text_RGB("redrgbvalue");
my_RGB magenta_text_RGB("magentargbvalue");

void reset_color_text_RGB(){
	for (UINT i = 0; i < statcolors.size(); i++) {
		statcolors[i].red = -1;		
		statcolors[i].green = -1;
		statcolors[i].blue = -1;
	}
}

#pragma endregion

#define MIN3(x,y,z)  ((y) <= (z) ? ((x) <= (y) ? (x) : (y)) : ((x) <= (z) ? (x) : (z)))

#define MAX3(x,y,z)  ((y) >= (z) ? ((x) >= (y) ? (x) : (y)) : ((x) >= (z) ? (x) : (z)))

struct rgb_color {
	double r, g, b;
	rgb_color(){}
	rgb_color(double r, double g, double b):r(r/255), g(g/255), b(b/255) {}
};

struct hsv_color {
	double hue;
	double sat;
	double val;
};

// ascii value, number of pixels in character+2 (size-2), width, height, [grid values...](zero based)
vector<vector<BYTE>> font16 = {
	{ 32, 2, 0, 0 },
	{ 37, 47, 10, 9, 1, 2, 10, 11, 12, 13, 14, 16, 20, 23, 24, 25, 26, 30, 31, 32, 33, 35, 40, 41, 42, 43, 44, 45, 46, 47, 48, 54, 55, 56, 58, 59, 63, 65, 66, 67, 69, 73, 75, 76, 77, 82, 86, 87, 88 },//%
	{ 39, 5, 1, 3, 0, 1, 2 },//'
	{ 40, 15, 3, 12, 2, 3, 6, 9, 12, 15, 18, 21, 24, 27, 30, 31, 35 },//(
	{ 41, 14, 2, 11, 0, 2, 3, 5, 7, 9, 11, 13, 15, 17, 19, 21 },//)
	{ 43, 15, 5, 5, 2, 5, 7, 10, 11, 12, 13, 14, 15, 17, 21, 22, 23 },//+
	{ 44, 6, 2, 3, 1, 2, 3, 4 },//,
	{ 45, 4, 2, 1, 0, 1 },//- (PROBLEM CHAR) - right side of gap
	{ 47, 16, 6, 12, 5, 11, 16, 22, 27, 32, 33, 38, 39, 44, 49, 55, 60, 66 },//'/'
	{ 48, 37, 9, 10, 4, 5, 11, 12, 13, 14, 15, 16, 19, 24, 25, 27, 28, 32, 33, 34, 35, 36, 40, 44, 45, 48, 53, 54, 56, 61, 62, 64, 65, 70, 74, 75, 76, 78, 85 },//0
	{ 49, 11, 2, 9, 1, 2, 4, 6, 8, 10, 12, 14, 16 },//1
	{ 50, 27, 6, 9, 2, 7, 8, 10, 12, 13, 16, 17, 18, 19, 22, 23, 28, 33, 34, 38, 39, 43, 44, 48, 49, 50, 51, 52, 53 },//2
	{ 51, 26, 6, 9, 1, 2, 3, 6, 7, 8, 9, 10, 11, 12, 16, 21, 26, 27, 28, 34, 35, 37, 41, 43, 47, 49, 50, 52 },//3
	{ 52, 20, 7, 8, 4, 10, 11, 17, 18, 23, 25, 29, 32, 35, 36, 37, 38, 39, 40, 41, 46, 53 },//4
	{ 53, 26, 6, 8, 1, 2, 4, 7, 13, 18, 19, 20, 21, 22, 25, 28, 29, 30, 31, 35, 36, 37, 40, 41, 43, 44, 45, 46 },//5
	{ 54, 24, 6, 10, 5, 9, 10, 15, 20, 21, 25, 26, 27, 28, 31, 35, 36, 37, 41, 43, 47, 49, 50, 51, 52, 57 },//6
	{ 55, 16, 6, 9, 2, 3, 6, 7, 8, 10, 11, 16, 22, 28, 33, 39, 44, 50 },//7
	{ 56, 31, 6, 10, 2, 3, 7, 8, 9, 10, 12, 13, 16, 19, 21, 22, 25, 26, 27, 30, 31, 34, 36, 40, 41, 42, 43, 46, 49, 50, 51, 52, 56 },//8
	{ 57, 23, 6, 9, 3, 7, 8, 9, 10, 11, 12, 13, 17, 18, 19, 23, 25, 28, 29, 32, 33, 34, 39, 45, 50 },//9
	{ 58, 8, 2, 7, 0, 2, 3, 10, 12, 13 },//:
	{ 65, 25, 8, 9, 4, 11, 12, 19, 21, 26, 29, 34, 38, 41, 46, 49, 50, 51, 52, 54, 55, 56, 57, 63, 64, 65, 71 },//A
	{ 66, 35, 5, 9, 0, 1, 2, 3, 4, 5, 6, 9, 10, 11, 13, 14, 15, 16, 17, 18, 19, 20, 21, 24, 25, 26, 29, 30, 31, 34, 35, 36, 37, 38, 39, 40, 41 },//B
	{ 67, 26, 7, 10, 4, 9, 10, 11, 12, 13, 15, 20, 22, 28, 35, 36, 42, 43, 50, 51, 58, 59, 60, 61, 62, 66, 67, 68 },//C
	{ 68, 16, 4, 8, 0, 1, 2, 6, 7, 11, 15, 19, 23, 26, 27, 28, 29, 30 },//D (PROBLEM CHAR) - right side of gap
	{ 69, 33, 5, 9, 1, 2, 3, 4, 6, 10, 11, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 30, 31, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44 },//E
	{ 70, 23, 6, 8, 0, 1, 2, 3, 4, 7, 12, 13, 18, 19, 20, 22, 23, 24, 25, 26, 28, 30, 31, 37, 43 },//F
	{ 71, 28, 7, 9, 1, 2, 3, 4, 5, 6, 8, 9, 14, 21, 26, 27, 28, 33, 34, 35, 41, 43, 48, 51, 52, 53, 54, 55, 59, 60 },//G
	{ 72, 37, 7, 10, 6, 7, 8, 12, 15, 19, 22, 26, 28, 29, 30, 31, 32, 33, 35, 36, 37, 38, 39, 40, 41, 42, 43, 47, 49, 50, 54, 55, 56, 57, 61, 62, 63, 64, 68 },//H
	{ 73, 16, 2, 8, 0, 1, 2, 3, 5, 7, 8, 9, 10, 11, 12, 13, 14, 15 },//I
	{ 74, 21, 2, 10, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18 },//J
	{ 75, 24, 7, 9, 1, 4, 8, 10, 11, 15, 16, 17, 22, 23, 29, 30, 36, 38, 43, 46, 50, 54, 55, 56, 57, 62 },//K
	{ 76, 17, 5, 9, 0, 5, 10, 15, 20, 25, 30, 35, 36, 37, 38, 40, 42, 43, 44 },//L
	{ 77, 53, 9, 10, 3, 4, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 21, 22, 25, 26, 27, 30, 31, 34, 35, 36, 39, 40, 43, 44, 45, 48, 49, 52, 53, 54, 57, 58, 61, 62, 63, 66, 67, 70, 71, 72, 75, 76, 79, 80, 81, 84, 85, 88, 89 },//M
	{ 78, 34, 8, 9, 0, 1, 6, 7, 9, 14, 17, 18, 19, 22, 24, 25, 27, 30, 32, 33, 36, 38, 40, 41, 45, 46, 48, 49, 54, 56, 57, 63, 64, 65, 70, 71 },//N
	{ 79, 53, 9, 10, 4, 10, 11, 12, 13, 14, 15, 16, 19, 20, 22, 25, 27, 28, 31, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 58, 61, 62, 64, 67, 69, 70, 74, 75, 76, 77, 78, 84, 85 },//O
	{ 80, 25, 6, 8, 0, 1, 2, 3, 4, 6, 7, 10, 12, 13, 16, 17, 19, 22, 25, 26, 27, 30, 31, 36, 37, 42, 43 },//P
	{ 81, 37, 9, 10, 2, 3, 4, 5, 6, 10, 15, 16, 18, 19, 25, 26, 27, 34, 35, 36, 44, 45, 49, 52, 53, 54, 55, 58, 61, 64, 65, 66, 67, 68, 69, 75, 76, 77, 85 },//Q
	{ 82, 25, 7, 9, 0, 1, 2, 3, 7, 11, 14, 18, 21, 24, 25, 29, 30, 31, 38, 43, 46, 49, 50, 54, 55, 56, 62 },//R
	{ 83, 24, 5, 8, 1, 2, 3, 4, 5, 6, 9, 10, 11, 16, 17, 23, 24, 29, 30, 31, 34, 35, 36, 37, 38, 39 },//S
	{ 84, 24, 9, 9, 0, 1, 2, 3, 4, 5, 6, 7, 8, 14, 22, 23, 32, 40, 41, 49, 50, 59, 67, 68, 76, 77 },//T
	{ 85, 36, 10, 9, 0, 1, 8, 9, 10, 11, 18, 19, 20, 21, 28, 29, 30, 31, 38, 39, 40, 41, 48, 49, 51, 52, 58, 59, 61, 68, 72, 73, 74, 75, 76, 77, 84, 85 },//U
	{ 86, 22, 9, 8, 0, 1, 8, 10, 16, 17, 19, 20, 25, 29, 33, 34, 39, 42, 48, 50, 51, 58, 59, 67 },//V
	{ 87, 43, 13, 9, 0, 1, 4, 5, 8, 11, 12, 14, 18, 20, 21, 24, 27, 28, 31, 32, 33, 37, 41, 45, 46, 49, 54, 55, 58, 62, 68, 70, 71, 72, 74, 81, 82, 83, 85, 86, 87, 95, 96, 99, 108 },//W
	{ 88, 20, 8, 9, 0, 7, 9, 14, 15, 18, 21, 27, 28, 35, 36, 42, 45, 49, 54, 56, 63, 64 },//X
	{ 89, 25, 9, 10, 7, 9, 10, 16, 17, 19, 20, 24, 25, 29, 30, 32, 33, 38, 39, 40, 41, 49, 58, 67, 76, 84, 85 },//Y
	{ 90, 26, 6, 9, 0, 1, 2, 3, 4, 5, 10, 11, 16, 21, 22, 27, 32, 37, 38, 43, 44, 45, 46, 47, 49, 50, 51, 53 },//Z
	{ 97, 15, 6, 7, 3, 9, 14, 16, 19, 22, 25, 29, 30, 31, 32, 35, 36 },//a
	{ 98, 16, 4, 6, 0, 1, 2, 4, 8, 9, 10, 12, 14, 15, 16, 19, 20, 22 },//b
	{ 99, 16, 6, 8, 3, 4, 5, 8, 10, 11, 13, 19, 24, 25, 31, 38, 45, 47 },//c
	{ 100, 24, 6, 7, 0, 1, 2, 4, 6, 7, 11, 12, 13, 17, 18, 19, 23, 24, 25, 29, 30, 31, 34, 37, 38, 39 },//d
	{ 101, 17, 4, 7, 0, 1, 2, 3, 4, 8, 9, 10, 11, 12, 13, 14, 15, 20, 27 },//e
	{ 102, 19, 4, 6, 0, 1, 2, 3, 4, 5, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 21 },//f
	{ 103, 21, 6, 8, 3, 4, 7, 8, 9, 10, 11, 18, 24, 27, 28, 29, 31, 35, 37, 41, 44, 45, 46 },//g
	{ 104, 22, 5, 8, 4, 9, 10, 14, 15, 16, 17, 18, 19, 20, 21, 22, 24, 25, 29, 30, 31, 34, 35, 39 },//h
	{ 105, 9, 1, 7, 0, 1, 2, 3, 4, 5, 6 },//i
	// no lowercase j (PROBLEM CHAR) - identical to lowercase i (105)
	{ 107, 15, 4, 7, 0, 2, 3, 4, 5, 8, 12, 13, 16, 18, 20, 23, 24 },//k
	{ 108, 11, 3, 7, 0, 3, 6, 9, 12, 15, 18, 19, 20 },//l
	{ 109, 29, 7, 8, 2, 3, 7, 8, 9, 10, 11, 12, 13, 14, 17, 20, 21, 24, 27, 28, 31, 34, 35, 38, 41, 42, 45, 48, 49, 52, 55 },//m
	{ 110, 27, 6, 7, 0, 4, 5, 6, 7, 10, 11, 12, 14, 16, 17, 18, 20, 21, 22, 23, 24, 27, 28, 29, 30, 34, 35, 36, 41 },//n
	{ 111, 33, 7, 8, 3, 8, 9, 10, 11, 12, 14, 17, 20, 21, 24, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 38, 41, 43, 44, 45, 46, 47, 51, 52, 53 },//o
	{ 112, 12, 4, 6, 0, 1, 2, 3, 7, 11, 12, 13, 14, 20 },//p
	{ 113, 25, 7, 9, 3, 8, 9, 10, 11, 12, 14, 19, 20, 21, 27, 28, 34, 35, 38, 41, 43, 45, 46, 47, 51, 52, 59 },//q
	{ 114, 14, 5, 6, 0, 2, 3, 8, 10, 11, 13, 15, 16, 17, 23, 29 },//r
	{ 115, 16, 5, 7, 1, 2, 3, 5, 6, 11, 12, 18, 24, 25, 26, 31, 32, 33 },//s
	{ 116, 15, 7, 7, 0, 7, 8, 9, 10, 11, 12, 13, 17, 24, 31, 38, 45 },//t
	{ 117, 10, 4, 7, 3, 7, 11, 15, 19, 22, 24, 25 },//u (PROBLEM CHAR) - right side of gap
	{ 118, 16, 8, 8, 7, 8, 14, 16, 17, 21, 25, 29, 34, 36, 42, 44, 51, 59 },//v
	{ 119, 29, 10, 7, 0, 10, 15, 16, 18, 19, 20, 23, 25, 28, 31, 33, 34, 35, 37, 38, 41, 44, 47, 52, 53, 54, 55, 62, 63, 65, 66 },//w
	{ 120, 15, 7, 6, 0, 5, 6, 8, 11, 16, 17, 23, 24, 29, 32, 35, 40 },//x
	{ 121, 13, 8, 7, 1, 8, 9, 14, 15, 18, 21, 27, 28, 43, 51 },//y
	{ 122, 17, 6, 7, 0, 1, 2, 4, 5, 10, 15, 20, 26, 31, 37, 38, 39, 40, 41 }//z
};
//int ingame[][400] = {//does not work properly
//	{33, 21 , 3, 9, 0,1,2,4,5,7,8,10,11,13,14,16,17,21,22,23,24,25,26},
//	{34, 14 , 4, 3, 0,1,2,3,4,5,6,7,8,9,10,11},
//	{35, 47 , 8, 9, 3,4,5,6,10,11,12,13,14,16,17,18,19,20,21,22,23,25,26,28,29,33,34,36,37,40,41,42,43,44,45,46,49,50,51,52,56,57,58,59,60,64,65,66,67},
//	{36, 46 , 7, 10, 3,4,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,29,30,31,32,38,39,40,41,45,46,47,48,49,50,52,53,54,55,57,58,59,60,61,66,67},
//	{37, 49 , 11, 8, 1,2,3,4,7,8,11,12,15,16,17,18,22,23,26,27,28,34,35,36,37,38,39,48,49,50,51,52,53,58,59,60,61,64,65,69,70,71,72,75,76,79,80,83,84,85,86},
//	{38, 39 , 9, 9, 2,3,4,5,6,10,11,14,15,19,20,28,29,38,39,40,41,46,47,49,50,51,52,53,54,55,60,61,63,64,68,69,73,74,75,76,77},
//	{39, 8 , 2, 3, 0,1,2,3,4,5},
//	{40, 22 , 3, 10, 1,2,4,5,6,7,9,10,12,13,15,16,18,19,21,22,25,26,28,29},
//	{41, 22 , 3, 10, 0,1,3,4,7,8,10,11,13,14,16,17,19,20,22,23,24,25,27,28},
//	{42, 22 , 6, 5, 2,3,6,7,8,9,10,11,13,14,15,16,18,19,20,21,22,23,26,27},
//	{43, 20 , 6, 7, 2,3,8,9,14,15,18,19,20,21,22,23,26,27,32,33,38,39},
//	{44, 8 , 3, 3, 1,2,4,5,6,7},
//	{45, 4 , 2, 1, 0,1},
//	{46, 8 , 3, 2, 0,1,2,3,4,5},
//	{47, 20 , 4, 10, 3,7,10,11,14,15,18,19,21,22,25,26,28,29,32,33,36,37},
//	{48, 28 , 7, 6, 2,3,4,5,8,9,11,12,13,14,15,19,20,21,22,26,27,28,29,30,32,33,36,37,38,39},
//	{49, 15 , 3, 6, 1,2,3,4,5,7,8,10,11,13,14,16,17},
//	{50, 23 , 6, 6, 1,2,3,4,5,6,7,10,11,16,17,21,22,25,26,27,30,31,32,33,34},
//	{51, 27 , 6, 8, 0,1,2,3,4,5,6,7,9,10,14,15,19,20,21,22,28,29,34,35,39,40,43,44,45},
//	{52, 31 , 7, 8, 4,5,10,11,12,16,17,18,19,23,24,25,26,29,30,31,32,33,35,36,37,38,39,40,41,46,47,53,54},
//	{53, 25 , 6, 8, 0,1,2,3,4,6,7,12,13,18,19,20,21,22,28,29,34,35,39,40,43,44,45},
//	{54, 30 , 7, 8, 4,5,9,10,11,15,16,22,23,24,25,26,28,29,33,34,35,36,40,41,42,43,46,47,50,51,52,53},
//	{55, 24 , 6, 8, 0,1,2,3,4,5,6,7,9,10,15,16,21,22,26,27,32,33,38,39,43,44},
//	{56, 36 , 7, 8, 2,3,4,5,8,9,12,13,15,16,19,20,23,24,25,26,29,30,32,33,34,35,36,40,41,42,43,47,48,50,51,52,53,54},
//	{57, 33 , 7, 8, 2,3,4,5,7,8,9,11,12,13,14,15,19,20,21,22,23,26,27,29,30,31,32,33,38,39,40,44,45,50,51},
//	{58, 14 , 3, 6, 0,1,2,3,4,5,12,13,14,15,16,17},
//	{59, 14 , 3, 7, 0,1,2,3,4,5,13,14,16,17,18,19},
//	{60, 21 , 8, 6, 6,7,11,12,13,14,16,17,18,19,24,25,26,27,35,36,37,45,46},
//	{61, 14 , 6, 4, 0,1,2,3,4,5,18,19,20,21,22,23},
//	{62, 21 , 8, 6, 0,1,9,10,11,12,20,21,22,23,28,29,30,31,34,35,36,41,42},
//	{63, 25 , 7, 9, 1,2,3,4,5,7,8,12,13,19,20,25,26,31,32,38,39,51,52,53,58,59,60},
//	{64, 73 , 12, 10, 3,4,5,6,7,8,9,14,15,16,20,21,22,25,26,34,35,36,37,40,41,42,43,44,46,47,48,49,51,52,53,55,56,58,59,60,61,63,64,67,68,70,71,72,73,75,76,78,79,81,82,85,86,87,88,89,90,91,92,93,97,98,99,104,105,111,112,113,114,115,116},
//	{65, 41 , 9, 9, 3,4,5,12,13,14,21,22,23,24,29,30,31,32,33,38,39,41,42,46,47,48,50,51,52,55,56,57,58,59,60,61,63,64,69,70,72,79,80},
//	{66, 46 , 8, 9, 0,1,2,3,4,5,6,9,10,13,14,15,17,18,22,23,25,26,29,30,33,34,35,36,37,38,41,42,45,46,47,49,50,54,55,57,58,61,62,65,66,67,68,69},
//	{67, 33 , 8, 9, 3,4,5,6,7,9,10,11,14,15,17,18,24,25,32,33,40,41,48,49,50,57,58,59,62,63,66,67,68,69,70},
//	{68, 44 , 9, 9, 0,1,2,3,4,5,6,10,11,14,15,16,19,20,24,25,26,28,29,34,35,37,38,43,44,46,47,52,53,55,56,60,61,64,65,68,69,73,74,75,76,77},
//	{69, 31 , 7, 9, 0,1,2,3,4,5,6,8,9,15,16,22,23,29,30,31,32,33,36,37,43,44,50,51,57,58,59,60,61},
//	{70, 27 , 6, 9, 0,1,2,3,4,5,7,8,13,14,19,20,25,26,27,28,29,31,32,37,38,43,44,49,50},
//	{71, 41 , 9, 9, 3,4,5,6,7,10,11,12,15,16,19,20,27,28,36,37,45,46,48,49,50,51,52,53,54,55,56,61,62,64,65,66,69,70,74,75,76,77,78},
//	{72, 43 , 9, 9, 0,1,2,7,8,10,11,16,17,19,20,25,26,28,29,34,35,37,38,39,40,41,42,43,44,46,47,52,53,55,56,61,62,64,65,70,71,73,74,79,80},
//	{73, 21 , 3, 9, 0,1,2,4,5,7,8,10,11,13,14,16,17,19,20,22,23,25,26},
//	{74, 23 , 3, 10, 0,1,2,4,5,7,8,10,11,13,14,16,17,19,20,22,23,25,26,27,28},
//	{75, 46 , 9, 9, 0,1,2,6,7,8,10,11,14,15,16,19,20,22,23,24,28,29,31,32,37,38,39,40,46,47,48,49,50,55,56,58,59,60,64,65,68,69,70,73,74,78,79,80},
//	{76, 24 , 6, 9, 0,1,2,7,8,13,14,19,20,25,26,31,32,37,38,43,44,49,50,51,52,53},
//	{77, 66 , 10, 9, 0,1,2,3,7,8,9,11,12,13,17,18,19,21,22,23,26,27,28,29,31,32,33,34,36,37,38,39,40,41,43,44,45,46,48,49,50,51,53,54,55,56,58,59,60,61,63,64,65,66,68,69,70,71,74,75,78,79,80,81,84,85,88,89},
//	{78, 54 , 9, 9, 0,1,2,3,7,8,10,11,12,13,16,17,19,20,21,22,25,26,28,29,30,31,32,34,35,37,38,40,41,43,44,46,47,50,51,52,53,55,56,59,60,61,62,64,65,69,70,71,73,74,79,80},
//	{79, 46 , 9, 9, 1,2,3,4,5,6,9,10,11,14,15,16,18,19,24,25,26,27,28,34,35,36,37,43,44,45,46,52,53,54,55,56,60,61,64,65,66,69,70,74,75,76,77,78},
//	{80, 37 , 8, 9, 0,1,2,3,4,5,6,9,10,13,14,15,17,18,22,23,25,26,30,31,33,34,36,37,38,41,42,43,44,49,50,57,58,65,66},
//	{81, 54 , 9, 9, 1,2,3,4,5,6,9,10,11,14,15,16,18,19,24,25,26,27,28,34,35,36,37,43,44,45,46,49,50,52,53,54,55,56,58,59,60,61,62,64,65,66,68,69,70,74,75,76,77,78,79,80},
//	{82, 47 , 9, 9, 0,1,2,3,4,5,6,10,11,14,15,16,19,20,24,25,28,29,33,34,37,38,41,42,46,47,48,49,50,55,56,57,58,59,64,65,67,68,69,70,73,74,78,79,80},
//	{83, 37 , 7, 9, 2,3,4,5,6,7,8,9,12,13,14,15,21,22,23,29,30,31,32,33,39,40,41,47,48,49,50,54,55,56,57,58,59,60,61},
//	{84, 23 , 5, 9, 0,1,2,3,4,6,7,11,12,16,17,21,22,26,27,31,32,36,37,41,42},
//	{85, 41 , 9, 9, 0,1,2,7,8,10,11,16,17,19,20,25,26,28,29,34,35,37,38,43,44,46,47,52,53,55,56,61,62,64,65,66,69,70,74,75,76,77,78},
//	{86, 36 , 9, 9, 0,1,2,7,8,10,11,15,16,19,20,21,24,25,29,30,32,33,38,39,41,42,47,48,50,51,57,58,59,66,67,68,75,76},
//	{87, 66 , 13, 9, 0,1,2,6,7,11,12,14,15,18,19,20,23,24,27,28,31,32,33,36,37,40,41,42,44,45,46,47,49,50,54,55,56,57,59,60,61,62,67,68,69,70,72,73,74,75,80,81,82,83,85,86,87,93,94,95,98,99,100,107,108,111,112,113},
//	{88, 43 , 9, 9, 0,1,2,6,7,8,10,11,12,14,15,16,20,21,22,23,24,29,30,31,32,39,40,41,47,48,49,50,56,57,58,59,60,64,65,68,69,72,73,78,79},
//	{89, 39 , 9, 10, 0,1,2,6,7,8,10,11,12,15,16,19,20,21,24,25,29,30,32,33,38,39,40,41,42,48,49,50,57,58,59,66,67,75,76,83,84},
//	{90, 35 , 8, 9, 0,1,2,3,4,5,6,7,8,9,13,14,20,21,27,28,29,35,36,42,43,49,50,51,57,58,64,65,66,67,68,69,70},
//	{91, 24 , 3, 10, 0,1,2,3,4,6,7,9,10,12,13,15,16,18,19,21,22,24,25,27,28,29},
//	{92, 20 , 4, 10, 0,1,4,5,8,9,13,14,17,18,21,22,26,27,30,31,35,39},
//	{93, 24 , 3, 10, 0,1,2,4,5,7,8,10,11,13,14,16,17,19,20,22,23,25,26,27,28,29},
//	{94, 18 , 8, 3, 2,3,4,5,9,10,11,12,13,14,16,17,18,21,22,23},
//	{95, 7 , 5, 1, 0,1,2,3,4},
//	{96, 8 , 4, 2, 0,1,2,5,6,7},
//	{97, 31 , 7, 6, 2,3,4,5,6,8,9,12,13,14,15,19,20,21,22,25,26,27,28,29,31,32,33,34,36,37,38,40,41},
//	{98, 36 , 8, 9, 0,1,2,9,10,17,18,25,26,27,28,29,30,33,34,35,38,39,41,42,46,47,49,50,54,55,57,58,61,62,66,67,68,69},
//	{99, 21 , 6, 6, 2,3,4,5,7,8,10,11,12,13,18,19,24,25,26,31,32,33,34},
//	{100, 38 , 7, 9, 4,5,6,12,13,19,20,23,24,25,26,27,29,30,33,34,35,36,40,41,42,43,46,47,48,49,50,52,53,54,55,57,58,59,61,62},
//	{101, 29 , 7, 6, 2,3,4,5,6,8,9,12,13,14,15,18,19,20,21,22,23,24,25,28,29,30,36,37,38,39,40},
//	{102, 29 , 5, 11, 2,3,4,6,7,8,11,12,15,16,17,18,19,21,22,26,27,31,32,36,37,41,42,46,47,51,52},
//	{103, 38 , 7, 9, 2,3,4,5,6,8,9,12,13,14,15,19,20,21,22,25,26,27,28,29,31,32,33,34,36,37,38,40,41,47,48,53,54,58,59,60},
//	{104, 38 , 8, 9, 0,1,2,9,10,17,18,25,26,28,29,30,31,33,34,35,36,38,39,41,42,43,46,47,49,50,54,55,57,58,62,63,65,66,70,71},
//	{105, 21 , 4, 9, 1,2,3,5,6,7,12,13,14,17,18,21,22,25,26,29,30,33,34},
//	{106, 27 , 4, 12, 1,2,3,5,6,7,12,13,14,17,18,21,22,25,26,29,30,33,34,37,38,41,42,44,45},
//	{107, 33 , 7, 9, 0,1,2,8,9,15,16,22,23,26,27,29,30,32,33,36,37,38,39,43,44,45,46,50,51,53,54,57,58,61,62},
//	{108, 21 , 3, 9, 0,1,2,4,5,7,8,10,11,13,14,16,17,19,20,22,23,25,26},
//	{109, 48 , 12, 6, 0,1,2,3,4,5,6,8,9,10,11,13,14,15,17,18,19,20,22,23,25,26,27,29,30,31,34,35,37,38,41,42,46,47,49,50,53,54,58,59,61,62,65,66,70,71},
//	{110, 31 , 8, 6, 0,1,2,4,5,6,9,10,11,12,14,15,17,18,19,22,23,25,26,30,31,33,34,38,39,41,42,46,47},
//	{111, 29 , 7, 6, 1,2,3,4,5,8,9,11,12,13,14,15,19,20,21,22,26,27,28,29,30,32,33,36,37,38,39},
//	{112, 37 , 8, 9, 0,1,2,3,4,5,6,9,10,11,14,15,17,18,22,23,25,26,30,31,33,34,37,38,41,42,43,44,45,49,50,57,58,65,66},
//	{113, 37 , 7, 9, 2,3,4,5,6,8,9,12,13,14,15,19,20,21,22,25,26,27,28,29,31,32,33,34,36,37,38,40,41,47,48,54,55,61,62},
//	{114, 19 , 5, 6, 0,1,2,3,4,6,7,8,11,12,13,16,17,21,22,26,27},
//	{115, 25 , 6, 6, 1,2,3,4,5,6,7,10,11,12,13,14,19,20,21,22,23,28,29,31,32,33,34},
//	{116, 21 , 4, 8, 1,2,5,6,8,9,10,11,13,14,17,18,21,22,25,26,29,30,31},
//	{117, 33 , 8, 6, 0,1,2,6,7,9,10,14,15,17,18,21,22,23,25,26,29,30,31,33,34,36,37,38,39,41,42,43,44,46,47},
//	{118, 26 , 7, 6, 0,1,2,6,8,9,12,13,15,16,17,19,20,23,24,25,26,30,31,32,33,37,38,39},
//	{119, 40 , 10, 6, 0,1,2,5,6,9,11,12,14,15,16,18,19,21,22,24,25,26,28,29,31,32,33,34,35,36,37,38,42,43,44,46,47,48,52,53,56,57},
//	{120, 29 , 7, 6, 0,1,2,4,5,6,8,9,10,11,12,16,17,18,23,24,25,29,30,31,32,33,35,36,39,40,41},
//	{121, 32 , 7, 8, 0,1,2,5,6,8,9,12,13,15,16,17,19,20,23,24,25,26,30,31,32,33,38,39,44,45,46,50,51,52},
//	{122, 25 , 7, 6, 0,1,2,3,4,5,6,7,8,11,12,17,18,23,24,29,30,35,36,37,38,39,40},
//	{123, 26 , 4, 11, 1,2,3,5,6,9,10,13,14,17,18,20,21,25,26,29,30,33,34,37,38,41,42,43},
//	{124, 26 , 2, 12, 0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23},
//	{125, 26 , 4, 11, 0,1,2,5,6,9,10,13,14,17,18,22,23,25,26,29,30,33,34,37,38,40,41,42},
//	{126, 13 , 8, 2, 1,2,3,4,6,7,8,9,12,13,14}
//};
//
//BYTE font16_2[][400][400] = {
//	{
//		{}
//	},
//	{
//		{0,1,1,0,0,0,0,0,0,0},
//		{1,1,1,1,1,0,1,0,0,0},
//		{1,0,0,1,1,1,1,0,0,0},
//		{1,1,1,1,0,1,0,0,0,0},
//		{1,1,1,1,1,1,1,1,1,0},
//		{0,0,0,0,1,1,1,0,1,1},
//		{0,0,0,1,0,1,1,1,0,1},
//		{0,0,0,1,0,1,1,1,0,0},
//		{0,0,1,0,0,0,1,1,1,0}
//	},
//	{
//		{1},
//		{1},
//		{1}
//	},
//	{
//		{0,0,1},
//		{1,0,0},
//		{1,0,0},
//		{1,0,0},
//		{1,0,0},
//		{1,0,0},
//		{1,0,0},
//		{1,0,0},
//		{1,0,0},
//		{1,0,0},
//		{1,1,0},
//		{0,0,1}
//	},
//	{
//		{1,0},
//		{1,1},
//		{0,1},
//		{0,1},
//		{0,1},
//		{0,1},
//		{0,1},
//		{0,1},
//		{0,1},
//		{0,1},
//		{0,1}
//	},
//	{
//		{0,0,1,0,0},
//		{1,0,1,0,0},
//		{1,1,1,1,1},
//		{1,0,1,0,0},
//		{0,1,1,1,0}
//	},
//	{
//		{0,1},
//		{1,1},
//		{1,0}
//	},
//	{
//		{1,1}
//	},
//	{
//		{0,0,0,0,0,1},
//		{0,0,0,0,0,1},
//		{0,0,0,0,1,0},
//		{0,0,0,0,1,0},
//		{0,0,0,1,0,0},
//		{0,0,1,1,0,0},
//		{0,0,1,1,0,0},
//		{0,0,1,0,0,0},
//		{0,1,0,0,0,0},
//		{0,1,0,0,0,0},
//		{1,0,0,0,0,0},
//		{1,0,0,0,0,0}
//	},
//	{
//		{0,0,0,0,1,1,0,0,0},
//		{0,0,1,1,1,1,1,1,0},
//		{0,1,0,0,0,0,1,1,0},
//		{1,1,0,0,0,1,1,1,1},
//		{1,0,0,0,1,0,0,0,1},
//		{1,0,0,1,0,0,0,0,1},
//		{1,0,1,0,0,0,0,1,1},
//		{0,1,1,0,0,0,0,1,0},
//		{0,0,1,1,1,0,1,0,0},
//		{0,0,0,0,1,0,0,0,0}
//	},
//	{
//		{0,1},
//		{1,0},
//		{1,0},
//		{1,0},
//		{1,0},
//		{1,0},
//		{1,0},
//		{1,0},
//		{1,0}
//	},
//	{
//		{0,0,1,0,0,0},
//		{0,1,1,0,1,0},
//		{1,1,0,0,1,1},
//		{1,1,0,0,1,1},
//		{0,0,0,0,1,0},
//		{0,0,0,1,1,0},
//		{0,0,1,1,0,0},
//		{0,1,1,0,0,0},
//		{1,1,1,1,1,1}
//	},
//	{
//		{0,1,1,1,0,0},
//		{1,1,1,1,1,1},
//		{1,0,0,0,1,0},
//		{0,0,0,1,0,0},
//		{0,0,1,1,1,0},
//		{0,0,0,0,1,1},
//		{0,1,0,0,0,1},
//		{0,1,0,0,0,1},
//		{0,1,1,0,1,0}
//	},
//	{
//		{0,0,0,0,1,0,0},
//		{0,0,0,1,1,0,0},
//		{0,0,0,1,1,0,0},
//		{0,0,1,0,1,0,0},
//		{0,1,0,0,1,0,0},
//		{1,1,1,1,1,1,1},
//		{0,0,0,0,1,0,0},
//		{0,0,0,0,1,0,0}
//	},
//	{
//		{0,1,1,0,1,0},
//		{0,1,0,0,0,0},
//		{0,1,0,0,0,0},
//		{1,1,1,1,1,0},
//		{0,1,0,0,1,1},
//		{1,1,0,0,0,1},
//		{1,1,0,0,1,1},
//		{0,1,1,1,1,0}
//	},
//	{
//		{0,0,0,0,0,1},
//		{0,0,0,1,1,0},
//		{0,0,0,1,0,0},
//		{0,0,1,1,0,0},
//		{0,1,1,1,1,0},
//		{0,1,0,0,0,1},
//		{1,1,0,0,0,1},
//		{0,1,0,0,0,1},
//		{0,1,1,1,1,0},
//		{0,0,0,1,0,0}
//	},
//	{
//		{0,0,1,1,0,0},
//		{1,1,1,0,1,1},
//		{0,0,0,0,1,0},
//		{0,0,0,0,1,0},
//		{0,0,0,0,1,0},
//		{0,0,0,1,0,0},
//		{0,0,0,1,0,0},
//		{0,0,1,0,0,0},
//		{0,0,1,0,0,0}
//	},
//	{
//		{0,0,1,1,0,0},
//		{0,1,1,1,1,0},
//		{1,1,0,0,1,0},
//		{0,1,0,1,1,0},
//		{0,1,1,1,0,0},
//		{1,1,0,0,1,0},
//		{1,0,0,0,1,1},
//		{1,1,0,0,1,0},
//		{0,1,1,1,1,0},
//		{0,0,1,0,0,0}
//	},
//	{
//		{0,0,0,1,0,0},
//		{0,1,1,1,1,1},
//		{1,1,0,0,0,1},
//		{1,1,0,0,0,1},
//		{0,1,0,0,1,1},
//		{0,0,1,1,1,0},
//		{0,0,0,1,0,0},
//		{0,0,0,1,0,0},
//		{0,0,1,0,0,0}
//	},
//	{
//		{1,0},
//		{1,1},
//		{0,0},
//		{0,0},
//		{0,0},
//		{1,0},
//		{1,1}
//	},
//	{
//		{0,0,0,0,1,0,0,0},
//		{0,0,0,1,1,0,0,0},
//		{0,0,0,1,0,1,0,0},
//		{0,0,1,0,0,1,0,0},
//		{0,0,1,0,0,0,1,0},
//		{0,1,0,0,0,0,1,0},
//		{0,1,1,1,1,0,1,1},
//		{1,1,0,0,0,0,0,1},
//		{1,1,0,0,0,0,0,1}
//	},
//	{
//		{1,1,1,1,1},
//		{1,1,0,0,1},
//		{1,1,0,1,1},
//		{1,1,1,1,1},
//		{1,1,0,0,1},
//		{1,1,0,0,1},
//		{1,1,0,0,1},
//		{1,1,1,1,1},
//		{1,1,0,0,0}
//	},
//	{
//		{0,0,0,0,1,0,0},
//		{0,0,1,1,1,1,1},
//		{0,1,0,0,0,0,1},
//		{0,1,0,0,0,0,0},
//		{1,0,0,0,0,0,0},
//		{1,1,0,0,0,0,0},
//		{1,1,0,0,0,0,0},
//		{0,1,1,0,0,0,0},
//		{0,0,1,1,1,1,1},
//		{0,0,0,1,1,1,0}
//	},
//	{
//		{1,1,1,0},
//		{0,0,1,1},
//		{0,0,0,1},
//		{0,0,0,1},
//		{0,0,0,1},
//		{0,0,0,1},
//		{0,0,1,1},
//		{1,1,1,0}
//	},
//	{
//		{0,1,1,1,1},
//		{0,1,0,0,0},
//		{1,1,0,0,0},
//		{1,1,1,1,1},
//		{1,1,1,1,1},
//		{1,1,0,0,0},
//		{1,1,0,0,0},
//		{1,1,1,1,1},
//		{1,1,1,1,1}
//	},
//	{
//		{1,1,1,1,1,0},
//		{0,1,0,0,0,0},
//		{1,1,0,0,0,0},
//		{1,1,1,0,1,1},
//		{1,1,1,0,1,0},
//		{1,1,0,0,0,0},
//		{0,1,0,0,0,0},
//		{0,1,0,0,0,0}
//	},
//	{
//		{0,1,1,1,1,1,1},
//		{0,1,1,0,0,0,0},
//		{1,0,0,0,0,0,0},
//		{1,0,0,0,0,1,1},
//		{1,0,0,0,0,1,1},
//		{1,0,0,0,0,0,1},
//		{0,1,0,0,0,0,1},
//		{0,0,1,1,1,1,1},
//		{0,0,0,1,1,0,0}
//	},
//	{
//		{0,0,0,0,0,0,1},
//		{1,1,0,0,0,1,0},
//		{0,1,0,0,0,1,0},
//		{0,1,0,0,0,1,0},
//		{1,1,1,1,1,1,0},
//		{1,1,1,1,1,1,1},
//		{1,1,0,0,0,1,0},
//		{1,1,0,0,0,1,1},
//		{1,1,0,0,0,1,1},
//		{1,1,0,0,0,1,0}
//	},
//	{
//		{1,1},
//		{1,1},
//		{0,1},
//		{0,1},
//		{1,1},
//		{1,1},
//		{1,1},
//		{1,1}
//	},
//	{
//		{1,1},
//		{1,1},
//		{1,1},
//		{1,1},
//		{1,1},
//		{1,1},
//		{1,1},
//		{1,1},
//		{1,1},
//		{1,0}
//	},
//	{
//		{0,1,0,0,1,0,0},
//		{0,1,0,1,1,0,0},
//		{0,1,1,1,0,0,0},
//		{0,1,1,0,0,0,0},
//		{0,1,1,0,0,0,0},
//		{0,1,0,1,0,0,0},
//		{0,1,0,0,1,0,0},
//		{0,1,0,0,0,1,1},
//		{1,1,0,0,0,0,1}
//	},
//	{
//		{1,0,0,0,0},
//		{1,0,0,0,0},
//		{1,0,0,0,0},
//		{1,0,0,0,0},
//		{1,0,0,0,0},
//		{1,0,0,0,0},
//		{1,0,0,0,0},
//		{1,1,1,1,0},
//		{1,0,1,1,1}
//	},
//	{
//		{0,0,0,1,1,0,0,0,0},
//		{1,1,1,1,1,1,1,1,1},
//		{1,0,0,1,1,0,0,1,1},
//		{1,0,0,1,1,0,0,1,1},
//		{1,0,0,1,1,0,0,1,1},
//		{1,0,0,1,1,0,0,1,1},
//		{1,0,0,1,1,0,0,1,1},
//		{1,0,0,1,1,0,0,1,1},
//		{1,0,0,1,1,0,0,1,1},
//		{1,0,0,1,1,0,0,1,1}
//	},
//	{
//		{1,1,0,0,0,0,1,1},
//		{0,1,0,0,0,0,1,0},
//		{0,1,1,1,0,0,1,0},
//		{1,1,0,1,0,0,1,0},
//		{1,1,0,0,1,0,1,0},
//		{1,1,0,0,0,1,1,0},
//		{1,1,0,0,0,0,1,0},
//		{1,1,0,0,0,0,0,1},
//		{1,1,0,0,0,0,1,1}
//	},
//	{
//		{0,0,0,0,1,0,0,0,0},
//		{0,1,1,1,1,1,1,1,0},
//		{0,1,1,0,1,0,0,1,0},
//		{1,1,0,0,1,0,0,1,1},
//		{1,1,1,1,1,1,1,1,1},
//		{1,1,1,1,1,1,1,1,1},
//		{1,1,0,0,1,0,0,1,1},
//		{0,1,0,0,1,0,1,1,0},
//		{0,0,1,1,1,1,1,0,0},
//		{0,0,0,1,1,0,0,0,0}
//	},
//	{
//		{1,1,1,1,1,0},
//		{1,1,0,0,1,0},
//		{1,1,0,0,1,1},
//		{0,1,0,0,1,0},
//		{0,1,1,1,0,0},
//		{1,1,0,0,0,0},
//		{1,1,0,0,0,0},
//		{1,1,0,0,0,0}
//	},
//	{
//		{0,0,1,1,1,1,1,0,0},
//		{0,1,0,0,0,0,1,1,0},
//		{1,1,0,0,0,0,0,1,1},
//		{1,0,0,0,0,0,0,1,1},
//		{1,0,0,0,0,0,0,0,1},
//		{1,0,0,0,1,0,0,1,1},
//		{1,1,0,0,1,0,0,1,0},
//		{0,1,1,1,1,1,1,0,0},
//		{0,0,0,1,1,1,0,0,0},
//		{0,0,0,0,1,0,0,0,0}
//	},
//	{
//		{1,1,1,1,0,0,0},
//		{1,0,0,0,1,0,0},
//		{1,0,0,0,1,0,0},
//		{1,0,0,1,1,0,0},
//		{0,1,1,1,0,0,0},
//		{0,0,0,1,0,0,0},
//		{0,1,0,0,1,0,0},
//		{1,1,0,0,0,1,1},
//		{1,0,0,0,0,0,1}
//	},
//	{
//		{0,1,1,1,1},
//		{1,1,0,0,1},
//		{1,1,0,0,0},
//		{0,1,1,0,0},
//		{0,0,0,1,1},
//		{0,0,0,0,1},
//		{1,1,0,0,1},
//		{1,1,1,1,1}
//	},
//	{
//		{1,1,1,1,1,1,1,1,1},
//		{0,0,0,0,0,1,0,0,0},
//		{0,0,0,0,1,1,0,0,0},
//		{0,0,0,0,0,1,0,0,0},
//		{0,0,0,0,1,1,0,0,0},
//		{0,0,0,0,1,1,0,0,0},
//		{0,0,0,0,0,1,0,0,0},
//		{0,0,0,0,1,1,0,0,0},
//		{0,0,0,0,1,1,0,0,0}
//	},
//	{
//		{1,1,0,0,0,0,0,0,1,1},
//		{1,1,0,0,0,0,0,0,1,1},
//		{1,1,0,0,0,0,0,0,1,1},
//		{1,1,0,0,0,0,0,0,1,1},
//		{1,1,0,0,0,0,0,0,1,1},
//		{0,1,1,0,0,0,0,0,1,1},
//		{0,1,0,0,0,0,0,0,1,0},
//		{0,0,1,1,1,1,1,1,0,0},
//		{0,0,0,0,1,1,0,0,0,0}
//	},
//	{
//		{1,1,0,0,0,0,0,0,1},
//		{0,1,0,0,0,0,0,1,1},
//		{0,1,1,0,0,0,0,1,0},
//		{0,0,1,0,0,0,1,1,0},
//		{0,0,0,1,0,0,1,0,0},
//		{0,0,0,1,0,1,1,0,0},
//		{0,0,0,0,1,1,0,0,0},
//		{0,0,0,0,1,0,0,0,0}
//	},
//	{
//		{1,1,0,0,1,1,0,0,1,0,0,1,1},
//		{0,1,0,0,0,1,0,1,1,0,0,1,0},
//		{0,1,1,0,0,1,1,1,0,0,0,1,0},
//		{0,0,1,0,0,0,1,1,0,0,1,0,0},
//		{0,0,1,1,0,0,1,0,0,0,1,0,0},
//		{0,0,0,1,0,1,1,1,0,1,0,0,0},
//		{0,0,0,1,1,1,0,1,1,1,0,0,0},
//		{0,0,0,0,1,1,0,0,1,0,0,0,0},
//		{0,0,0,0,1,0,0,0,0,0,0,0,0}
//	},
//	{
//		{1,0,0,0,0,0,0,1},
//		{0,1,0,0,0,0,1,1},
//		{0,0,1,0,0,1,0,0},
//		{0,0,0,1,1,0,0,0},
//		{0,0,0,1,1,0,0,0},
//		{0,0,1,0,0,1,0,0},
//		{0,1,0,0,0,0,1,0},
//		{1,0,0,0,0,0,0,1},
//		{1,0,0,0,0,0,0,0}
//	},
//	{
//		{0,0,0,0,0,0,0,1,0},
//		{1,1,0,0,0,0,0,1,1},
//		{0,1,1,0,0,0,1,1,0},
//		{0,0,1,1,0,1,1,0,0},
//		{0,0,1,1,1,1,0,0,0},
//		{0,0,0,0,1,0,0,0,0},
//		{0,0,0,0,1,0,0,0,0},
//		{0,0,0,0,1,0,0,0,0},
//		{0,0,0,0,1,0,0,0,0},
//		{0,0,0,1,1,0,0,0,0}
//	},
//	{
//		{1,1,1,1,1,1},
//		{0,0,0,0,1,1},
//		{0,0,0,0,1,0},
//		{0,0,0,1,1,0},
//		{0,0,0,1,0,0},
//		{0,0,1,0,0,0},
//		{0,1,1,0,0,0},
//		{0,1,1,1,1,1},
//		{0,1,1,1,0,1}
//	},
//	{
//		{0,0,0,1,0,0},
//		{0,0,0,1,0,0},
//		{0,0,1,0,1,0},
//		{0,1,0,0,1,0},
//		{0,1,0,0,0,1},
//		{1,1,1,0,0,1},
//		{1,0,0,0,0,0}
//	},
//	{
//		{1,1,1,0},
//		{1,0,0,0},
//		{1,1,1,0},
//		{1,0,1,1},
//		{1,0,0,1},
//		{1,0,1,0}
//	},
//	{
//		{0,0,0,1,1,1},
//		{0,0,1,0,1,1},
//		{0,1,0,0,0,0},
//		{0,1,0,0,0,0},
//		{1,1,0,0,0,0},
//		{0,1,0,0,0,0},
//		{0,0,1,0,0,0},
//		{0,0,0,1,0,1}
//	},
//	{
//		{1,1,1,0,1,0},
//		{1,1,0,0,0,1},
//		{1,1,0,0,0,1},
//		{1,1,0,0,0,1},
//		{1,1,0,0,0,1},
//		{1,1,0,0,1,0},
//		{0,1,1,1,0,0}
//	},
//	{
//		{1,1,1,1},
//		{1,0,0,0},
//		{1,1,1,1},
//		{1,1,1,1},
//		{0,0,0,0},
//		{1,0,0,0},
//		{0,0,0,1}
//	},
//	{
//		{1,1,1,1},
//		{1,1,0,0},
//		{1,1,1,1},
//		{1,1,1,1},
//		{1,1,0,0},
//		{0,1,0,0}
//	},
//	{
//		{0,0,0,1,1,0},
//		{0,1,1,1,1,1},
//		{0,0,0,0,0,0},
//		{1,0,0,0,0,0},
//		{1,0,0,1,1,1},
//		{0,1,0,0,0,1},
//		{0,1,0,0,0,1},
//		{0,0,1,1,1,0}
//	},
//	{
//		{0,0,0,0,1},
//		{0,0,0,0,1},
//		{1,0,0,0,1},
//		{1,1,1,1,1},
//		{1,1,1,0,1},
//		{1,0,0,0,1},
//		{1,1,0,0,1},
//		{1,0,0,0,1}
//	},
//	{
//		{1},
//		{1},
//		{1},
//		{1},
//		{1},
//		{1},
//		{1}
//	},
//	{
//		{1,0,1,1},
//		{1,1,0,0},
//		{1,0,0,0},
//		{1,1,0,0},
//		{1,0,1,0},
//		{1,0,0,1},
//		{1,0,0,0}
//	},
//	{
//		{1,0,0},
//		{1,0,0},
//		{1,0,0},
//		{1,0,0},
//		{1,0,0},
//		{1,0,0},
//		{1,1,1}
//	},
//	{
//		{0,0,1,1,0,0,0},
//		{1,1,1,1,1,1,1},
//		{1,0,0,1,0,0,1},
//		{1,0,0,1,0,0,1},
//		{1,0,0,1,0,0,1},
//		{1,0,0,1,0,0,1},
//		{1,0,0,1,0,0,1},
//		{1,0,0,1,0,0,1}
//	},
//	{
//		{1,0,0,0,1,1},
//		{1,1,0,0,1,1},
//		{1,0,1,0,1,1},
//		{1,0,1,1,1,1},
//		{1,0,0,1,1,1},
//		{1,0,0,0,1,1},
//		{1,0,0,0,0,1}
//	},
//	{
//		{0,0,0,1,0,0,0},
//		{0,1,1,1,1,1,0},
//		{1,0,0,1,0,0,1},
//		{1,0,0,1,0,0,1},
//		{1,1,1,1,1,1,1},
//		{1,1,0,1,0,0,1},
//		{0,1,1,1,1,1,0},
//		{0,0,1,1,1,0,0}
//	},
//	{
//		{1,1,1,1},
//		{0,0,0,1},
//		{0,0,0,1},
//		{1,1,1,0},
//		{0,0,0,0},
//		{1,0,0,0}
//	},
//	{
//		{0,0,0,1,0,0,0},
//		{0,1,1,1,1,1,0},
//		{1,0,0,0,0,1,1},
//		{1,0,0,0,0,0,1},
//		{1,0,0,0,0,0,1},
//		{1,0,0,1,0,0,1},
//		{0,1,0,1,1,1,0},
//		{0,0,1,1,0,0,0},
//		{0,0,0,1,0,0,0}
//	},
//	{
//		{1,0,1,1,0},
//		{0,0,0,1,0},
//		{1,1,0,1,0},
//		{1,1,1,0,0},
//		{0,0,0,1,0},
//		{0,0,0,0,1}
//	},
//	{
//		{0,1,1,1,0},
//		{1,1,0,0,0},
//		{0,1,1,0,0},
//		{0,0,0,1,0},
//		{0,0,0,0,1},
//		{1,1,0,0,0},
//		{0,1,1,1,0}
//	},
//	{
//		{1,0,0,0,0,0,0},
//		{1,1,1,1,1,1,1},
//		{0,0,0,1,0,0,0},
//		{0,0,0,1,0,0,0},
//		{0,0,0,1,0,0,0},
//		{0,0,0,1,0,0,0},
//		{0,0,0,1,0,0,0}
//	},
//	{
//		{0,0,0,1},
//		{0,0,0,1},
//		{0,0,0,1},
//		{0,0,0,1},
//		{0,0,0,1},
//		{0,0,1,0},
//		{1,1,0,0}
//	},
//	{
//		{0,0,0,0,0,0,0,1},
//		{1,0,0,0,0,0,1,0},
//		{1,1,0,0,0,1,0,0},
//		{0,1,0,0,0,1,0,0},
//		{0,0,1,0,1,0,0,0},
//		{0,0,1,0,1,0,0,0},
//		{0,0,0,1,0,0,0,0},
//		{0,0,0,1,0,0,0,0}
//	},
//	{
//		{1,0,0,0,0,0,0,0,0,0},
//		{1,0,0,0,0,1,1,0,1,1},
//		{1,0,0,1,0,1,0,0,1,0},
//		{0,1,0,1,1,1,0,1,1,0},
//		{0,1,0,0,1,0,0,1,0,0},
//		{0,0,1,1,1,1,0,0,0,0},
//		{0,0,1,1,0,1,1,0,0,0}
//	},
//	{
//		{1,0,0,0,0,1,1},
//		{0,1,0,0,1,0,0},
//		{0,0,1,1,0,0,0},
//		{0,0,1,1,0,0,0},
//		{0,1,0,0,1,0,0},
//		{1,0,0,0,0,1,0}
//	},
//	{
//		{0,1,0,0,0,0,0,0},
//		{1,1,0,0,0,0,1,1},
//		{0,0,1,0,0,1,0,0},
//		{0,0,0,1,1,0,0,0},
//		{0,0,0,0,0,0,0,0},
//		{0,0,0,1,0,0,0,0},
//		{0,0,0,1,0,0,0,0}
//	},
//	{
//		{1,1,1,0,1,1},
//		{0,0,0,0,1,0},
//		{0,0,0,1,0,0},
//		{0,0,1,0,0,0},
//		{0,0,1,0,0,0},
//		{0,1,0,0,0,0},
//		{0,1,1,1,1,1}
//	}
//};

//http://msdn.microsoft.com/en-us/library/dd183402(v=vs.85).aspx
BYTE* CaptureAnImage(HWND hWnd, string filename = "default.bmp"){
	HDC hdcWindow;
	HDC hdcMemDC = NULL;
	HBITMAP hbmScreen = NULL;
	BITMAP bmpScreen;

	// Retrieve the handle to a display device context for the client 
	// area of the window. 
	hdcWindow = GetDC(hWnd);

	// Create a compatible DC which is used in a BitBlt from the window DC
	hdcMemDC = CreateCompatibleDC(hdcWindow);

	if (!hdcMemDC)
		goto done;

	// Get the client area for size calculation
	RECT rcClient;
	GetClientRect(hWnd, &rcClient);

	//This is the best stretch mode
	SetStretchBltMode(hdcWindow, HALFTONE);

	// Create a compatible bitmap from the Window DC
	hbmScreen = CreateCompatibleBitmap(hdcWindow, rcClient.right - rcClient.left, rcClient.bottom - rcClient.top);

	if (!hbmScreen)
		goto done;

	// Select the compatible bitmap into the compatible memory DC.
	SelectObject(hdcMemDC, hbmScreen);

	// Bit block transfer into our compatible memory DC.
	if (!BitBlt(hdcMemDC, 0, 0, rcClient.right - rcClient.left, rcClient.bottom - rcClient.top, hdcWindow, 0, 0, SRCCOPY))
		goto done;

	// Get the BITMAP from the HBITMAP
	GetObject(hbmScreen, sizeof(BITMAP), &bmpScreen);

	BITMAPFILEHEADER   bmfHeader;
	BITMAPINFOHEADER   bi;

	bi.biSize = sizeof(BITMAPINFOHEADER);
	bi.biWidth = bmpScreen.bmWidth;
	bi.biHeight = bmpScreen.bmHeight;
	bi.biPlanes = 1;
	bi.biBitCount = 24;
	bi.biCompression = BI_RGB;
	bi.biSizeImage = 0;
	bi.biXPelsPerMeter = 0;
	bi.biYPelsPerMeter = 0;
	bi.biClrUsed = 0;
	bi.biClrImportant = 0;

	DWORD dwBmpSize = ((bmpScreen.bmWidth * bi.biBitCount + 31) / 24) * 4 * bmpScreen.bmHeight;

	// Starting with 32-bit Windows, GlobalAlloc and LocalAlloc are implemented as wrapper functions that 
	// call HeapAlloc using a handle to the process's default heap. Therefore, GlobalAlloc and LocalAlloc 
	// have greater overhead than HeapAlloc.
	HANDLE hDIB = GlobalAlloc(GHND, dwBmpSize);
	BYTE *lpbitmap = (BYTE *)GlobalLock(hDIB);

	// Gets the "bits" from the bitmap and copies them into a buffer 
	// which is pointed to by lpbitmap.
	GetDIBits(hdcWindow, hbmScreen, 0, (UINT)bmpScreen.bmHeight, lpbitmap, (BITMAPINFO *)&bi, DIB_RGB_COLORS);

	BYTE* ret = new BYTE[bmpScreen.bmWidth * bmpScreen.bmHeight * 3];

	for (int y = 0; y < bmpScreen.bmHeight; y++) {
		for (int x = 0; x < 3 * bmpScreen.bmWidth; x += 3) {
			int pos = y * 3 * bmpScreen.bmWidth + x;
			int bpos = (bmpScreen.bmHeight - y) * 3 * bmpScreen.bmWidth + x;
			ret[pos + 0] = lpbitmap[bpos + 2];
			ret[pos + 1] = lpbitmap[bpos + 1];
			ret[pos + 2] = lpbitmap[bpos + 0];
		}
	}

	//skip file save and return bmp data buffer
	if (filename == "default.bmp") {
		GlobalUnlock(hDIB);
		GlobalFree(hDIB);
		goto done;
	}

	// A file is created, this is where we will save the screen capture.
	
	HANDLE hFile = CreateFile(str_to_wstr(filename).c_str(), GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);

	// Add the size of the headers to the size of the bitmap to get the total file size
	DWORD dwSizeofDIB = dwBmpSize + sizeof(BITMAPFILEHEADER)+sizeof(BITMAPINFOHEADER);

	//Offset to where the actual bitmap bits start.
	bmfHeader.bfOffBits = (DWORD)sizeof(BITMAPFILEHEADER)+(DWORD)sizeof(BITMAPINFOHEADER);

	//Size of the file
	bmfHeader.bfSize = dwSizeofDIB;

	//bfType must always be BM for Bitmaps
	bmfHeader.bfType = 0x4D42; //BM   

	DWORD dwBytesWritten = 0;
	WriteFile(hFile, (LPSTR)&bmfHeader, sizeof(BITMAPFILEHEADER), &dwBytesWritten, NULL);
	WriteFile(hFile, (LPSTR)&bi, sizeof(BITMAPINFOHEADER), &dwBytesWritten, NULL);
	WriteFile(hFile, (LPSTR)lpbitmap, dwBmpSize, &dwBytesWritten, NULL);

	//Unlock and Free the DIB from the heap
	GlobalUnlock(hDIB);
	GlobalFree(hDIB);

	//Close the handle for the file that was created
	CloseHandle(hFile);

	//Clean up
done:
	DeleteObject(hbmScreen);
	DeleteObject(hdcMemDC);
	ReleaseDC(hWnd, hdcWindow);

	return ret;
}
//http://www.runicsoft.com/bmp.cpp
//http://tipsandtricks.runicsoft.com/Cpp/BitmapTutorial.html#chapter5
BYTE* LoadBMP(int* width, int* height, long* size, LPCTSTR bmpfile){
	// declare bitmap structures
	BITMAPFILEHEADER bmpheader;
	BITMAPINFOHEADER bmpinfo;
	// value to be used in ReadFile funcs
	DWORD bytesread;
	// open file to read from
	HANDLE file = CreateFile(bmpfile, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_FLAG_SEQUENTIAL_SCAN, NULL);
	if (NULL == file) {
		cout << "ERROR: could not open BMP file: " << wstr_to_str(bmpfile) << '\n';
		return NULL; // coudn't open file	
	}
	if (GetLastError() == ERROR_FILE_NOT_FOUND) {
		cout << "ERROR: could not open BMP file: " << wstr_to_str(bmpfile) << '\n';
		return NULL; // coudn't open file	
	}
	if (GetLastError() == ERROR_PATH_NOT_FOUND) {
		cout << "ERROR: path not found: " << wstr_to_str(bmpfile) << '\n';
		return NULL;
	}
	// read file header
	if (ReadFile(file, &bmpheader, sizeof(BITMAPFILEHEADER), &bytesread, NULL) == false){
		cout << "ERROR: could not read bmp file header: " << wstr_to_str(bmpfile) << '\n';
		CloseHandle(file);
		return NULL;
	}

	//read bitmap info

	if (ReadFile(file, &bmpinfo, sizeof(BITMAPINFOHEADER), &bytesread, NULL) == false){
		cout << "ERROR: could not read bmp file info: " << wstr_to_str(bmpfile) << '\n';
		CloseHandle(file);
		return NULL;
	}

	// check if file is actually a bmp
	if (bmpheader.bfType != 'MB'){
		cout << "ERROR: file is not a bmp: " << wstr_to_str(bmpfile) << '\n';
		CloseHandle(file);
		return NULL;
	}
	
	// get image measurements
	*width = bmpinfo.biWidth;
	*height = abs(bmpinfo.biHeight);

	// check if bmp is uncompressed
	if (bmpinfo.biCompression != BI_RGB){
		CloseHandle(file);
		return NULL;
	}

	// check if we have 24 bit bmp
	if (bmpinfo.biBitCount != 24){
		cout << "ERROR: file is does not have 24 bits per pixel: " << wstr_to_str(bmpfile) << '\n';
		CloseHandle(file);
		return NULL;
	}

	// create buffer to hold the data
	*size = bmpheader.bfSize - bmpheader.bfOffBits;
	BYTE* Buffer = new BYTE[*size];
	// move file pointer to start of bitmap data
	SetFilePointer(file, bmpheader.bfOffBits, NULL, FILE_BEGIN);
	// read bmp data
	if (ReadFile(file, Buffer, *size, &bytesread, NULL) == false){
		delete[] Buffer;
		CloseHandle(file);
		return NULL;
	}

	// everything successful here: close file and return buffer

	CloseHandle(file);

	return Buffer;
}
bool SaveBMP(BYTE* Buffer, int width, int height, long paddedsize, LPCTSTR bmpfile){
	// declare bmp structures 
	BITMAPFILEHEADER bmfh;
	BITMAPINFOHEADER info;

	// andinitialize them to zero
	memset(&bmfh, 0, sizeof (BITMAPFILEHEADER));
	memset(&info, 0, sizeof (BITMAPINFOHEADER));

	// fill the fileheader with data
	bmfh.bfType = 0x4d42;       // 0x4d42 = 'BM'
	bmfh.bfReserved1 = 0;
	bmfh.bfReserved2 = 0;
	bmfh.bfSize = sizeof(BITMAPFILEHEADER)+sizeof(BITMAPINFOHEADER)+paddedsize;
	bmfh.bfOffBits = 0x36;		// number of bytes to start of bitmap bits

	// fill the infoheader

	info.biSize = sizeof(BITMAPINFOHEADER);
	info.biWidth = width;
	info.biHeight = height;
	info.biPlanes = 1;			// we only have one bitplane
	info.biBitCount = 24;		// RGB mode is 24 bits
	info.biCompression = BI_RGB;
	info.biSizeImage = 0;		// can be 0 for 24 bit images
	info.biXPelsPerMeter = 0x0ec4;     // paint and PSP use this values
	info.biYPelsPerMeter = 0x0ec4;
	info.biClrUsed = 0;			// we are in RGB mode and have no palette
	info.biClrImportant = 0;    // all colors are important

	// now we open the file to write to
	HANDLE file = CreateFile(bmpfile, GENERIC_WRITE, FILE_SHARE_READ, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
	if (file == NULL){
		cout << "ERROR: could not create bmp file: " << wstr_to_str(bmpfile) << '\n';
		CloseHandle(file);
		return false;
	}
	if (GetLastError() == ERROR_INVALID_NAME) {
		cout << "ERROR: invalid name: " << wstr_to_str(bmpfile) << '\n';
		return false;
	}
	// write file header
	unsigned long bwritten;
	if (WriteFile(file, &bmfh, sizeof(BITMAPFILEHEADER), &bwritten, NULL) == false){
		cout << "ERROR: could not write bmp file header: " << wstr_to_str(bmpfile) << '\n';
		CloseHandle(file);
		return false;
	}
	// write infoheader
	if (WriteFile(file, &info, sizeof(BITMAPINFOHEADER), &bwritten, NULL) == false){
		cout << "ERROR: could not write bmp file infoheader: " << wstr_to_str(bmpfile) << '\n';
		CloseHandle(file);
		return false;
	}
	// write image data
	if (WriteFile(file, Buffer, paddedsize, &bwritten, NULL) == false){
		cout << "ERROR: could not write bmp file image data: " << wstr_to_str(bmpfile) << '\n';
		CloseHandle(file);
		return false;
	}
	// and close file
	CloseHandle(file);

	return true;
}
BYTE* ConvertBMPToRGBBuffer(BYTE* Buffer, int width, int height){
	// first make sure the parameters are valid
	if ((NULL == Buffer) || (width == 0) || (height == 0))
		return NULL;

	// find the number of padding bytes

	int padding = 0;
	int scanlinebytes = width * 3;
	while ((scanlinebytes + padding) % 4 != 0)     // DWORD = 4 bytes
		padding++;
	// get the padded scanline width
	int psw = scanlinebytes + padding;

	// create new buffer
	BYTE* newbuf = new BYTE[width*height * 3];

	// now we loop trough all bytes of the original buffer, 
	// swap the R and B bytes and the scanlines
	long bufpos = 0;
	long newpos = 0;
	for (int y = 0; y<height; y++){
		for (int x = 0; x<3 * width; x += 3){
			newpos = y * 3 * width + x;
			bufpos = (height - y - 1)*psw + x;

			newbuf[newpos] = Buffer[bufpos + 2];
			newbuf[newpos + 1] = Buffer[bufpos + 1];
			newbuf[newpos + 2] = Buffer[bufpos];
		}
	}
	return newbuf;
}
BYTE* ConvertRGBToBMPBuffer(BYTE* Buffer, int width, int height, long* newsize)
{

	// first make sure the parameters are valid
	if ((NULL == Buffer) || (width == 0) || (height == 0))
		return NULL;

	// now we have to find with how many bytes
	// we have to pad for the next DWORD boundary	

	int padding = 0;
	int scanlinebytes = width * 3;
	while ((scanlinebytes + padding) % 4 != 0)     // DWORD = 4 bytes
		padding++;
	// get the padded scanline width
	int psw = scanlinebytes + padding;

	// we can already store the size of the new padded buffer
	*newsize = height * psw;

	// and create new buffer
	BYTE* newbuf = new BYTE[*newsize];

	// fill the buffer with zero bytes then we dont have to add
	// extra padding zero bytes later on
	memset(newbuf, 0, *newsize);

	// now we loop trough all bytes of the original buffer, 
	// swap the R and B bytes and the scanlines
	long bufpos = 0;
	long newpos = 0;
	for (int y = 0; y < height; y++)
	for (int x = 0; x < 3 * width; x += 3)
	{
		bufpos = y * 3 * width + x;     // position in original buffer
		newpos = (height - y - 1) * psw + x;           // position in padded buffer

		newbuf[newpos] = Buffer[bufpos + 2];       // swap r and b
		newbuf[newpos + 1] = Buffer[bufpos + 1]; // g stays
		newbuf[newpos + 2] = Buffer[bufpos];     // swap b and r
	}

	return newbuf;
}
BYTE* bmp_to_array(string file, int &x, int &y, HWND capture = NULL) {
	if (capture)
		CaptureAnImage(capture, file);
	long s;
	BYTE* a = LoadBMP(&x, &y, &s, str_to_wstr(file).c_str());
	BYTE* newbuf = ConvertBMPToRGBBuffer(a, x, y);
	delete[] a;
	return newbuf;
}
void array_to_bmp(string file, BYTE* buffer, int x, int y) {
	long s;
	BYTE* b = ConvertRGBToBMPBuffer(buffer, x, y, &s);
	SaveBMP(b, x, y, s, (str_to_wstr(file).c_str()));
	delete[] b;
}
bool LoadAndBlitBitmap(LPCWSTR szFileName, HDC hWinDC) {
	// Load the bitmap image file
	HBITMAP hBitmap;
	hBitmap = (HBITMAP)::LoadImage(NULL, szFileName, IMAGE_BITMAP, 0, 0,
		LR_LOADFROMFILE);
	// Verify that the image was loaded
	if (hBitmap == NULL) {
		::MessageBox(NULL, TEXT("LoadImage Failed"), TEXT("Error"), MB_OK);
		return false;
	}

	// Create a device context that is compatible with the window
	HDC hLocalDC;
	hLocalDC = ::CreateCompatibleDC(hWinDC);
	// Verify that the device context was created
	if (hLocalDC == NULL) {
		::MessageBox(NULL, TEXT("CreateCompatibleDC Failed"), TEXT("Error"), MB_OK);
		return false;
	}

	// Get the bitmap's parameters and verify the get
	BITMAP qBitmap;
	int iReturn = GetObject(reinterpret_cast<HGDIOBJ>(hBitmap), sizeof(BITMAP),
		reinterpret_cast<LPVOID>(&qBitmap));
	if (!iReturn) {
		::MessageBox(NULL, TEXT("GetObject Failed"), TEXT("Error"), MB_OK);
		return false;
	}

	// Select the loaded bitmap into the device context
	HBITMAP hOldBmp = (HBITMAP)::SelectObject(hLocalDC, hBitmap);
	if (hOldBmp == NULL) {
		::MessageBox(NULL, TEXT("SelectObject Failed"), TEXT("Error"), MB_OK);
		return false;
	}

	// Blit the dc which holds the bitmap onto the window's dc
	BOOL qRetBlit = ::BitBlt(hWinDC, 0, 0, qBitmap.bmWidth, qBitmap.bmHeight,
		hLocalDC, 0, 0, SRCCOPY);
	if (!qRetBlit) {
		::MessageBox(NULL, TEXT("Blit Failed"), TEXT("Error"), MB_OK);
		return false;
	}

	// Unitialize and deallocate resources
	::SelectObject(hLocalDC, hOldBmp);
	::DeleteDC(hLocalDC);
	::DeleteObject(hBitmap);
	return true;
}

hsv_color RGB_to_HSV(rgb_color RGB) {
	hsv_color HSV;

	double R = RGB.r;
	double G = RGB.g;
	double B = RGB.b;

	double M = MAX3(R, G, B);
	double m = MIN3(R, G, B);
	double C = M - m;

	double H = 0;
	double S = 0;
	double V = 0;

	//calculate value
	V = M;
	//calculate hue
	if (M == R) {
		H = ((G - B) / C) * 60;
		if (H < 0)
			H += 360;
	}
	else if (M == G)
		H = (((B - R) / C) + 2) * 60;
	else if (M == B)
		H = (((R - G) / C) + 4) * 60; 
	//calculate saturation
	if (V == 0)
		S = 0;
	else
		S = (C / M);

	HSV.hue = H;
	HSV.sat = S;
	HSV.val = V;
	return HSV;
}
rgb_color HSV_to_RGB(hsv_color HSV) {
	rgb_color RGB;

	double H = HSV.hue;
	double S = HSV.sat;
	double V = HSV.val;

	double C = V * S * 255;
	double X = C * (1 - abs(fmod((H / 60), 2) - 1));
	double m = V * 255 - C;

	double R = 0;
	double G = 0;
	double B = 0;

	int c = 0;
	for (; H >= 0; H -= 60, c++);

	R = (c == 1 || c == 6) ? C + m : (c == 2 || c == 5) ? X + m : (c == 3 || c == 4) ? m : 0;
	G = (c == 2 || c == 3) ? C + m : (c == 1 || c == 4) ? X + m : (c == 5 || c == 6) ? m : 0;
	B = (c == 4 || c == 5) ? C + m : (c == 3 || c == 6) ? X + m : (c == 1 || c == 2) ? m : 0;

	RGB.r = R;
	RGB.g = G;
	RGB.b = B;
	return RGB;
}

int GetEncoderClsid(const WCHAR* format, CLSID* pClsid) {
	UINT  num = 0;          // number of image encoders
	UINT  size = 0;         // size of the image encoder array in bytes

	ImageCodecInfo* pImageCodecInfo = NULL;

	GetImageEncodersSize(&num, &size);
	if (size == 0)
		return -1;  // Failure

	pImageCodecInfo = (ImageCodecInfo*)(malloc(size));
	if (pImageCodecInfo == NULL)
		return -1;  // Failure

	GetImageEncoders(num, size, pImageCodecInfo);

	for (UINT j = 0; j < num; ++j) {
		if (wcscmp(pImageCodecInfo[j].MimeType, format) == 0) {
			*pClsid = pImageCodecInfo[j].Clsid;
			free(pImageCodecInfo);
			return j;  // Success
		}
	}

	free(pImageCodecInfo);
	return -1;  // Failure
}

class process_image;
vector<process_image*> process_images;
class process_image {
	public:
	BYTE* buffer;
	int x, y;
	string filename;
	string directory;
	string algs;

	process_image(){
		buffer = NULL;
		x = y = NULL;
		filename = directory = algs = "";
	}

	process_image(const process_image& other) {
		buffer = other.buffer;
		x = other.x;
		y = other.y;
		filename = other.filename;
		directory = other.directory;
		algs = other.algs;
	};

	process_image& operator=(const process_image& other) {
		if (this == &other)
			return *this;
		buffer = other.buffer;
		x = other.x;
		y = other.y;
		filename = other.filename;
		directory = other.directory;
		algs = other.algs;
		return *this;
	}

	~process_image() {
		delete[] buffer;
	}

	void load_bmp(string file) {
		directory = file.substr(0, file.rfind('\\') + 1);
		filename = file.substr(file.rfind('\\') + 1, file.size());
		long s;
		BYTE* a = LoadBMP(&x, &y, &s, str_to_wstr(file).c_str());
		buffer = ConvertBMPToRGBBuffer(a, x, y);
		delete[] a;
	}
};

void grayscale(BYTE *newbuf, int x, int y, UINT gray_algorithm, int extra = 0, string outfile = "") {
	for (int i = 0; i < y; i++) {
		for (int j = 0; j < 3 * x; j += 3) {
			int pos = i * 3 * x + j;
			int red = newbuf[pos];
			int green = newbuf[pos + 1];
			int blue = newbuf[pos + 2];

			BYTE gray = 255;

			if (gray_algorithm == GRAYSCALE_AVGERAGE) {
				gray = (red + green + blue) / 3;
			}

			else if (gray_algorithm == GRAYSCALE_LUMINOSITY) {
				gray = (BYTE)(((double)red * 0.2125) + ((double)green * 0.7154) + ((double)blue * 0.0721));
			}

			else if (gray_algorithm == GRAYSCALE_DESATURATION) {
				gray = (MAX3(red, green, blue) + MIN3(red, green, blue)) / 2;
			}

			else if (gray_algorithm == GRAYSCALE_DECOMPOSITION_MIN) {
				gray = MIN3(red, green, blue);
			}
			else if (gray_algorithm == GRAYSCALE_DECOMPOSITION_MAX) {
				gray = MAX3(red, green, blue);
			}

			else if (gray_algorithm == GRAYSCALE_COLOR_CHANNEL_RED) {
				gray = red;
			}
			else if (gray_algorithm == GRAYSCALE_COLOR_CHANNEL_GREEN) {
				gray = green;
			}
			else if (gray_algorithm == GRAYSCALE_COLOR_CHANNEL_BLUE) {
				gray = blue;
			}

			else if (gray_algorithm == GRAYSCLAE_COLOR_COUNT) {
				if (extra < 2)
					extra = 2;
				BYTE ConversionFactor = 255 / (extra - 1);
				BYTE AverageValue = (red + green + blue) / 3;
				gray = (BYTE)((AverageValue / ConversionFactor) + 0.5) * ConversionFactor;
			}

			else if (gray_algorithm == GRAYSCLAE_COLOR_COUNT_DITHER) {

			}

			if (gray_algorithm == GRAYSCALE_BINARY) {
				gray = (((red + green + blue) / 3 > extra) ? 255 : 0);
			}
			else if (gray_algorithm == GRAYSCALE_INVERSE_BINARY) {
				gray = ((red + green + blue) / 3 > extra) ? 0 : 255;
			}


			newbuf[pos + 0] = gray;
			newbuf[pos + 1] = gray;
			newbuf[pos + 2] = gray;
		}
	}
	if (outfile.size() > 0)
		array_to_bmp(outfile, newbuf, x, y);
}
BYTE* cropimage(BYTE *buf, int &x, int &y, int startx, int stopx, int starty, int stopy, string outfile = "") {
	BYTE* newbuf = new BYTE[((x - (startx + stopx)) * ((y - (starty + stopy)) * 3))];
	int newpos = 0;
	for (int i = starty; i < y - stopy; i++) {
		for (int j = startx * 3; j < 3 * (x - stopx); j += 3) {
			int pos = i * 3 * x + j;
			int red = pos;
			int green = pos + 1;
			int blue = pos + 2;
			newbuf[newpos + 0] = buf[red];
			newbuf[newpos + 1] = buf[green];
			newbuf[newpos + 2] = buf[blue];
			newpos += 3;
		}
	}
	if (outfile.size() > 0)
		array_to_bmp(outfile, newbuf, x - (startx + stopx), y - (starty + stopy));
	x -= (startx + stopx);
	y -= (starty + stopy);
	return newbuf;
}
BYTE* growimage(BYTE *buf, int &x, int &y, int startx, int stopx, int starty, int stopy, COLORREF background = RGB(0, 0, 0), string outfile = "") {
	x = x + startx + stopx;
	y = y + starty + stopy;
	BYTE* newbuf = new BYTE[x * y * 3];

	for (int i = 0; i < y; i++) {
		for (int j = 0; j < 3 * x; j+=3) {
			int pos = i * 3 * x + j;
			newbuf[pos + 0] = GetRValue(background);
			newbuf[pos + 1] = GetGValue(background);
			newbuf[pos + 2] = GetBValue(background);
		}
	}

	int newpos = 0;
	for (int i = starty; i < y - stopy; i++) {
		for (int j = startx * 3; j < 3 * (x - stopx); j += 3) {
			int pos = i * 3 * x + j;
			int red = pos;
			int green = pos + 1;
			int blue = pos + 2;			
			newbuf[red] = buf[newpos];
			newbuf[green] = buf[newpos + 1];
			newbuf[blue] = buf[newpos + 2];
			newpos += 3;
		}
	}
	if (outfile.size() > 0)
		array_to_bmp(outfile, newbuf, x, y);
	return newbuf;	
}
void brightness(BYTE *newbuf, int x, int y, UINT brightness_algorithm, double val, string outfile = "") {
	for (int i = 0; i < y; i++) {
		for (int j = 0; j < 3 * x; j += 3) {
			int pos = i * 3 * x + j;
			int red = newbuf[pos];
			int green = newbuf[pos + 1];
			int blue = newbuf[pos + 2];

			if (brightness_algorithm == BRIGHTNESS_FLAT) {
				newbuf[pos + 0] = (BYTE)(red + val > 255 ? 255 : red + val < 0 ? 0 : red + val);
				newbuf[pos + 1] = (BYTE)(green + val > 255 ? 255 : green + val < 0 ? 0 : green + val);
				newbuf[pos + 2] = (BYTE)(blue + val > 255 ? 255 : blue + val < 0 ? 0 : blue + val);
			}
			else if (brightness_algorithm == BRIGHTNESS_HSV) {
				hsv_color hsv = RGB_to_HSV(rgb_color(red, green, blue));
				hsv.val += val / 100 > 1 ? 1 : val / 100 < 0 ? 0 : val / 100;
				rgb_color rgb = HSV_to_RGB(hsv);
				newbuf[pos + 0] = (BYTE)rgb.r;
				newbuf[pos + 1] = (BYTE)rgb.g;
				newbuf[pos + 2] = (BYTE)rgb.b;
			}
		}
	}
	if (outfile.size() > 0)
		array_to_bmp(outfile, newbuf, x, y);
}






bool rgbt(int red, int green, int blue) {
	for (UINT i = 0; i < statcolors.size(); i++) {
		if (red == statcolors[i].red && green == statcolors[i].green && blue == statcolors[i].blue)
			return true;
	}
	return false;

}
void load_letters() {
	string IMAGEFILE = "load_letters";
	int x, y;
	int bottom = 0;
	int right = 0;
	BYTE* newbuf;
	fileout.open("array.txt");
	string asc = "";
	string poz = "";
	string wh = "";
	string size = "";
	for (int imagecount = 33; imagecount <= 126; imagecount++) {
		if (imagecount<100)
			IMAGEFILE = "0" + int_to_str(imagecount);
		else
			IMAGEFILE = int_to_str(imagecount);
		asc = "{" + int_to_str(str_to_int(IMAGEFILE)) + ", ";
		newbuf = bmp_to_array(IMAGEFILE, x, y);
		vector<int> char_pos = isolate_letters(newbuf, x, 0, y);
		if (char_pos.size() == 0)
			continue;
		int left = char_pos[0];
		int right = char_pos[1];
		int top = char_pos[2];
		int bottom = char_pos[3];
		wh = " , " + int_to_str(right - left) + ", " + int_to_str(bottom - top) + ", ";
		int count = 2;
		for (int i = top; i<bottom; i++) {
			for (int j = left * 3; j<3 * right; j += 3) {
				int pos = i * 3 * x + j;
				int red = (int)newbuf[pos];
				int green = (int)newbuf[pos + 1];
				int blue = (int)newbuf[pos + 2];
				if (rgbt(red, blue, green)) {
					poz += int_to_str((pos / 3) - (x*i) - left + ((right - left)*(i - top))) + ",";
					newbuf[pos] = 255;
					count++;
					size = int_to_str(count);
				}
			}
		}
		array_to_bmp(IMAGEFILE, newbuf, x, y);
		if (poz.size() > 0)
			poz.resize(poz.size() - 1);
		fileout << asc + size + wh + poz + "},\n";
		asc = "";
		wh = "";
		poz = "";
	}
	fileout.close();
	////////KEEEEEEEEEEEEEEEEEEEP
	//for (int a=0; a<71; a++){
	//	int count=0;
	//	vector<int> temp(charset[a][2], 0);
	//	vector<int> tempcpy(temp);
	//	vector<vector<int>> let;
	//	for (int i=4; i<charset[a][1]+2; i++){
	//		int num=charset[a][i];
	//		while (charset[a][i]/charset[a][2]>count){
	//			count++;
	//			let.push_back(temp);
	//			temp=tempcpy;
	//		}
	//		temp[charset[a][i]-(charset[a][2]*count)]=1;
	//	}
	//	let.push_back(temp);
	//	set.push_back(let);
	//}
	//for (int i=0; i<set.size(); i++){
	//	cout << "\t{\n";
	//	for (int j=0; j<set[i].size(); j++){
	//		cout << "\t\t{";
	//		for (int k=0; k<set[i][j].size(); k++){
	//			int cur=set[i][j][k];
	//			cout << cur;
	//			if (k!=set[i][j].size()-1)
	//				cout << ",";
	//		}
	//		cout << "}";
	//		if (j!=set[i].size()-1)
	//			cout << ",";
	//		cout << '\n';
	//		//next line of char
	//	}
	//	cout << "\t}";
	//	if (i!=set.size()-1)
	//		cout << ",";
	//	cout << '\n';
	//	//next char
	//}
	//_getch();
	///////////////////////KEEEEEEEEEEEEEEEEP
}
bool process(BYTE *newbuf, int x, int y, string outfile = "process.bmp"){
	static int brightness = 0;
	static int contrast = 225;
	for (int i = 0; i < y; i++){
		for (int j = 0; j < 3 * x; j += 3) {
			int pos = i * 3 * x + j;
			int red = pos;
			int green = pos + 1;
			int blue = pos + 2;


			if (!rgbt(newbuf[red], newbuf[green], newbuf[blue])
				/*&& !((newbuf[red] == 255 && newbuf[green] == 0 && newbuf[blue] == 0)
				|| (newbuf[red] == 0 && newbuf[green] == 255 && newbuf[blue] == 0)
				|| (newbuf[red] == 255 && newbuf[green] == 255 && newbuf[blue] == 0))*/
				) {
				/*
				newbuf[red] = (newbuf[red] + brightness >= 255) ? 255 : (newbuf[red] + brightness <= 0) ? 0 : newbuf[red] + brightness;
				newbuf[green] = (newbuf[green] + brightness >= 255) ? 255 : (newbuf[green] + brightness <= 0) ? 0 : newbuf[green] + brightness;
				newbuf[blue] = (newbuf[blue] + brightness >= 255) ? 255 : (newbuf[blue] + brightness <= 0) ? 0 : newbuf[blue] + brightness;
				
				
				newbuf[red] = (((int)floor((newbuf[red] - 128)*(.01*contrast)) + 128) >= 255) ? 255 : (((int)floor((newbuf[red] - 128)*(.01*contrast)) + 128) <= 0) ? 0 : ((int)floor((newbuf[red] - 128)*(.01*contrast)) + 128);
				newbuf[green] = (((int)floor((newbuf[green] - 128)*(.01*contrast)) + 128) >= 255) ? 255 : (((int)floor((newbuf[green] - 128)*(.01*contrast)) + 128) <= 0) ? 0 : ((int)floor((newbuf[green] - 128)*(.01*contrast)) + 128);
				newbuf[blue] = (((int)floor((newbuf[blue] - 128)*(.01*contrast)) + 128) >= 255) ? 255 : (((int)floor((newbuf[blue] - 128)*(.01*contrast)) + 128) <= 0) ? 0 : ((int)floor((newbuf[blue] - 128)*(.01*contrast)) + 128);
				*/
				newbuf[red] = 0;
				newbuf[green] = 0;
				newbuf[blue] = 0;				
			}
			if ((j == (3 * x - 3)) || (i == y - 1)){
				newbuf[pos] = 0;
				newbuf[pos + 1] = 0;
				newbuf[pos + 2] = 0;
			}
		}
	}
	/*contrast+=250;*/
	
	string path = outfile.substr(0, outfile.rfind('\\') + 1);
	string filename = outfile.substr(outfile.rfind('\\') + 1, outfile.size());
	if (outfile.size() > 0) {
		outfile = path + "(processed)" + filename;
		/*static int filecount = 2;
		file = path + "example" + int_to_str(filecount++) + ".bmp";*/
		array_to_bmp(outfile, newbuf, x, y);
	}
	return true;
}

void find_box(BYTE* newbuf, int x, int y, POINT pt, string outfile = "find box.bmp"){
	cout << pt.x << " " << pt.y << '\n';
	int column = 0;
	for (int i = pt.x * 3; i >= 0; i -= 3) {
		int vertlinecount = 0;
		int largest = 0;		
		for (int j = i; j < y * x * 3; j += (x * 3)) {
			if (newbuf[j + 0] == 0 && newbuf[j + 1] == 0 && newbuf[j + 2] == 0)
				vertlinecount++;
			else 
				vertlinecount = 0;
			if (vertlinecount > largest) {
				largest = vertlinecount;
				column = i / 3;
			}
		}
	}
	//cout << column << '\n';
	for (int i = pt.x * 3; i < x * 3; i += 3) {
		for (int j = i; j < y * x * 3; j += (x * 3)) {
			/*newbuf[j + 0] = 0;
			newbuf[j + 1] = 0;
			newbuf[j + 2] = 255;*/
		}
	}
	array_to_bmp("(box)" + outfile, newbuf, x, y);
}
vector<int> find_lines(BYTE* newbuf, int x, int y){
	vector<int> lines;
	int top = 1000000;
	int height = 0;
	for (int i = 0; i < y; i++){
		if (top < 1000000)
			height++;
		int gap = 0;
		for (int j = 0; j < 3 * x; j += 3) {
			int pos = i * 3 * x + j;
			int red = (int)newbuf[pos];
			int green = (int)newbuf[pos + 1];
			int blue = (int)newbuf[pos + 2];
			if (height >= 16) {
				top = 1000000;
				lines.push_back(i - 1);
				height = 0;
			}
			if (!rgbt(red, green, blue)){
				gap++;
				if (gap == x && i>top) {
					top = 1000000;
					lines.push_back(i - 1);
					height = 0;
				}
			}
			else{
				if (i<top){
					top = i;
					lines.push_back(top);
				}
			}
		}
	}
	return lines;
}
vector<int> isolate_letters(BYTE* newbuf, int width, int top, int bottom){
	vector<int> gaps;
	int l = 1000000, r = 0, t = 1000000, b = 0;
	int gap_count = 0;
	for (int i = 0; i<width * 3; i += 3){//crops to left right top and bottom
		int gap = 0;
		for (int j = top*width * 3 + i; j<(width * 3 * (bottom + 1)); j += (width * 3)){
			int red = (int)newbuf[j];
			int green = (int)newbuf[j + 1];
			int blue = (int)newbuf[j + 2];
			if (rgbt(red, green, blue) && red != 171){
				if (i / 3 < l)
					l = i / 3;
				r = i / 3 + 1;
				if ((j - i) / (width * 3) < t)
					t = (j - i) / (width * 3);
				if ((j - i) / (width * 3) + 1 > b)
					b = (j - i) / (width * 3) + 1;
			}
			else
				gap++;
			if (gap == bottom + 1 - top && ocr_spaces_on){
				gap_count++;
				if (gap_count>8){
					gaps.push_back(-1); gaps.push_back(-1); gaps.push_back(-1); gaps.push_back(-1);
					gap_count = 0;
				}
			}
			if (gap == bottom + 1 - top && r){
				gaps.push_back(l); gaps.push_back(r); gaps.push_back(t); gaps.push_back(b);
				l = 1000000, r = 0, t = 1000000, b = 0;
				gap_count = 0;
			}
		}
	}
	if (gaps.size()>0 && ocr_spaces_on){
		while (gaps[0] == -1)
			gaps.erase(gaps.begin(), gaps.begin() + 1);
		while (gaps[gaps.size() - 1] == -1)
			gaps.erase(gaps.end() - 1, gaps.end());
	}
	return gaps;
}
bool match(vector<int> a, int b, vector<vector<BYTE>> &charset) {
	int size = charset[b][1];
	if (size != a.size())
		return false;
	for (UINT i = 0; i < a.size() - 1; i++)
		if (a[i] != charset[b][i + 2])
			return false;
	return true;
}
vector<string> ocr(BYTE* newbuf, int x, int y, vector<vector<BYTE>> &charset) {
	/*for (int row = 0; row < y; row++) {
		if (row == y - 1) {
			for (int i = 0; i < 3 * x; i += 3) {
				int pos = row * 3 * x + i;
				newbuf[pos + 0] = 0;
				newbuf[pos + 1] = 255;
				newbuf[pos + 2] = 0;
			}
		}
		else {
			int pos = 3 * row * x + (3 * (x - 1));
			newbuf[pos + 0] = 255;
			newbuf[pos + 1] = 0;
			newbuf[pos + 2] = 0;
		}
	}*/
	vector<string> item_stats;
	vector<int> lines = find_lines(newbuf, x, y);//finds top and bottom row coordinates for each line of text
	for (UINT l = 0; l < lines.size(); l += 2){
		vector<int> letters = isolate_letters(newbuf, x, lines[l], lines[l + 1]);
		vector<vector<int>> let;
		vector<int> temp;
		if (letters.size() == 0)
			continue;
		for (UINT a = 0; a < letters.size(); a += 4) {//puts each isolated letter into its own array. ex. (Capital H)
			int left = letters[a];						//0, x, x, x, 4,
			int right = letters[a + 1];					//5, x, x, x, 9,
			int top = letters[a + 2];					//10,11,12,13,14,
			int bottom = letters[a + 3];				//15,x, x, x, 19,
			temp.push_back(right - left);				//20,x, x, x, 24
			temp.push_back(bottom - top);				//in array it would be: {5(width), 5(height), 0,4,5,9,10,11,12,13,14,15,19,20,24}
			for (int i = top; i < bottom; i++) {
				for (int j = left * 3; j < 3 * right; j += 3) {
					int pos = i * 3 * x + j;
					int red = (int)newbuf[pos];
					int green = (int)newbuf[pos + 1];
					int blue = (int)newbuf[pos + 2];					
					

					/*
					int newpos;
					if (i == top && i > 0) {
						newpos = (i - 1) * 3 * x + j;
						newbuf[newpos + 0] = 255;
						newbuf[newpos + 1] = 255;
						newbuf[newpos + 2] = 0;
					}
					if (i == bottom - 1 && i < y) {
						newpos = (i + 1) * 3 * x + j;
						newbuf[newpos + 0] = 255;
						newbuf[newpos + 1] = 255;
						newbuf[newpos + 2] = 0;
					}
					if (j == left * 3 && j > 0) {
						newpos = i * 3 * x + (j - 3);
						newbuf[newpos + 0] = 255;
						newbuf[newpos + 1] = 255;
						newbuf[newpos + 2] = 0;
					}
					if (j == 3 * right - 3 && j < x * 3) {
						newpos = i * 3 * x + (j + 3);
						newbuf[newpos + 0] = 255;
						newbuf[newpos + 1] = 255;
						newbuf[newpos + 2] = 0;
					}
*/


					if (rgbt(red, green, blue)){
						temp.push_back((pos / 3) - (x * i) - left + ((right - left) * (i - top)));
					}
				}
			}
			let.push_back(temp);
			temp.erase(temp.begin(), temp.end());
		}
		int size = charset.size();
		string tline = "";
		for (UINT i = 0; i < let.size(); i++){
			for (int a = 0; a<size; a++){
				if (match(let[i], a, charset)){
					tline += (char)charset[a][0];
					break;
				}
			}
		}
		if (tline.size()>0){
			char start = tline[0];
			char end = tline[tline.size() - 1];
			while (tline.size()>0 && (start == ' ' || start == '-' || start == ':' || start == ',' || start == '\'')){
				tline.erase(tline.begin(), tline.begin() + 1);
				start = tline[0];
			}
			while (tline.size()>0 && (end == ' ' || end == '-' || end == ':' || end == ',' || end == '\'')){
				tline.erase(tline.end() - 1, tline.end());
				end = tline[tline.size() - 1];
			}
			if (tline.size()>1)
				item_stats.push_back(tline);
		}



		
		/*for (int ln = 0; ln < 3 * x; ln += 3) {
			int ps1 = (lines[l + 0] - 1) * 3 * x + ln;
			if (lines[l] > 0) {
				newbuf[ps1 + 0] = 0;
				newbuf[ps1 + 1] = 255;
				newbuf[ps1 + 2] = 0;
			}
			int ps2 = (lines[l + 1] + 1) * 3 * x + ln;
			if (lines[l + 1] < y) {
				newbuf[ps2 + 0] = 255;
				newbuf[ps2 + 1] = 0;
				newbuf[ps2 + 2] = 0;
			}
		}*/



	}
	return item_stats;
}

bool get_transmute_pos(HWND wnd, LONG* x, LONG* y) {
	RECT client = getclientrect(wnd);
	POINT client_cursor = getclientcursorpos(wnd);
	cout << "current client cursor pos: " << client_cursor.x << " " << client_cursor.y << '\n';
	cout << "current screen resolution: " << client.right << " " << client.bottom << '\n';
	if (transmutebuttonx >= 0 && transmutebuttony >= 0) {
		*x = transmutebuttonx; *y = transmutebuttony;
	}
	else if (client.right == 640 && client.bottom == 480) {
		*x = 160; *y = 275;
	}
	else if (client.right == 800 && client.bottom == 600) {
		*x = 240; *y = 335;
	}
	else if (client.right == 1024 && client.bottom == 768) {
		*x = 160; *y = 445;
	}
	else if (client.right == 1280 && client.bottom == 1024) {
		*x = 165; *y = 560;
	}
	else
		return false;
	return true;
}
bool get_transmute_pos(HWND wnd, POINT* pt) {
	return get_transmute_pos(wnd, &pt->x, &pt->y);
}

bool get_gold_pos(HWND wnd, LONG* x, LONG* y) {
	RECT client = getclientrect(wnd);
	POINT client_cursor = getclientcursorpos(wnd);
	cout << "current client cursor pos: " << client_cursor.x << " " << client_cursor.y << '\n';
	cout << "current screen resolution: " << client.right << " " << client.bottom << '\n';
	if (goldbuttonx >= 0 && goldbuttony >= 0) {
		*x = goldbuttonx; *y = goldbuttony;
	}
	else if (client.right == 640 && client.bottom == 480) {
		*x = 411; *y = 401;
	}
	else if (client.right == 800 && client.bottom == 600) {
		*x = 496; *y = 458;
	}
	///////////////////////////////
	else if (client.right == 1024 && client.bottom == 768) {
		*x = 0; *y = 0;
	}
	else if (client.right == 1280 && client.bottom == 1024) {
		*x = 0; *y = 0;
	}
	else
		return false;
	return true;
}
bool get_gold_pos(HWND wnd, POINT* pt) {
	return get_gold_pos(wnd, &pt->x, &pt->y);
}

void switch_weapons() {
	if (weapsonswitchkey == -1)
		scroll(120);
	else if (weapsonswitchkey < -1)
		scroll(-120);
	else if (weapsonswitchkey)
		keydownup(weapsonswitchkey);
}

void OCR_auto_roll(HWND wnd, POINT pt, vector<vector<BYTE>> &font) {
	double starttime = (double)clock() / 1000;
	
	bool match = false;

	LONG transx, transy;
	if (!get_transmute_pos(wnd, &transx, &transy)) {
		if (TBTN_SOUND.toggle_state)
			PlaySound(MAKEINTRESOURCE(NOTFOUND), NULL, SND_ASYNC | SND_RESOURCE);
		cout << "transmute button location not found" << '\n';
		return;
	}

	RECT rcclient = getclientrect(wnd);
	RECT rcstartpos = getwindowrect(wnd);
	RECT rcdesktop = getclientrect(GetDesktopWindow());

	/*HHOOK dllhook;
	HHOOK dllhook2;
	HHOOK dllhook3;
	if (!InjectDll(DLL_NAME, wnd, &dllhook, &dllhook2, &dllhook3)) {
		MessageBox(NULL, L"Dll injection failed", L"Error", MB_OK);
		PostQuitMessage(0);
	}*/

	/*LONG winLong = GetWindowLong(wnd, GWL_EXSTYLE);	
	SetWindowLong(wnd, GWL_EXSTYLE, winLong | WS_EX_LAYERED);
	SetLayeredWindowAttributes(wnd, 0, 1, LWA_ALPHA);*/
	
	if (AUTOROLL.on == 2)
		MoveWindow(wnd, rcdesktop.right, rcdesktop.bottom, rcstartpos.right - rcstartpos.left, rcstartpos.bottom - rcstartpos.top, true);

	vector<string> stats_in_file_copy = stats_in_file;

	//SendMessage(wnd, WM_MOUSEMOVE, 0, MAKELPARAM(pt.x, pt.y));

	while (!match) {
		if (GetAsyncKeyState(VK_ESCAPE) == -32767 || !IsWindow(wnd)) {
			if (TBTN_SOUND.toggle_state)
				PlaySound(MAKEINTRESOURCE(NOTFOUND), NULL, SND_ASYNC | SND_RESOURCE);
			cout << "exited rolling" << '\n';
			break;
		}
		BYTE* newbuf = CaptureAnImage(wnd);
		vector<string> item_stats = ocr(newbuf, rcclient.right, rcclient.bottom, font);
		delete[] newbuf;
		if (item_stats.size() == 0) {
			if (TBTN_SOUND.toggle_state)
				PlaySound(MAKEINTRESOURCE(NOTFOUND), NULL, SND_ASYNC | SND_RESOURCE);
			cout << "no stats found" << '\n';
			break;
		}
		////////////////////////////////////////////////////////////////////
		//implement OR(|), NOT(!), WILDCARD(?), WILDCARD SEQUENCE(?\), by character OR (<,>)
			//item sets/ stat groups
		for (UINT i = 0; i < stats_in_file_copy.size(); i++) {
			match = false;
			for (UINT j = 0; j < item_stats.size(); j++) {
				transform(item_stats[j].begin(), item_stats[j].end(), item_stats[j].begin(), tolower);
				item_stats[j].erase(remove(item_stats[j].begin(), item_stats[j].end(), ' '), item_stats[j].end());
				if (item_stats[j].find(stats_in_file_copy[i]) != string::npos) {
					match = true;
					break;
				}
			}
			if (!match) {
				send_left_click({transx, transy}, 0, wnd);
				this_thread::sleep_for(chrono::milliseconds(200));
				break;
			}
		}
		//////////////////////////////////////////////////////////////////////
	}
	if (match && TBTN_SOUND.toggle_state) {
		if (TBTN_SOUND.toggle_state)
			PlaySound(MAKEINTRESOURCE(WTF), NULL, SND_ASYNC | SND_RESOURCE);
		cout << "match found" << '\n';
	}

	//UnhookWindowsHookEx(dllhook);
	//UnhookWindowsHookEx(dllhook2);
	//UnhookWindowsHookEx(dllhook3);

	//SetWindowLong(wnd, GWL_EXSTYLE, winLong);
	if (AUTOROLL.on == 2)
		MoveWindow(wnd, rcstartpos.left, rcstartpos.top, rcstartpos.right - rcstartpos.left, rcstartpos.bottom - rcstartpos.top, true);

//	cout << milliseconds_to_hms((((double)clock() / 1000) - starttime)) << '\n';
}


#endif



///directory set
//convert to gif
//create animated gif