~-----------------------------------------------~
C:\Users\Josh\Documents\Visual Studio 2017\Projects\Sorting\Sorting\badsorts.h
~-----------------------------------------------~
#pragma once

template<class T, class C>
inline void _slowsort(T _First, T _Last, C compare) {
	if (_First < _Last) {
		T _Mid = _First + ((_Last - _First) >> 1);
		_slowsort(_First, _Mid, compare);
		_slowsort(_Mid + 1, _Last, compare);
		if (compare(*_Last, *_Mid))
			iter_swap(_Mid, _Last);
		_slowsort(_First, _Last - 1, compare);
	}
}

template<class T, class C>
inline void slowsort(T _First, T _Last, C compare) {
	_slowsort(_First, _Last - 1, compare);
}

template<class T>
inline void slowsort(T _First, T _Last) {
	slowsort(_First, _Last, std::less<>());
}

template<class T, class C>
inline void _sillysort(T _First, T _Last, C compare) {
	if (_First < _Last) {
		T _Mid = _First + ((_Last - _First) >> 1);
		_sillysort(_First, _Mid, compare);
		_sillysort(_Mid + 1, _Last, compare);
		if (!compare(*_First, *(_Mid + 1)))
			iter_swap(_First, (_Mid + 1));
		_sillysort(_First + 1, _Last, compare);
	}
}

template<class T, class C>
inline void sillysort(T _First, T _Last, C compare) {
	_sillysort(_First, _Last - 1, compare);
}

template<class T>
inline void sillysort(T _First, T _Last) {
	sillysort(_First, _Last, std::less<>());
}

template<class T, class C>
inline void _stoogesort(T _First, T _Last, C compare /*i = 0, j = length(L) - 1*/) {
	if (compare(*_Last, *_First))
		iter_swap(_First, _Last);
	if (std::distance(_First, _Last) + 1 > 2) {
		T _Temp = _First + ((_Last - _First + 1) / 3);
		_stoogesort(_First, (_Last - std::distance(_First, _Temp)), compare);
		_stoogesort(_Temp, _Last, compare);
		_stoogesort(_First, (_Last - std::distance(_First, _Temp)), compare);
	}
}

template<class T, class C>
inline void stoogesort(T _First, T _Last, C compare) {
	_stoogesort(_First, _Last - 1, compare);
}

template<class T>
inline void stoogesort(T _First, T _Last) {
	stoogesort(_First, _Last, std::less<>());
}

template<class T, class C>
inline void bogosort(T _First, T _Last, C compare) {
	while (!sorted(_First, _Last, compare)) {
		std::random_shuffle(_First, _Last);
	}
}

template<class T>
inline void bogosort(T _First, T _Last) {
	bogosort(_First, _Last, std::less<>());
}

template<class T, class C>
inline void lexipermsort(T _First, T _Last, C compare) {
	while (!sorted(_First, _Last, compare))
		std::next_permutation(_First, _Last, compare);
}

template<class T>
inline void lexipermsort(T _First, T _Last) {
	lexipermsort(_First, _Last, std::less<>());
}

template<class T, class J, class C>
bool bogo_equal(T first1, T last1, J first2, C compare) {
	for (; first1 != last1; ++first1, ++first2) 
		if ((compare(*first1, *first2) || compare(*first2, *first1))) 
			return false;
	return true;
}

template<class T, class C>
inline void bogobogosort(T _First, T _Last, C compare);

template<class T, class C>
inline bool bogo_sorted(T _First, T _Last, C compare) {
	if (_First == _Last || _First == _Last - 1) return true;
	std::vector<typename T::value_type> _Copy(_First, _Last);
	do {
		std::random_shuffle(_Copy.begin(), _Copy.end());
		bogobogosort(_Copy.begin(), _Copy.end() - 1, compare);
		
	} while (compare(*(_Last - 1), _Copy.back()));

	return bogo_equal(_First, _Last, _Copy.begin(), compare);
}

template<class T, class C>
inline void bogobogosort(T _First, T _Last, C compare) {
	while (!bogo_sorted(_First, _Last, compare)) {
		std::random_shuffle(_First, _Last);
	}
}

template<class T>
inline void bogobogosort(T _First, T _Last) {
	bogobogosort(_First, _Last, std::less<>());
}

template<class T, class C>
inline void bozosort(T _First, T _Last, C compare) {
	auto size = std::distance(_First, _Last);
	while (!sorted(_First, _Last, compare))
		iter_swap(_First + (rand() % size), _First + (rand() % size));
}

template<class T>
inline void bozosort(T _First, T _Last) {
	bozosort(_First, _Last, std::less<>());
}

template<class T, class C>
inline void pancakesort(T _First, T _Last, C compare) {	
	for (T _Pos = _Last; _Pos > _First + 1; --_Pos) {
		T _Max = std::max_element(_First, _Pos, compare);
		if (_Max + 1 != _Pos) {			
			std::reverse(_First, _Max + 1);	
			std::reverse(_First, _Pos);
		}
	}	
}

template<class T>
inline void pancakesort(T _First, T _Last) {
	pancakesort(_First, _Last, std::less<>());
}


























~-----------------------------------------------~
C:\Users\Josh\Documents\Visual Studio 2017\Projects\Sorting\Sorting\benchmark.h
~-----------------------------------------------~
#pragma once

#include <windows.h>
#include <iostream>

class Benchmark {
public:

	Benchmark() {
		QueryPerformanceFrequency(&frequency);
	}

	LONGLONG start() {
		stopped = false;
		QueryPerformanceCounter(&start_time);
		return start_time.QuadPart;
	}

	LONGLONG stop() {
		QueryPerformanceCounter(&end_time);
		if (stopped) start_time = end_time;
		else stopped = true;
		elapsed.QuadPart = end_time.QuadPart - start_time.QuadPart;
		elapsed.QuadPart *= 1000000;
		elapsed.QuadPart /= frequency.QuadPart;
		return elapsed.QuadPart;
	}

	void reset() {
		elapsed.QuadPart = 0;
		stopped = true;
		paused = false;
		stop();
	}

	void pause() {
		if (!stopped && !paused) {
			QueryPerformanceCounter(&paused_time);
		}
		paused = true;
	}

	void resume() {
		if (!stopped && paused) {
			QueryPerformanceCounter(&resume_time);
			start_time.QuadPart += (resume_time.QuadPart - paused_time.QuadPart);
		}
		paused_time = { 0 };
		paused = false;
	}

	LONGLONG getElapsed() { 
		if (!stopped) {
			stop();
			stopped = false;
		}
		
		return elapsed.QuadPart; 
	}

	double getElapsedMS() { return (double)getElapsed() / 1000.0; }

	friend std::ostream& operator<<(std::ostream& os, Benchmark& bm) {
		bm.stop();
		os << bm.elapsed.QuadPart;
		return os;
	}

private:
	bool stopped = true;
	bool paused = false;
	LARGE_INTEGER paused_time;
	LARGE_INTEGER resume_time;

	LARGE_INTEGER start_time;
	LARGE_INTEGER end_time;
	LARGE_INTEGER elapsed;

	LARGE_INTEGER frequency;
};


























~-----------------------------------------------~
C:\Users\Josh\Documents\Visual Studio 2017\Projects\Sorting\Sorting\binarytreesort.h
~-----------------------------------------------~
#pragma once

#include <set>       // for multiset
#include <algorithm> // for copy

template<class T, class C>
void binarytreesort(T _First, T _Last, C compare) {
	std::multiset<typename std::iterator_traits<T>::value_type, C> tree(_First, _Last, compare);
	std::copy(tree.begin(), tree.end(), _First);
}

template<class T>
void binarytreesort(T _First, T _Last) {
	binarytreesort(_First, _Last, std::less<>());
}

/* AVL node */
template <class T>
class AVLnode {
public:
	T key;
	int balance;
	AVLnode *left, *right, *parent;

	AVLnode(T k, AVLnode *p) : key(k), balance(0), parent(p),
		left(NULL), right(NULL) {}

	~AVLnode() {
		delete left;
		delete right;
	}
};

/* AVL tree */
template <class T>
class AVLtree {
public:
	AVLtree(void);
	~AVLtree(void);

	bool insert(T key);
	void deleteKey(const T key);
	void printBalance();
	void inOrder();
	void preOrder();
	void postOrder();
	AVLnode<T>* getRoot();

private:
	AVLnode<T> *root;

	AVLnode<T>* rotateLeft(AVLnode<T> *a);
	AVLnode<T>* rotateRight(AVLnode<T> *a);
	AVLnode<T>* rotateLeftThenRight(AVLnode<T> *n);
	AVLnode<T>* rotateRightThenLeft(AVLnode<T> *n);
	void rebalance(AVLnode<T> *n);
	int height(AVLnode<T> *n);
	void setBalance(AVLnode<T> *n);
	void printBalance(AVLnode<T> *n);
	void inOrder(AVLnode<T> *t);
	void preOrder(AVLnode<T> *t);
	void postOrder(AVLnode<T> *t);
//	void clearNode(AVLnode<T> *n);
};

/* AVL class definition */
template<class T>
AVLnode<T>* AVLtree<T>::getRoot() {
	return root;
}

template <class T>
void AVLtree<T>::rebalance(AVLnode<T> *n) {
	setBalance(n);

	if (n->balance == -2) {
		if (height(n->left->left) >= height(n->left->right))
			n = rotateRight(n);
		else
			n = rotateLeftThenRight(n);
	}
	else if (n->balance == 2) {
		if (height(n->right->right) >= height(n->right->left))
			n = rotateLeft(n);
		else
			n = rotateRightThenLeft(n);
	}

	if (n->parent != NULL) {
		rebalance(n->parent);
	}
	else {
		root = n;
	}
}

template <class T>
AVLnode<T>* AVLtree<T>::rotateLeft(AVLnode<T> *a) {
	AVLnode<T> *b = a->right;
	b->parent = a->parent;
	a->right = b->left;

	if (a->right != NULL)
		a->right->parent = a;

	b->left = a;
	a->parent = b;

	if (b->parent != NULL) {
		if (b->parent->right == a) {
			b->parent->right = b;
		}
		else {
			b->parent->left = b;
		}
	}

	setBalance(a);
	setBalance(b);
	return b;
}

template <class T>
AVLnode<T>* AVLtree<T>::rotateRight(AVLnode<T> *a) {
	AVLnode<T> *b = a->left;
	b->parent = a->parent;
	a->left = b->right;

	if (a->left != NULL)
		a->left->parent = a;

	b->right = a;
	a->parent = b;

	if (b->parent != NULL) {
		if (b->parent->right == a) {
			b->parent->right = b;
		}
		else {
			b->parent->left = b;
		}
	}

	setBalance(a);
	setBalance(b);
	return b;
}

template <class T>
AVLnode<T>* AVLtree<T>::rotateLeftThenRight(AVLnode<T> *n) {
	n->left = rotateLeft(n->left);
	return rotateRight(n);
}

template <class T>
AVLnode<T>* AVLtree<T>::rotateRightThenLeft(AVLnode<T> *n) {
	n->right = rotateRight(n->right);
	return rotateLeft(n);
}

template <class T>
int AVLtree<T>::height(AVLnode<T> *n) {
	if (n == NULL)
		return -1;
	return 1 + std::max(height(n->left), height(n->right));
}

template <class T>
void AVLtree<T>::setBalance(AVLnode<T> *n) {
	n->balance = height(n->right) - height(n->left);
}

template <class T>
void AVLtree<T>::printBalance(AVLnode<T> *n) {
	if (n != NULL) {
		printBalance(n->left);
		std::cout << n->balance << " ";
		printBalance(n->right);
	}
}

template <class T>
AVLtree<T>::AVLtree(void) : root(NULL) {}

template <class T>
AVLtree<T>::~AVLtree(void) {
	delete root;
}

template <class T>
bool AVLtree<T>::insert(T key) {
	if (root == NULL) {
		root = new AVLnode<T>(key, NULL);
	}
	else {
		AVLnode<T>
			*n = root,
			*parent;

		while (true) {
			/*if (n->key == key)
				return false;*/

			parent = n;

			bool goLeft = key < n->key;
			n = goLeft ? n->left : n->right;

			if (n == NULL) {
				if (goLeft) {
					parent->left = new AVLnode<T>(key, parent);
				}
				else {
					parent->right = new AVLnode<T>(key, parent);
				}

				rebalance(parent);
				break;
			}
		}
	}

	return true;
}

template <class T>
void AVLtree<T>::deleteKey(const T delKey) {
	if (root == NULL)
		return;

	AVLnode<T>
		*n = root,
		*parent = root,
		*delNode = NULL,
		*child = root;

	while (child != NULL) {
		parent = n;
		n = child;
		child = delKey >= n->key ? n->right : n->left;
		if (delKey == n->key)
			delNode = n;
	}

	if (delNode != NULL) {
		delNode->key = n->key;

		child = n->left != NULL ? n->left : n->right;

		if (root->key == delKey) {
			root = child;
		}
		else {
			if (parent->left == n) {
				parent->left = child;
			}
			else {
				parent->right = child;
			}

			rebalance(parent);
		}
	}
}

template <class T>
void AVLtree<T>::printBalance() {
	printBalance(root);
	std::cout << std::endl;
}

template <class T>
void AVLtree<T>::inOrder(AVLnode<T> *t) {
	if (t == NULL)
		return;
	inOrder(t->left);
	std::cout << t->key << " ";
	inOrder(t->right);
}

template <class T>
void AVLtree<T>::preOrder(AVLnode<T> *t) {
	if (t == NULL)
		return;
	std::cout << t->key << " ";
	preOrder(t->left);
	preOrder(t->right);
}

template <class T>
void AVLtree<T>::postOrder(AVLnode<T> *t) {
	if (t == NULL)
		return;
	postOrder(t->left);
	postOrder(t->right);
	std::cout << t->key << " ";
}

template <class T>
void AVLtree<T>::inOrder() {
	inOrder(root);
}

template <class T>
void AVLtree<T>::preOrder() {
	preOrder(root);
}

template <class T>
void AVLtree<T>::postOrder() {
	postOrder(root);
}

template<class It, class T>
void AVLTreeSortHelper(It _First, AVLnode<T> *n, unsigned& count) {
	if (n == NULL)
		return;
	AVLTreeSortHelper(_First, n->left, count);
	*(_First + count) = n->key;
	printf("%d ", n->key);
	++count;
	AVLTreeSortHelper(_First, n->right, count);
}

template<class T, class C>
void AVLTreeSort(T _First, T _Last, C compare) {
	AVLtree<typename std::iterator_traits<T>::value_type> tree;

	auto _Pos = _First;
	while (_Pos != _Last) {
		tree.insert(*_Pos);
		++_Pos;
	}

	unsigned count = 0;
	AVLTreeSortHelper(_First, tree.getRoot(), count);
}



~-----------------------------------------------~
C:\Users\Josh\Documents\Visual Studio 2017\Projects\Sorting\Sorting\bubblesort.h
~-----------------------------------------------~
#pragma once

//#include "Visualizer.h"

#include "trace.h"

template<class T, class C>
inline void bubblesort(T _First, T _Last, C compare) {
	T _Start = _First + 1;
	T _End = _Last;

	while (_Start < _End) {
		T _LastSwap = _Start;
		for (T _Pos = _Start; _Pos < _End; ++_Pos) {
			T _Prev = _Pos - 1;
			if (compare(*_Pos, *_Prev)) {
				iter_swap(_Prev, _Pos);
				_LastSwap = _Pos;
			}
		}
		_End = _LastSwap;

		if (_End == _Start) break;
	}
}

template<class T>
inline void bubblesort(T _First, T _Last) {
	bubblesort(_First, _Last, std::less<>());
}

template<class T, class C>
inline void cocktailshakersort(T _First, T _Last, C compare) {
	T _Start = _First + 1;
	T _End = _Last;

	while (_Start < _End) {
		T _Left = _End;
		T _Right = _Start;
		for (T _Pos = _Start; _Pos < _End; ++_Pos) {
			T _Prev = _Pos - 1;
			if (compare(*_Pos, *_Prev)) {
				iter_swap(_Prev, _Pos);
				_Right = _Pos;
			}
		}
		_End = _Right;

		for (T _Pos = _End; _Pos >= _Start; --_Pos) {
			T _Prev = _Pos - 1;
			if (compare(*_Pos, *_Prev)) {
				iter_swap(_Prev, _Pos);
				_Left = _Pos;
			}
		}
		_Start = _Left;
	}
}

template<class T>
inline void cocktailshakersort(T _First, T _Last) {
	cocktailshakersort(_First, _Last, std::less<>());
}

template<class T, class C>
inline void combsort(T _First, T _Last, C compare) {
	auto _Gap = std::distance(_First, _Last);
	auto _Done = false;
	while (!_Done) {
		_Gap *= 10;
		_Gap /= 13;
		if (_Gap <= 1) {
			_Gap = 1;
			_Done = true;
		//	cocktailshakersort(_First, _Last, compare);
		//	break;
		}
		for (T _Pos = _First; _Last - _Pos > _Gap; ++_Pos) {
			T _Next = _Pos + _Gap;
			if (compare(*_Next, *_Pos)) {
				iter_swap(_Next, _Pos);
				_Done = false;
			}
		}
	}
}

template<class T>
inline void combsort(T _First, T _Last) {
	combsort(_First, _Last, std::less<>());
}

template<class T, class C>
inline void evenoddsort(T _First, T _Last, C compare) {
	T _End = _Last - 1;
	auto sorted = false;
	while (!sorted) {
		sorted = true;
		for (T _Pos = _First + 1; _Pos < _End; _Pos += 2) {
			T _Next = _Pos + 1;
			if (compare(*_Next, *_Pos)) {
				iter_swap(_Pos, _Next);
				sorted = false;
			}
		}
		for (T _Pos = _First; _Pos < _End; _Pos += 2) {
			T _Next = _Pos + 1;
			if (compare(*_Next, *_Pos)) {
				iter_swap(_Pos, _Next);
				sorted = false;
			}
		}
	}
}

template<class T>
inline void evenoddsort(T _First, T _Last) {
	evenoddsort(_First, _Last, std::less<>());
}








~-----------------------------------------------~
C:\Users\Josh\Documents\Visual Studio 2017\Projects\Sorting\Sorting\chart.h
~-----------------------------------------------~
#pragma once

#include <Windows.h>
#include <string>
#include <vector>

#include "visualizer.h"
#include "sorting.h"
#include "benchmark.h"

enum class ChartType {
	Pie, Graph, Line
};

template<class T>
struct Point {
	T x, y;
};

template<class T>
class Data {
public:
	void AddPoint(Point<T> point) {
		points.push_back(point);
	}

	size_t GetNumPoints() {
		return points.size();
	}

	Point<T> GetPoint(size_t i) {
		return points[i];
	}

private:
	std::vector<Point<T>> points;
};

template<class T>
class Chart {
public:
	Chart() { }

	void AddDataPoints(size_t data_i, Data<T>& data) {
		size_t numPoints = data.GetNumPoints();
		for (unsigned i = 0; i < numPoints; ++i) {
			AddDataPoint(data_i, data.GetPoint(i));
		}
	}
	void AddDataPoints(Data<T>& data) {
		AddDataPoints(0, data);
	}

	void AddDataPoints(size_t data_i, const std::vector<Point<T>>& points) {
		for (unsigned i = 0; i < points.size(); ++i)
			AddDataPoint(data_i, points[i]);
	}
	void AddDataPoints(const std::vector<Point<T>>& points) {
		AddDataPoints(0, points);
	}

	void AddDataPoint(const Point<T>& dataPoint) {
		AddDataPoint(0, dataPoint);
	}

	void AddDataPoint(size_t data_i, const Point<T>& dataPoint) {
		add_data_point(data_i, dataPoint);
	}

	static Chart<T>* getChart(HWND hwnd);

	HWND GetHWND() { return hwnd; }

private:
	inline void add_data_point(size_t data_i, const Point<T>& dataPoint) {
		if (dataPoint.x < x_range.min) x_range.min = dataPoint.x;
		else if (dataPoint.x > x_range.max) x_range.max = dataPoint.x;

		if (dataPoint.y < y_range.min) y_range.min = dataPoint.y;
		else if (dataPoint.y > y_range.max) y_range.max = dataPoint.y;

		dataPoints[data_i].AddPoint(dataPoint);
	}

	ChartType type;

	std::wstring title, label_x_axis, label_y_axis;

	Range<T> x_range, y_range;

	std::vector<Data<T>> dataPoints;

	HWND hwnd;

	static LRESULT CALLBACK Proc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam);

	static void DrawScreen(Chart<T>* chart);

	friend class Visualizer;
};

template<class T>
Chart<T>* Chart<T>::getChart(HWND hwnd) {
	return (Chart<T>*)GetWindowLongPtr(hwnd, GWLP_USERDATA);
}

template<class T>
void Chart<T>::DrawScreen(Chart<T>* chart) {
	HWND hwnd = chart->GetHWND();

	Benchmark bm;
	bm.start();

	RECT rcclient;
	GetClientRect(hwnd, &rcclient);

	if (!rcclient.right || !rcclient.bottom) return;

	HDC hdc = GetDC(hwnd);

	HDC hdcmem = CreateCompatibleDC(hdc);

	HBITMAP hbmScreen, hbmOldBitmap;
	hbmScreen = CreateCompatibleBitmap(hdc, rcclient.right, rcclient.bottom);
	hbmOldBitmap = (HBITMAP)SelectObject(hdcmem, hbmScreen);

	//////////////////////////////////////////////////////////////////////////////////////


	FillRect(hdcmem, &rcclient, (HBRUSH)GetStockObject(WHITE_BRUSH));


	//////////////////////////////////////////////////////////////////////////////////////

	//draw the screen
	BitBlt(hdc, 0, 0, rcclient.right, rcclient.bottom, hdcmem, 0, 0, SRCCOPY);

	//cleanup
	SelectObject(hdcmem, hbmOldBitmap);
	DeleteObject(hbmScreen);

	DeleteDC(hdcmem);
	ReleaseDC(hwnd, hdc);

	bm.stop();
}

template<class T>
LRESULT CALLBACK Chart<T>::Proc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam) {
	Chart<T>* chart = Chart<T>::getChart(hwnd);

	switch (message) {
		case WM_NCCREATE: {
			chart = (Chart<T>*)(((LPCREATESTRUCT)lParam)->lpCreateParams);
			chart->hwnd = hwnd;
			SetWindowLongPtr(hwnd, GWLP_USERDATA, (LONG_PTR)chart);

			break;
		}
		case WM_PAINT: {
			DrawScreen(chart);
			break;
		}
		case WM_CLOSE:
		case WM_DESTROY: {
			/*if (chart) {
				delete chart;
				chart = 0;
			}*/
			break;
		}
	}

	return DefWindowProc(hwnd, message, wParam, lParam);
}

















~-----------------------------------------------~
C:\Users\Josh\Documents\Visual Studio 2017\Projects\Sorting\Sorting\countingsort.h
~-----------------------------------------------~
#pragma once

constexpr size_t pow2(size_t e) {
	return (e == 0) ? 1 : 2 * pow2(e - 1);
}

template<class T, class O>
inline void counting_sort(T _First, T _Last, O _Res) {
	constexpr size_t num_c = (size_t)pow2(sizeof(T::value_type) * 8) - 1;
	std::vector<size_t> counts(num_c, 0);

	for (T it = _First; it != _Last; ++it)
		++counts[*it];

	size_t total = 0;
	for (size_t & count : counts) {
		size_t old_count = count;
		count = total;
		total += old_count;
	}

	for (; _First != _Last; ++_First)
		_Res[counts[*_First]++] = *_First;
}

template<class T, class C>
inline void countingsort(T _First, T _Last, C compare) {
	std::vector<T::value_type> _Res(std::distance(_First, _Last));
	counting_sort(_First, _Last, _Res.begin());
	std::copy(_Res.begin(), _Res.end(), _First);
}

template<class T>
inline void countingsort(T _First, T _Last) {
	countingsort(_First, _Last, NULL);
}



















~-----------------------------------------------~
C:\Users\Josh\Documents\Visual Studio 2017\Projects\Sorting\Sorting\customtrackbar.h
~-----------------------------------------------~
#ifndef CustomTrackbar_header_guard
#define CustomTrackbar_header_guard

#include <Windows.h>
#include <string>
#include <vector>

static TCHAR CustomTrackbar_classname[] = TEXT("custom trackbar");

#define CTB_CHANGE (WM_USER + 3)

//const UINT WM_customtrackbar_VALUE_CHANGED = RegisterWindowMessageA("custom trackbar value changed");

ATOM register_customtrackbar();

#define WM_MOUSEENTER (WM_USER)
#define WM_UPDATE (WM_USER + 1)
#define HTTHUMB (WM_USER + 2)

struct BasicControl_colorscheme {
	COLORREF background_idle_on;
	COLORREF border_idle_on;
	COLORREF text_idle_on;
	COLORREF background_hover_on;
	COLORREF border_hover_on;
	COLORREF text_hover_on;
	//COLORREF background_selected_on;
	//COLORREF border_selected_on;
	//COLORREF text_selected_on;

	COLORREF background_idle_off;
	COLORREF border_idle_off;
	COLORREF text_idle_off;
	COLORREF background_hover_off;
	COLORREF border_hover_off;
	COLORREF text_hover_off;
	//COLORREF background_selected_off;
	//COLORREF border_selected_off;	
	//COLORREF text_selected_off;

	BasicControl_colorscheme();
	BasicControl_colorscheme(
		COLORREF background_idle_on, COLORREF border_idle_on, COLORREF text_idle_on
	);
	BasicControl_colorscheme(
		COLORREF background_idle_on, COLORREF border_idle_on, COLORREF text_idle_on,
		COLORREF background_hover_on, COLORREF border_hover_on, COLORREF text_hover_on
		//,COLORREF background_selected_on, COLORREF border_selected_on, COLORREF text_selected_on);
	);
	BasicControl_colorscheme(
		COLORREF background_idle_on, COLORREF border_idle_on, COLORREF text_idle_on,
		COLORREF background_hover_on, COLORREF border_hover_on, COLORREF text_hover_on,
		//COLORREF background_selected_on, COLORREF border_selected_on, COLORREF text_selected_on,
		COLORREF background_idle_off, COLORREF border_idle_off, COLORREF text_idle_off,
		COLORREF background_hover_off, COLORREF border_hover_off, COLORREF text_hover_off
		//COLORREF background_selected_off, COLORREF border_selected_off, COLORREF text_selected_off);
	);
};

class BasicControl {
public:
	std::string className;
	HWND hwnd;
	std::string window_text;
	UINT window_exstyles = NULL;
	UINT window_styles;
	int xpos;
	int ypos;
	int width;
	int height;
	UINT id;
	void(*Proc)(WPARAM wParam, LPARAM lParam);
	HFONT font;
	HCURSOR client_cursor;
	int toggle_state;

	bool mouse_in_client = false;
	bool focus = false;

	BasicControl();

	HWND Create(HWND parent);

	void Show();
	void Hide();
};

BasicControl* getBasicControl(HWND wnd);



enum CUSTOM_TRACKBAR_FLAGS {
	CTB_BORDER = 1 << 0,		//always show border, default shows when focused hides when not
	CTB_NOBORDER = 1 << 1,		//never show border, default shows when focused hides when not

	CTB_SMOOTH = 1 << 2,		//trackbar moves smoothly, default trackbar moves on value
	CTB_STAY = 1 << 3,			//trackbar doesn't jump to real value on release, default does

	CTB_VERT = 1 << 4,			//trackbar verticle, default horizontal

	CTB_THUMBVALUE = 1 << 5,	//display current value on thumb, default don't
};

struct TrackbarColorScheme {
	COLORREF background;
	COLORREF border;

	COLORREF window_name_idle;
	COLORREF window_name_highlight;

	COLORREF left_channel_idle;
	COLORREF right_channel_idle;
	COLORREF left_channel_highlight;
	COLORREF right_channel_highlight;

	COLORREF thumb_background_idle;
	COLORREF thumb_background_hover;
	COLORREF thumb_background_selected;

	COLORREF thumb_border_idle;
	COLORREF thumb_border_hover;
	COLORREF thumb_border_selected;

	COLORREF thumb_text_idle;
	COLORREF thumb_text_hover;
	COLORREF thumb_text_selected;
};

class CustomTrackbar : public BasicControl {
public:
	RECT thumb_region;
	std::string window_name;
	UINT thumb_size;
	int start_val, current_val, pos;
	int min_val, max_val;
	int small_step, large_step;
	UINT channel_size;
	UINT flags;
	TrackbarColorScheme tcolor_scheme;
	HCURSOR thumb_cursor;

	bool start;
	bool mouse_in_client = false;
	bool dragging = false;
	bool thumb_hover = false;
	bool thumb_selected = false;

	HWND scrollbar_owner_handle;

	CustomTrackbar() {}
	~CustomTrackbar() {}

	CustomTrackbar(std::string window_name, UINT window_styles, int xpos, int ypos, UINT width, UINT height, int id,
				   int min_val, int max_val, int start_val, int small_step, int large_step, UINT thumb_size, UINT channel_size, UINT flags,
				   TrackbarColorScheme color_scheme, HCURSOR client_cursor = NULL, HCURSOR thumb_cur = NULL);

	int setPos(int pos);

	int setVal(int pos);

	int setPosWithVal(int val);

	int moveThumb(int pos);
	void moveThumbReal(int pos);

	void thumbHitText();

	void setFocus(bool focus, HWND hwnd_focus = NULL);

	bool setRange(int min, int max);

	void redrawNewVal(int val);

	static LRESULT CALLBACK  customtrackbarProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam);
};

#endif

























~-----------------------------------------------~
C:\Users\Josh\Documents\Visual Studio 2017\Projects\Sorting\Sorting\cyclesort.h
~-----------------------------------------------~
#pragma once

template<class T, class C>
void cyclesort_(T a, int n, C compare) {
	using std::swap;
	int writes = 0;
	for (int c_start = 0; c_start <= n - 2; c_start++) {
		typename T::value_type item = a[c_start];
		int pos = c_start;
		for (int i = c_start + 1; i < n; i++)
			if (a[i] < item)
				pos++;
		if (pos == c_start)
			continue;
		while (item == a[pos])
			pos += 1;
		if (pos != c_start) {
			swap(item, a[pos]);
			writes++;
		}
		while (pos != c_start) {
			pos = c_start;
			for (int i = c_start + 1; i < n; i++)
				if (a[i] < item)
					pos += 1;
			while (item == a[pos])
				pos += 1;
			if (item != a[pos]) {
				swap(item, a[pos]);
				writes++;
			}
		}
	}
}

template<class T, class C>
void cyclesort(T _First, T _Last, C compare) {
	cyclesort_(_First, std::distance(_First, _Last), compare);
}

template<class T>
void cyclesort(T _First, T _Last) {
	cyclesort(_First, _Last, std::less<>());
}


























~-----------------------------------------------~
C:\Users\Josh\Documents\Visual Studio 2017\Projects\Sorting\Sorting\dropmergesort.h
~-----------------------------------------------~
#ifndef DROP_MERGE_SORT_H
#define DROP_MERGE_SORT_H

#include <vector>
#include <algorithm>
#include <type_traits>
#include <iterator>

/*
A C++ reimplementation of a drop-merge sort, originally made by Emil Ernerfeldt:
https://github.com/emilk/drop-merge-sort
There are two versions of this function.
The first one is identical to the reference Rust implementation.
It doesn't support uncopyable types.
Here, it's used only for trivially copyable types.
(just like the Rust version, which required the Copy trait).
The second version is copy-free, so it supports noncopyable types like std::unique_ptr.
It's also more efficient for types with expensive copying, like std::string.
However, being copy-free involves some extra bookkeeping, so for trivial types
it's a bit less efficient than the original function - which is why I use both versions.
*/

namespace detail {

constexpr static bool double_comparison = true;

// with-trivial-copies version
template<typename Iter, typename Comp>
void dmsort(Iter begin, Iter end, Comp comp/*, std::true_type*/) {
	size_t size = end - begin;

	if (size < 2)
		return;

	using Value = typename std::iterator_traits<Iter>::value_type;
	std::vector<Value> dropped;

	size_t num_dropped_in_row = 0;
	auto write = begin;
	auto read = begin;

	constexpr size_t recency = 8;

	while (read != end) {
		if (begin != write && comp(*read, *(write - 1))) {

			if (double_comparison && num_dropped_in_row == 0 && write > begin + 1 && !comp(*read, *(write - 2))) {
				dropped.push_back(*(write - 1));
				*(write - 1) = *read;
				++read;
				continue;
			}

			if (num_dropped_in_row < recency) {
				dropped.push_back(*read);
				++read;
				++num_dropped_in_row;
			}
			else {
				for (size_t i = 0; i < num_dropped_in_row; ++i) {
					dropped.pop_back();
				}
				read -= num_dropped_in_row;

				--write;
				dropped.push_back(*write);

				num_dropped_in_row = 0;
			}
		}
		else {
			// Here we don't need to guard against self-move because such an
			// operation can't destroy the value for trivially copyable types
			*write = std::move(*read);
			++read;
			++write;
			num_dropped_in_row = 0;
		}
	}

	std::sort(dropped.begin(), dropped.end(), comp);

	auto back = end;

	while (!dropped.empty()) {
		auto & last_dropped = dropped.back();

		while (begin != write && comp(last_dropped, *(write - 1))) {
			--back;
			--write;
			*back = std::move(*write);
		}
		--back;
		*back = std::move(last_dropped);
		dropped.pop_back();
	}
}

// move-only version
template<typename Iter, typename Comp>
void dmsort(Iter begin, Iter end, Comp comp, std::false_type) {
	size_t size = end - begin;

	if (size < 2)
		return;

	using Value = typename std::iterator_traits<Iter>::value_type;
	std::vector<Value> dropped;

	size_t num_dropped_in_row = 0;
	auto write = begin;
	auto read = begin;

	constexpr size_t recency = 8;

	while (read != end) {
		if (begin != write && comp(*read, *(write - 1))) {

			if (double_comparison && num_dropped_in_row == 0 && write > begin + 1 && !comp(*read, *(write - 2))) {
				dropped.push_back(std::move(*(write - 1)));
				*(write - 1) = std::move(*read);
				++read;
				continue;
			}

			if (num_dropped_in_row < recency) {
				dropped.push_back(std::move(*read));
				++read;
				++num_dropped_in_row;
			}
			else {
				for (int i = 0; i < num_dropped_in_row; ++i) {
					--read;
					*read = std::move(*(dropped.end() - 1));
					dropped.pop_back();
				}

				--write;
				dropped.push_back(std::move(*write));

				num_dropped_in_row = 0;
			}
		}
		else {
			if (read != write) {
				*write = std::move(*read);
			}
			++read;
			++write;
			num_dropped_in_row = 0;
		}
	}

	std::sort(dropped.begin(), dropped.end(), comp);

	auto back = end;

	while (!dropped.empty()) {
		auto & last_dropped = dropped.back();

		while (begin != write && comp(last_dropped, *(write - 1))) {
			--back;
			--write;
			*back = std::move(*write);
		}
		--back;
		*back = std::move(last_dropped);
		dropped.pop_back();
	}
}
}
template<typename Iter, typename Comp>
void dropmergesort(Iter begin, Iter end, Comp comp) {
	using Value = typename std::iterator_traits<Iter>::value_type;
	::detail::dmsort(begin, end, comp/*, std::is_trivially_copyable<Value>()*/);
}
template<typename Iter>
void dropmergesort(Iter begin, Iter end) {
	dropmergesort(begin, end, std::less<>());
}

#endif // DROP_MERGE_SORT_H




















~-----------------------------------------------~
C:\Users\Josh\Documents\Visual Studio 2017\Projects\Sorting\Sorting\gnomesort.h
~-----------------------------------------------~
#pragma once

template <class T, class C>
void gnomesort(T _First, T _Last, C compare) {
	T _Pos = _First;

	while (_Pos != _Last) {
		if (_Pos == _First || !compare(*_Pos, *(_Pos - 1))) {
			++_Pos;
		}
		else {
			iter_swap(_Pos, (_Pos - 1));
			--_Pos;
		}
	}
}

template <class T>
inline void gnomesort(T _First, T _Last) {
	gnomesort(_First, _Last, std::less<>());
}

template <class T, class C>
inline void optimizedgnomesort(T _First, T _Last, C compare) {
	auto _Pos = _First + 1;
	auto _JmpPos = _First + 2;

	while (_Pos < _Last) {
		if (!(compare(*_Pos, *(_Pos - 1)))) {
			_Pos = _JmpPos;
			if (_JmpPos != _Last)
				++_JmpPos;
		}
		else {
			iter_swap(_Pos - 1, _Pos);
			--_Pos;
			if (_Pos == _First) {
				_Pos = _JmpPos;
				if (_JmpPos != _Last)
					++_JmpPos;
			}
		}
	}
}

template <class T>
inline void optimizedgnomesort(T _First, T _Last) {
	optimizedgnomesort(_First, _Last, std::less<>());
}
















~-----------------------------------------------~
C:\Users\Josh\Documents\Visual Studio 2017\Projects\Sorting\Sorting\grailsort.h
~-----------------------------------------------~
#pragma once


#include <functional>
#include <string>
#include <type_traits>
#include <utility>

template<typename Derived>
struct three_way_compare_base {
	public:

	template<typename T, typename U>
	constexpr auto operator()(T&& lhs, U&& rhs) const
		-> int {
		auto&& compare = derived().base();
		return compare(std::forward<T>(lhs), std::forward<U>(rhs)) ? -1 :
			compare(std::forward<U>(rhs), std::forward<T>(lhs));
	}

	template<typename T, typename U>
	auto lt(T&& x, U&& y) const
		-> decltype(auto) {
		return derived().base()(std::forward<T>(x), std::forward<U>(y));
	}

	template<typename T, typename U>
	auto le(T&& x, U&& y) const
		-> decltype(auto) {
		return not derived().base()(std::forward<U>(y), std::forward<T>(x));
	}

	template<typename T, typename U>
	auto gt(T&& x, U&& y) const
		-> decltype(auto) {
		return derived().base()(std::forward<U>(y), std::forward<T>(x));
	}

	template<typename T, typename U>
	auto ge(T&& x, U&& y) const
		-> decltype(auto) {
		return not derived().base()(std::forward<T>(x), std::forward<U>(y));
	}

	private:

	auto derived() noexcept
		-> Derived& {
		return static_cast<Derived&>(*this);
	}

	auto derived() const noexcept
		-> const Derived& {
		return static_cast<const Derived&>(*this);
	}
};

template<
	typename Compare,
	bool = std::is_empty<Compare>::value && std::is_default_constructible<Compare>::value
>
struct three_way_compare :
	three_way_compare_base<three_way_compare<Compare>> {
	public:

	constexpr three_way_compare(Compare compare) :
		compare(std::move(compare)) {}

	constexpr auto base() const noexcept
		-> Compare {
		return compare;
	}

	private:

	Compare compare;
};

template<typename Compare>
struct three_way_compare<Compare, true> :
	three_way_compare_base<three_way_compare<Compare>> {
	constexpr three_way_compare(Compare) {}

	using three_way_compare_base<three_way_compare<Compare>>::operator();

	constexpr auto base() const noexcept
		-> Compare {
		// If the comparator is empty, we don't need to store it
		return {};
	}
};

template<>
struct three_way_compare<std::less<>, true> :
	three_way_compare_base<three_way_compare<std::less<>>> {
	constexpr three_way_compare(std::less<>) {}

	using three_way_compare_base<three_way_compare<std::less<>>>::operator();

	template<
		typename CharT,
		typename Traits1, typename Alloc1,
		typename Traits2, typename Alloc2
	>
		auto operator()(const std::basic_string<CharT, Traits1, Alloc1>& lhs,
						const std::basic_string<CharT, Traits2, Alloc2>& rhs) const
		-> int {
		return lhs.compare(0, lhs.size(), rhs.data(), rhs.size());
	}

	constexpr auto base() const noexcept
		-> std::less<> {
		return {};
	}
};

template<>
struct three_way_compare<std::greater<>, true> :
	three_way_compare_base<three_way_compare<std::greater<>>> {
	constexpr three_way_compare(std::greater<>) {}

	using three_way_compare_base<three_way_compare<std::greater<>>>::operator();

	template<
		typename CharT,
		typename Traits1, typename Alloc1,
		typename Traits2, typename Alloc2
	>
		auto operator()(const std::basic_string<CharT, Traits1, Alloc1>& lhs,
						const std::basic_string<CharT, Traits2, Alloc2>& rhs) const
		-> int {
		int res = lhs.compare(0, lhs.size(), rhs.data(), rhs.size());
		return (res < 0) ? 1 : -res;
	}

	constexpr auto base() const noexcept
		-> std::greater<> {
		return {};
	}
};


	// cost: 2 * len + nk^2 / 2
template<typename RandomAccessIterator, typename Compare>
auto find_keys(RandomAccessIterator first, RandomAccessIterator last,
			   std::_Iter_diff_t<RandomAccessIterator> key_count,
			   Compare compare)
	-> std::_Iter_diff_t<RandomAccessIterator> {
	

	std::_Iter_diff_t<RandomAccessIterator> dist = 1;
	auto h0 = first;
	for (auto u = std::next(first); u != last; ++u) {
		if (dist == key_count) break;
		auto r = std::lower_bound(h0, h0 + dist, *u, compare.base()) - h0;
		if (r == dist || compare(*u, h0[r]) != 0) {
			h0 = std::rotate(h0, h0 + dist, u);
			std::rotate(h0 + r, u, std::next(u));
			++dist;
		}
	}
	std::rotate(first, h0, h0 + dist);
	return dist;
}

// cost: min(L1, L2)^2 + max(L1, L2)
template<typename RandomAccessIterator, typename Compare>
auto merge_without_buffer(RandomAccessIterator first, RandomAccessIterator middle,
						  RandomAccessIterator last,
						  Compare compare)
	-> void {
	

	if (std::distance(first, middle) < std::distance(middle, last)) {
		while (first != middle) {
			// Binary search left
			auto it = std::lower_bound(middle, last, *first, compare.base());
			if (it != middle) {
				std::rotate(first, middle, it);
				auto delta = std::distance(middle, it);
				first += delta;
				middle += delta;
			}
			if (middle == last) break;
			do {
				++first;
			} while (first != middle && compare(*first, *middle) <= 0);
		}
	}
	else {
		while (middle != last) {
			// Binary search right
			auto it = std::upper_bound(first, middle, *std::prev(last), compare.base());
			if (it != middle) {
				std::rotate(it, middle, last);
				auto delta = std::distance(it, middle);
				middle -= delta;
				last -= delta;
			}
			if (first == middle) break;
			do {
				--last;
			} while (middle != last && compare(*std::prev(middle), *std::prev(last)) <= 0);
		}
	}
}

// arr[M..-1] - buffer, arr[0,L1-1]++arr[L1,L1+L2-1] -> arr[M,M+L1+L2-1]
template<typename RandomAccessIterator, typename Compare>
auto merge_left(RandomAccessIterator first, RandomAccessIterator middle,
				RandomAccessIterator last, RandomAccessIterator M,
				Compare compare)
	-> void {
	
	

	auto left_it = first;
	auto right_it = middle;

	while (right_it != last) {
		if (left_it == middle || compare(*left_it, *right_it) > 0) {
			iter_swap(M, right_it);
			++right_it;
		}
		else {
			iter_swap(M, left_it);
			++left_it;
		}
		++M;
	}
	if (M != left_it) {
		std::swap_ranges(M, M + std::distance(left_it, middle), left_it);
	}
}

template<typename RandomAccessIterator, typename Compare>
auto merge_right(RandomAccessIterator first, RandomAccessIterator middle,
				 RandomAccessIterator last, RandomAccessIterator M,
				 Compare compare)
	-> void {
	
	

	auto p0 = std::prev(M),
		p1 = std::prev(middle),
		p2 = std::prev(last);

	while (p1 >= first) {
		if (p2 < middle || compare(*p1, *p2) > 0) {
			iter_swap(p0, p1);
			--p1;
		}
		else {
			iter_swap(p0, p2);
			--p2;
		}
		--p0;
	}

	if (p2 != p0 && p2 >= middle) {
		do {
			iter_swap(p0, p2);
			--p0;
			--p2;
		} while (p2 != middle);
	}
}

template<typename RandomAccessIterator, typename Compare>
auto smart_merge_with_buffer(RandomAccessIterator first, RandomAccessIterator middle, RandomAccessIterator last,
							 std::_Iter_diff_t<RandomAccessIterator> block_len, int left_over_frag,
							 Compare compare)
	-> std::pair<std::_Iter_diff_t<RandomAccessIterator>, int> {
	
	

	auto out_it = first - block_len,
		left_it = first,
		right_it = middle;
	int frag_type = 1 - left_over_frag;  // 1 if inverted

	while (left_it != middle && right_it != last) {
		if (compare(*left_it, *right_it) - frag_type < 0) {
			iter_swap(out_it, left_it);
			++left_it;
		}
		else {
			iter_swap(out_it, right_it);
			++right_it;
		}
		++out_it;
	}

	//auto p1 = left_it, q1 = middle, p2 = right_it, q2 = last;
	std::_Iter_diff_t<RandomAccessIterator> len;
	if (left_it < middle) {
		len = std::distance(left_it, middle);
		do {
			iter_swap(--middle, --last);
		} while (left_it != middle);
	}
	else {
		len = std::distance(right_it, last);
		left_over_frag = frag_type;
	}
	return {len, left_over_frag};
}

template<typename RandomAccessIterator, typename Compare>
auto smart_merge_without_buffer(RandomAccessIterator first, RandomAccessIterator middle,
								RandomAccessIterator last, int left_over_frag,
								Compare compare)
	-> std::pair<int, int> {
	

	if (middle == last) {
		return {std::distance(first, middle), left_over_frag};
	}

	int frag_type = 1 - left_over_frag;
	if (first != middle && compare(*std::prev(middle), *middle) - frag_type >= 0) {
		while (first != middle) {
			auto len = frag_type ? (std::lower_bound(middle, last, *first, compare.base()) - middle)
				: (std::upper_bound(middle, last, *first, compare.base()) - middle);
			if (len != 0) {
				std::rotate(first, middle, middle + len);
				first += len;
				middle += len;
			}
			if (middle == last) {
				return {std::distance(first, middle), left_over_frag};
			}
			do {
				++first;
			} while (first != middle && compare(*first, *middle) - frag_type < 0);
		}
	}
	return {std::distance(middle, last), frag_type};
}

// Sort With Extra Buffer

template<typename ForwardIterator, typename Compare>
auto merge_left_with_extra_buffer(ForwardIterator first, ForwardIterator middle,
								  ForwardIterator last, ForwardIterator out,
								  Compare compare)
	-> void {
	
	

	auto it = middle;
	while (it != last) {
		if (first == middle || compare(*first, *it) > 0) {
			*out = std::move(*it);
			++out;
			++it;
		}
		else {
			*out = std::move(*first);
			++out;
			++first;
		}
	}
	if (out != first) {
		std::move(first, middle, out);
	}
}

template<typename RandomAccessIterator, typename Compare>
auto smart_merge_with_extra_buffer(RandomAccessIterator first, RandomAccessIterator middle,
								   RandomAccessIterator last,
								   int left_over_frag, std::_Iter_diff_t<RandomAccessIterator> block_len,
								   Compare compare)
	-> std::pair<int, int> {
	
	

	auto out = first - block_len;
	auto it = middle;

	int frag_type = 1 - left_over_frag;  // 1 if inverted
	while (first < middle && it < last) {
		if (compare(*first, *it) - frag_type < 0) {
			*out = std::move(*first);
			++first;
		}
		else {
			*out = std::move(*it);
			++it;
		}
		++out;
	}

	if (first < middle) {
		auto left_over_len = std::distance(first, middle);
		do {
			*--last = std::move(*--middle);
		} while (first != middle);
		return {left_over_len, left_over_frag};
	}
	return {std::distance(it, last), frag_type};
}

// arr - starting array. arr[-lblock..-1] - buffer (if havebuf).
// lblock - length of regular blocks. First nblocks are stable sorted by 1st elements and key-coded
// keys - arrays of keys, in same order as blocks. key<midkey means stream A
// nblock2 are regular blocks from stream A. llast is length of last (irregular) block from stream B, that should go before nblock2 blocks.
// llast=0 requires nblock2=0 (no irregular blocks). llast>0, nblock2=0 is possible.
template<typename RandomAccessIterator, typename Compare>
auto merge_buffers_left_with_extra_buffer(RandomAccessIterator keys, RandomAccessIterator midkey,
										  RandomAccessIterator arr, int nblock, int lblock, int nblock2,
										  int llast, Compare compare)
	-> void {
	

	if (nblock == 0) {
		auto l = arr + nblock2 * lblock;
		merge_left_with_extra_buffer(arr, l, l + llast, arr - lblock, compare);
		return;
	}

	int lrest = lblock;
	int frest = compare(*keys, *midkey) < 0 ? 0 : 1;
	auto pidx = arr + lblock;
	for (int cidx = 1; cidx < nblock; (void) ++cidx, pidx += lblock) {
		auto prest = pidx - lrest;
		int fnext = compare(keys[cidx], *midkey) < 0 ? 0 : 1;
		if (fnext == frest) {
			std::move(prest, prest + lrest, prest - lblock);
			prest = pidx;
			lrest = lblock;
		}
		else {
			std::tie(lrest, frest) = smart_merge_with_extra_buffer(
				prest, prest + lrest, prest + (lrest + lblock),
				frest, lblock, compare);
		}
	}
	auto prest = pidx - lrest;
	if (llast) {
		if (frest) {
			std::move(prest, prest + lrest, prest - lblock);
			prest = pidx;
			lrest = lblock * nblock2;
		}
		else {
			lrest += lblock * nblock2;
		}
		merge_left_with_extra_buffer(prest, prest + lrest, prest + (lrest + llast), prest - lblock,
									 std::move(compare));
	}
	else {
		std::move(prest, prest + lrest, prest - lblock);
	}
}

/***** End Sort With Extra Buffer *****/

// arr - starting array. arr[-lblock..-1] - buffer (if havebuf).
// lblock - length of regular blocks. First nblocks are stable sorted by 1st elements and key-coded
// keys - arrays of keys, in same order as blocks. key<midkey means stream A
// nblock2 are regular blocks from stream A. llast is length of last (irregular) block from stream B,
// that should go before nblock2 blocks.
// llast=0 requires nblock2=0 (no irregular blocks). llast>0, nblock2=0 is possible.
template<typename RandomAccessIterator, typename Compare>
auto merge_buffers_left(RandomAccessIterator keys, RandomAccessIterator midkey,
						RandomAccessIterator arr, int nblock, int lblock, bool havebuf,
						int nblock2, int llast, Compare compare)
	-> void {


	if (nblock == 0) {
		auto l = arr + nblock2 * lblock;
		if (havebuf) {
			merge_left(arr, l, l + llast, arr - lblock, std::move(compare));
		}
		else {
			merge_without_buffer(arr, l, l + llast, std::move(compare));
		}
		return;
	}

	int lrest = lblock;
	int frest = compare(*keys, *midkey) < 0 ? 0 : 1;
	auto pidx = arr + lblock;
	for (int cidx = 1; cidx < nblock; (void) ++cidx, pidx += lblock) {
		auto prest = pidx - lrest;
		int fnext = compare(keys[cidx], *midkey) < 0 ? 0 : 1;
		if (fnext == frest) {
			if (havebuf) {
				std::swap_ranges(prest - lblock, prest - (lblock - lrest), prest);
			}
			prest = pidx;
			lrest = lblock;
		}
		else {
			if (havebuf) {
				std::tie(lrest, frest) = smart_merge_with_buffer(
					prest, prest + lrest, prest + (lrest + lblock),
					lblock, frest, compare);
			}
			else {
				std::tie(lrest, frest) = smart_merge_without_buffer(
					prest, prest + lrest, prest + (lrest + lblock),
					frest, compare);
			}

		}
	}

	auto prest = pidx - lrest;
	if (llast) {
		if (frest) {
			if (havebuf) {
				std::swap_ranges(prest - lblock, prest - (lblock - lrest), prest);
			}
			prest = pidx;
			lrest = lblock * nblock2;
		}
		else {
			lrest += lblock * nblock2;
		}
		if (havebuf) {
			merge_left(prest, prest + lrest, prest + (lrest + llast), prest - lblock,
					   std::move(compare));
		}
		else {
			merge_without_buffer(prest, prest + lrest, prest + (lrest + llast),
								 std::move(compare));
		}
	}
	else {
		if (havebuf) {
			std::swap_ranges(prest, prest + lrest, prest - lblock);
		}
	}
}

// build blocks of length K
// input: [-K,-1] elements are buffer
// output: first K elements are buffer, blocks 2*K and last subblock sorted
template<typename RandomAccessIterator, typename BufferIterator,
	typename Compare>
	auto build_blocks(RandomAccessIterator first, RandomAccessIterator last,
					  int K, BufferIterator extbuf, int LExtBuf,
					  Compare compare)
	-> void {
	
	
	
	auto size = std::distance(first, last);

	int kbuf = std::min(K, LExtBuf);
	while (kbuf & (kbuf - 1)) {
		kbuf &= kbuf - 1;  // max power or 2 - just in case
	}

	int h;
	if (kbuf) {
		std::move(first - kbuf, first, extbuf);
		for (int m = 1; m < size; m += 2) {
			int u = 0;
			if (compare(first[m - 1], first[m]) > 0) {
				u = 1;
			}
			first[m - 3] = std::move(*(first + (m - 1 + u)));
			first[m - 2] = std::move(*(first + (m - u)));
		}
		if (size % 2) {
			first[size - 3] = std::move(*(first + (size - 1)));
		}
		first -= 2;
		last -= 2;
		for (h = 2; h < kbuf; h *= 2) {
			auto p0 = first;
			auto p1 = last - 2 * h;
			while (p0 <= p1) {
				merge_left_with_extra_buffer(p0, p0 + h, p0 + (h + h), p0 - h, compare);
				p0 += 2 * h;
			}
			int rest = std::distance(p0, last);
			if (rest > h) {
				merge_left_with_extra_buffer(p0, p0 + h, last, p0 - h, compare);
			}
			else {
				for (; p0 < last; ++p0) {
					p0[-h] = std::move(*p0);
				}
			}
			first -= h;
			last -= h;
		}
		std::move(extbuf, extbuf + kbuf, last);
	}
	else {
		for (int m = 1; m < size; m += 2) {
			int u = 0;
			if (compare(first[m - 1], first[m]) > 0) {
				u = 1;
			}
			iter_swap(first + (m - 3), first + (m - 1 + u));
			iter_swap(first + (m - 2), first + (m - u));
		}
		if (size % 2) {
			iter_swap(last - 1, last - 3);
		}
		first -= 2;
		last -= 2;
		h = 2;
	}
	for (; h < K; h *= 2) {
		auto p0 = first;
		auto p1 = last - 2 * h;
		while (p0 <= p1) {
			merge_left(p0, p0 + h, p0 + (h + h), p0 - h, compare);
			p0 += 2 * h;
		}
		int rest = std::distance(p0, last);
		if (rest > h) {
			merge_left(p0, p0 + h, last, p0 - h, compare);
		}
		else {
			std::rotate(p0 - h, p0, last);
		}
		first -= h;
		last -= h;
	}
	int restk = size % (2 * K);
	auto p = last - restk;
	if (restk <= K) {
		std::rotate(p, last, last + K);
	}
	else {
		merge_right(p, p + K, last, last + K, compare);
	}
	while (p > first) {
		p -= 2 * K;
		merge_right(p, p + K, p + (K + K), p + (K + K + K), compare);
	}
}

// keys are on the left of arr. Blocks of length LL combined. We'll combine them in pairs
// LL and nkeys are powers of 2. (2*LL/lblock) keys are guarantied
template<typename RandomAccessIterator, typename BufferIterator,
	typename Compare>
	auto combine_blocks(RandomAccessIterator keys, RandomAccessIterator arr, int len, int LL,
						int lblock, bool havebuf, BufferIterator xbuf, bool usexbuf,
						Compare compare)
	-> void {
	
	
	

	int M = len / (2 * LL);
	int lrest = len % (2 * LL);
	if (lrest <= LL) {
		len -= lrest;
		lrest = 0;
	}
	if (usexbuf) {
		std::move(arr - lblock, arr, xbuf);
	}
	for (int b = 0; b <= M; ++b) {
		if (b == M && lrest == 0) break;
		auto arr1 = arr + b * 2 * LL;
		int NBlk = (b == M ? lrest : 2 * LL) / lblock;
		::insertion_sort(keys, keys + (NBlk + (b == M ? 1 : 0)),
					   compare.base());
		int midkey = LL / lblock;
		for (int u = 1; u < NBlk; ++u) {
			int p = u - 1;
			for (int v = u; v < NBlk; ++v) {
				int kc = compare(arr1[p*lblock], arr1[v*lblock]);
				if (kc > 0 || (kc == 0 && compare(keys[p], keys[v]) > 0)) {
					p = v;
				}
			}
			if (p != u - 1) {
				std::swap_ranges(arr1 + (u - 1)*lblock, arr1 + u * lblock, arr1 + p * lblock);
				iter_swap(keys + (u - 1), keys + p);
				if (midkey == u - 1 || midkey == p) {
					midkey ^= (u - 1) ^ p;
				}
			}
		}
		int nbl2 = 0;
		int llast = 0;
		if (b == M) {
			llast = lrest % lblock;
		}
		if (llast != 0) {
			while (nbl2 < NBlk &&
				   compare(arr1[NBlk*lblock], arr1[(NBlk - nbl2 - 1)*lblock]) < 0) {
				++nbl2;
			}
		}
		if (usexbuf) {
			merge_buffers_left_with_extra_buffer(keys, keys + midkey, arr1, NBlk - nbl2, lblock, nbl2, llast,
												 compare);
		}
		else {
			merge_buffers_left(keys, keys + midkey, arr1, NBlk - nbl2, lblock, havebuf, nbl2, llast,
							   compare);
		}
	}
	if (usexbuf) {
		for (int p = len; --p >= 0;) {
			arr[p] = std::move(*(arr + (p - lblock)));
		}
		std::move(xbuf, xbuf + lblock, arr - lblock);
	}
	else if (havebuf) {
		while (--len >= 0) {
			iter_swap(arr + len, arr + (len - lblock));
		}
	}
}

template<typename RandomAccessIterator, typename Compare>
auto lazy_stable_sort(RandomAccessIterator first, RandomAccessIterator last,
					  Compare compare)
	-> void {
	
	

	for (auto it = std::next(first); it < last; it += 2) {
		if (compare(*std::prev(it), *it) > 0) {
			iter_swap(std::prev(it), it);
		}
	}

	auto size = std::distance(first, last);
	for (int h = 2; h < size; h *= 2) {
		auto p0 = first;
		auto p1 = last - 2 * h;
		while (p0 <= p1) {
			merge_without_buffer(p0, p0 + h, p0 + (h + h), compare);
			p0 += 2 * h;
		}
		int rest = std::distance(p0, last);
		if (rest > h) {
			merge_without_buffer(p0, p0 + h, last, compare);
		}
	}
}

template<typename BidirectionalIterator, typename Compare>
auto insertion_sort(BidirectionalIterator first, BidirectionalIterator last,
					Compare compare)
	-> void {
	if (first == last) return;

	for (BidirectionalIterator cur = std::next(first); cur != last; ++cur) {
		BidirectionalIterator sift = cur;
		BidirectionalIterator sift_1 = std::prev(cur);

		// Compare first so we can avoid 2 moves for
		// an element already positioned correctly.
		if (compare(*sift, *sift_1)) {
			auto tmp = *sift;
			do {
				*sift = *sift_1;
			} while (--sift != first && compare(tmp, *--sift_1));
			*sift = std::move(tmp);
		}
	}
}

template<typename RandomAccessIterator, typename BufferIterator,
	typename Compare>
	auto common_sort(RandomAccessIterator first, RandomAccessIterator last,
					 BufferIterator extbuf, int LExtBuf,
					 Compare compare)
	-> void {
	auto size = std::distance(first, last);
	if (size < 16) {
		insertion_sort(first, last, compare.base());
		return;
	}

	int lblock = 1;
	while (lblock * lblock < size) {
		lblock *= 2;
	}
	int nkeys = (size - 1) / lblock + 1;
	int findkeys = find_keys(first, last, nkeys + lblock, compare);
	bool havebuf = true;
	if (findkeys < nkeys + lblock) {
		if (findkeys < 4) {
			lazy_stable_sort(first, last, std::move(compare));
			return;
		}
		nkeys = lblock;
		while (nkeys > findkeys) {
			nkeys /= 2;
		}
		havebuf = false;
		lblock = 0;
	}
	auto ptr = first + (lblock + nkeys);
	int cbuf = havebuf ? lblock : nkeys;
	if (havebuf) {
		build_blocks(ptr, last, cbuf, extbuf, LExtBuf, compare);
	}
	else {
		using T = std::_Iter_value_t<BufferIterator>;
		build_blocks(ptr, last, cbuf, static_cast<T*>(nullptr), 0, compare);
	}

	// 2*cbuf are built
	while (std::distance(ptr, last) > (cbuf *= 2)) {
		int lb = lblock;
		bool chavebuf = havebuf;
		if (not havebuf) {
			if (nkeys > 4 && nkeys / 8 * nkeys >= cbuf) {
				lb = nkeys / 2;
				chavebuf = true;
			}
			else {
				int nk = 1;
				long long s = (long long)cbuf * findkeys / 2;
				while (nk < nkeys && s != 0) {
					nk *= 2;
					s /= 8;
				}
				lb = (2 * cbuf) / nk;
			}
		}

		combine_blocks(first, ptr, std::distance(ptr, last), cbuf, lb,
					   chavebuf, extbuf, chavebuf && lb <= LExtBuf,
					   compare);
	}
	insertion_sort(first, ptr, compare.base());
	merge_without_buffer(first, ptr, last, std::move(compare));
}

//template<typename BufferProvider, typename RandomAccessIterator,
//	typename Compare>
//	auto grailsort(RandomAccessIterator first, RandomAccessIterator last,
//					Compare compare)
//	-> void {
//	
//	using rvalue_reference = remove_cvref_t<rvalue_reference_t<RandomAccessIterator>>;
//
//	// Allocate temporary buffer
//	auto size = std::distance(first, last);
//	typename BufferProvider::template buffer<rvalue_reference> buffer(size);
//
//	using compare_t = std::remove_reference_t<decltype(utility::as_function(compare))>;
//	common_sort(std::move(first), std::move(last), buffer.begin(), buffer.size(),
//				three_way_compare<compare_t>(utility::as_function(compare)));
//}


struct as_function_fn {
	template<typename T>
	constexpr auto operator()(T && t) const
		noexcept(std::is_nothrow_constructible<T, T>::value) {
		return std::forward<T>(t);
	}
};

template<typename T>
struct static_const {
	static constexpr T value{};
};

template<typename T>
constexpr T static_const<T>::value;

constexpr auto&& as_function = static_const<as_function_fn>::value;


template<class T, class C>
inline void grailsort_nobuffer(T _First, T _Last, C compare) {
	std::vector<T::value_type> buffer(0);

	using compare_t = std::remove_reference_t<decltype(as_function(compare))>;

	common_sort(_First, _Last, buffer.begin(), buffer.size(), three_way_compare<compare_t>(as_function(compare)));
}

template<class T, class C>
inline void grailsort_fixedbuffer(T _First, T _Last, C compare) {
	std::vector<T::value_type> buffer(512);

	using compare_t = std::remove_reference_t<decltype(as_function(compare))>;

	common_sort(_First, _Last, buffer.begin(), buffer.size(), three_way_compare<compare_t>(as_function(compare)));
}

template<class T, class C>
inline void grailsort_fullbuffer(T _First, T _Last, C compare) {
	std::vector<T::value_type> buffer(std::distance(_First, _Last));

	using compare_t = std::remove_reference_t<decltype(as_function(compare))>;

	common_sort(_First, _Last, buffer.begin(), buffer.size(), three_way_compare<compare_t>(as_function(compare)));
}

template<class T>
inline void grailsort(T _First, T _Last) {
	grailsort_nobuffer(_First, _Last, std::less<>());
}





















~-----------------------------------------------~
C:\Users\Josh\Documents\Visual Studio 2017\Projects\Sorting\Sorting\gravitysort.h
~-----------------------------------------------~
#pragma once

template<class T, class C>
inline void gravitysort(T _First, T _Last, C compare) {		
	std::vector<unsigned> falling(_First, _Last);

	unsigned landed = 0;
	while (landed < falling.size()) {
		for (unsigned i = landed; i < falling.size(); ++i) {
			if (compare(falling[i], 1)) {
				iter_swap(_First + landed, _First + i);
				std::swap(falling[i], falling[landed]);
				++landed;
			}
			else
				--falling[i];
		}
	}
}

template<class T>
inline void gravitysort(T _First, T _Last) {
	gravitysort(_First, _Last, std::less<>());
}






















~-----------------------------------------------~
C:\Users\Josh\Documents\Visual Studio 2017\Projects\Sorting\Sorting\heapsort.h
~-----------------------------------------------~
#pragma once

template<class T, class C>
inline void heapsort(T _First, T _Last, C compare) {
	//	using std::iter_swap;
	T _PFirst = _First + 1;
	T _Pos(_PFirst);
	T _Parent(_Pos);
	while (_PFirst < _Last) {
		while ((_Parent = _First + ((std::distance(_First, _PFirst - 1)) >> 1)) >= _First && compare(*_Parent, *_PFirst)) {
			iter_swap(_Parent, _PFirst);
			if (_Parent == _First)
				break;
			_PFirst = _Parent;
		}
		_PFirst = ++_Pos;
	}
	static int c = 0;
	while (--_Pos > _First) {
		iter_swap(_Pos, _First);
		_PFirst = _First;
		for (;;) {
			auto _ChildOff = std::distance(_First, _PFirst) << 1;
			if (++_ChildOff >= std::distance(_First, _Pos)) break;

			T _Left = _First + _ChildOff;

			T _Big = _Left;
			if (((_First + ++_ChildOff) < _Pos)) {
				T _Right = _First + _ChildOff;
				if (compare(*_Left, *_Right))
					_Big = _Right;
			}

			if (!compare(*_PFirst, *_Big)) break;

			iter_swap(_PFirst, _Big);
			_PFirst = _Big;
		}
	}
}

template<class T>
inline void heapsort(T _First, T _Last) {
	heapsort(_First, _Last, std::less<>());
}

template<class T, class C>
inline void minheapsort(T _First, T _Last, C compare) {
	//	using std::iter_swap;
	//heapify
	T _PFirst = _First + 1;
	T _Pos(_PFirst);
	T _Parent(_Pos);
	while (_PFirst < _Last) {
		while ((_Parent = _First + ((std::distance(_First, _PFirst - 1)) >> 1)) >= _First && compare(*_PFirst, *_Parent)) {
			iter_swap(_Parent, _PFirst);
			if (_Parent == _First)
				break;
			_PFirst = _Parent;
		}
		_PFirst = ++_Pos;
	}
	
	//deheapify
	while (--_Pos > _First) {
		iter_swap(_Pos, _First);
		_PFirst = _First;
		for (;;) {
			auto _ChildOff = std::distance(_First, _PFirst) << 1;
			if (++_ChildOff >= std::distance(_First, _Pos)) break;

			T _Left = _First + _ChildOff;

			T _Small = _Left;
			if (((_First + ++_ChildOff) < _Pos)) {
				T _Right = _First + _ChildOff;
				if (compare(*_Right, *_Left))
					_Small = _Right;
			}

			if (!compare(*_Small, *_PFirst)) break;

			iter_swap(_PFirst, _Small);
			_PFirst = _Small;
		}
	}
	std::reverse(_First, _Last);
}

template<class T>
inline void minheapsort(T _First, T _Last) {
	minheapsort(_First, _Last, std::less<>());
}

template<class T, class C>
inline void stdheapsort(T _First, T _Last, C compare) {
	std::make_heap(_First, _Last, compare);
	std::sort_heap(_First, _Last, compare);
}

template<class T>
inline void stdheapsort(T _First, T _Last) {
	std::make_heap(_First, _Last, std::less<>());
	std::sort_heap(_First, _Last, std::less<>());
}


























~-----------------------------------------------~
C:\Users\Josh\Documents\Visual Studio 2017\Projects\Sorting\Sorting\initializer.h
~-----------------------------------------------~
#pragma once

#include <random>
#include <ctime>
#include <numeric>

enum InitTypeValue {
	Regular,
	FewUnique,
	VeryFewUnique,
	NoUnique,
	Random,
	Normal
};

enum InitTypeOrder {
	Shuffled,
	FrayedAscending,
	FrayedDescending,
	SawtoothAscending,
	SawtoothDescending,
	VeryNearSorted,
	Reversed,
	Sorted,
	PipeOrgan,
	FrayedFront,
	FrayedMiddle,
	FrayedEnd,
	RandomFront,
	RandomMiddle,
	RandomEnd,
	Alternating,
	WorstCaseQuickSortMedianOf3,
};

class Initializer {
public:
	template<class Vector>
	static void Init(Vector* vec, size_t size, InitTypeValue itv, InitTypeOrder ito) {
		InitValues(vec, size, itv);
		InitOrder(vec, size, ito);
	}

	template<class Vector>
	static void InitValues(Vector* vec, size_t size, InitTypeValue itv) {
		Vector& v = *vec;
		switch (itv) {
			case InitTypeValue::Regular: {
				for (unsigned i = 1; i <= size; i++)
					v.push_back(i);//must use push_back
				break;
			}
			case InitTypeValue::FewUnique: {//FewUnique
				int steps = 5;
				int f = size / steps;
				for (unsigned i = 0; i < size; i++)
					v.push_back(((i / f) + 1) * f);//must use push_back
				break;
			}
			case InitTypeValue::VeryFewUnique: {//VeryFewUnique
				for (unsigned i = 0; i < size; i++) {
					int num_few = (int)((double)size * .025);
					if ((double)i / (double)size < (double)num_few / (double)size) v.push_back(size / 3);
					else if ((double)i / (double)size > (double)(size - num_few) / (double)size) v.push_back(size - 1);
					else v.push_back(2 * size / 3);//must use push_back
				}
				break;
			}
			case InitTypeValue::NoUnique: {
				unsigned val = size / 2;
				for (unsigned i = 0; i < size; i++)
					v.push_back(val);
				break;
			}
			case InitTypeValue::Random: {
				std::vector<typename Vector::value_type> temp;
				std::random_device rd;
				std::mt19937 gen(rd());
				std::uniform_int_distribution<size_t> dis(1, size);
				for (unsigned i = 1; i <= size; i++)
					temp.push_back(dis(gen));//must use push_back
				std::sort(temp.begin(), temp.end());
				v = temp;
				break;
			}
			case InitTypeValue::Normal: {
				std::vector<typename Vector::value_type> temp;
				std::random_device rd;
				std::mt19937 gen(rd());
				std::normal_distribution<double> dis((double)size / 2.0, (double)size / 10.0);
				for (unsigned i = 1; i <= size; i++)
					temp.push_back((unsigned)dis(gen) % size);//must use push_back
				std::sort(temp.begin(), temp.end());
				v = temp;
				break;
			}
			default: {
				throw(std::exception("Unhandled init value case"));
			}
		}
	}


	template<class Vector>
	static void InitOrder(Vector* vec, size_t size, InitTypeOrder ito) {
		Vector& v = *vec;
		//scramble elements (random is assumed)
		switch (ito) {
			case InitTypeOrder::Sorted: {
				//do nothing
				break;
			}
			case InitTypeOrder::FrayedAscending:
			case InitTypeOrder::FrayedDescending: {
				srand(clock());
				int dist = std::max((int)((double)size * .025), 2),
					end = size - dist;

				if (ito == InitTypeOrder::FrayedAscending) {
					for (int i = 0; i < end; i++)
						std::swap(v[(rand() % dist + i) % size], v[(rand() % dist + i) % size]);
				}
				else if (ito == InitTypeOrder::FrayedDescending) {
					{
					//	ScopedVar<DrawOption> scoped_draw_options(options.draw_options, DrawOption::None);
						for (int i = 0; i < end; i++)
							std::swap(v[(rand() % dist + i) % size], v[(rand() % dist + i) % size]);
					}
					std::reverse(v.begin(), v.end());
				}
				break;
			}
			case InitTypeOrder::SawtoothAscending:
			case InitTypeOrder::SawtoothDescending: {
				int num_teeth = 10;
				double elems_per_tooth = (double)size / (double)num_teeth;

				if (ito == SawtoothAscending) {
					for (int i = 0; i < num_teeth; i++) {
						std::reverse(v.begin() + (i * elems_per_tooth), v.begin() + ((i + 1) * elems_per_tooth));
					}
				}
				else if (ito == SawtoothDescending) {
					for (int i = 0; i < num_teeth / 2; i++) {
						std::swap_ranges(v.begin() + (i * elems_per_tooth), v.begin() + ((i + 1) * elems_per_tooth), v.begin() + ((num_teeth - i - 1) * elems_per_tooth));
					}
				}

				break;
			}
			case InitTypeOrder::VeryNearSorted: {
				double percent_out_of_order = 10.0;
				unsigned num_out_of_order = (unsigned)((double)v.size() / percent_out_of_order);
				std::random_device rd;
				std::mt19937 gen(rd());
				std::uniform_int_distribution<size_t> dis(1, size);
				for (unsigned i = 0; i < num_out_of_order; ++i)
					std::swap(v[dis(gen) % v.size()], v[dis(gen) % v.size()]);

				break;
			}
			case InitTypeOrder::Reversed: {
				std::reverse(v.begin(), v.end());
				break;
			}
			case InitTypeOrder::PipeOrgan: {
				unsigned int num_splits = 1;

				std::vector<unsigned> proxy(v.size());
				for (int s = 0; s < num_splits; s++) {
					for (unsigned i = 0; i < proxy.size(); ++i) proxy[i] = i + 1;
					for (unsigned i = 1; i < v.size(); ++i) {
						unsigned j = 0;
						while (j != i) {
							unsigned half = proxy[i] / 2;
							j = proxy[i] % 2 == 0 ? proxy.size() - half : half;
							if (j != i) {
								std::swap(proxy[i], proxy[j]);
								std::swap(v[i], v[j]);
							}
						}
					}
				}

				break;
			}
			case InitTypeOrder::FrayedFront:
			case InitTypeOrder::FrayedMiddle:
			case InitTypeOrder::FrayedEnd: {
				double percent = .20;
				size_t num = (unsigned)((double)size * percent);

				std::random_device rd;
				std::mt19937 gen(rd());

				if (ito == InitTypeOrder::FrayedFront) {
					std::shuffle(v.begin(), v.begin() + num, gen);
					//this loop is for drawing the rest of the list (it has no other purpose)
					for (auto i = v.begin() + num; i != v.end(); ++i)
						iter_swap(i, i);
				}
				if (ito == InitTypeOrder::FrayedMiddle) {
					auto mid = v.begin() + ((v.end() - v.begin()) >> 1);
					auto hnum = num / 2;
					auto l = mid - hnum;
					auto r = mid + hnum;

					//this loop is for drawing the rest of the list (it has no other purpose)
					for (auto i = v.begin(); i != l; ++i)
						iter_swap(i, i);
					std::shuffle(l, r, gen);
					//this loop is for drawing the rest of the list (it has no other purpose)
					for (auto i = r; i != v.end(); ++i)
						iter_swap(i, i);
					
				}
				else if (ito == InitTypeOrder::FrayedEnd) {
					//this loop is for drawing the rest of the list (it has no other purpose)
					for (auto i = v.begin(); i != v.end() - num; ++i)
						iter_swap(i, i);
					std::shuffle(v.end() - num, v.end(), gen);
				}
				break;
			}
			case InitTypeOrder::RandomFront:
			case InitTypeOrder::RandomMiddle:
			case InitTypeOrder::RandomEnd: {
				double percent_unsorted = .20;
				size_t num_sorted = (size_t)((double)size * (1.0 - percent_unsorted));

				std::random_device rd;
				std::mt19937 gen(rd());

				std::vector<size_t> rand_indices(size);	for (size_t i = 0; i < size; ++i) rand_indices[i] = i; 
				std::shuffle(rand_indices.begin(), rand_indices.end(), gen);
				rand_indices.resize(num_sorted);

				if (ito == InitTypeOrder::RandomFront) {
					std::sort(rand_indices.begin(), rand_indices.end(), std::greater<>());

					for (int i = 0; i < num_sorted; i++) 
						std::swap(v[size - i - 1], v[rand_indices[i]]);

					std::shuffle(v.begin(), v.begin() + size - num_sorted, gen);
				}
				else if (ito == InitTypeOrder::RandomEnd) {
					std::sort(rand_indices.begin(), rand_indices.end(), std::less<>());

					for (int i = 0; i < num_sorted; i++) 
						std::swap(v[i], v[rand_indices[i]]);

					std::shuffle(v.begin() + num_sorted, v.begin() + size, gen);
				}
				else if (ito == InitTypeOrder::RandomMiddle) {
					std::sort(rand_indices.begin(), rand_indices.end(), std::less<>());
					size_t hnum_sorted = num_sorted / 2;
					std::reverse(rand_indices.begin() + hnum_sorted, rand_indices.end());

					for (int i = 0; i < hnum_sorted; i++) {
						std::swap(v[i], v[rand_indices[i]]);
						std::swap(v[size - i - 1], v[rand_indices[i + hnum_sorted]]);
					}

					auto mid = v.begin() + ((v.end() - v.begin()) >> 1);
					std::shuffle(v.begin() + hnum_sorted, v.end() - hnum_sorted, gen);
				}

				break;
			}
			case InitTypeOrder::Shuffled: {
				std::random_device rd;
				std::mt19937 gen(rd());

				std::shuffle(v.begin(), v.end(), gen);
				break;
			}
			case InitTypeOrder::Alternating: {
				std::vector<bool> visited(size, false);
				visited[0] = true;

				//cyclically place values in alternating order
				unsigned num_inplace, i, to_i, last_unvisited; num_inplace = i = to_i = last_unvisited = 1;
				unsigned mid = size / 2;
				unsigned sizex2 = size * 2;
				auto val_to_move = v[i];
				while (num_inplace < size) {
					unsigned ix2 = i * 2;
					to_i = i < mid ? ix2 : sizex2 - ix2 - 1;
					if (visited[to_i]) {
						for (unsigned visit = last_unvisited; visit < visited.size(); ++visit) {
							if (!visited[visit]) {
								i = last_unvisited = visit;
								val_to_move = v[i];
								break;
							} 
						}
						continue;
					}
					auto next_val = v[to_i];
					v[to_i] = val_to_move;
					val_to_move = next_val;
					visited[to_i] = true;
					++num_inplace;
					i = to_i;
				}

				break;
			}
			case WorstCaseQuickSortMedianOf3: {
				auto p = v;
				std::iota(p.begin(), p.end(), 0);
				auto i = 0u;
				for (; i < v.size(); i += 2) {
					auto const iPivot0 = i;
					auto const iPivot1 = (i + v.size() - 1) / 2;
					v[p[iPivot1]] = i + 1;
					v[p[iPivot0]] = i;
					std::swap(p[iPivot1], p[i + 1]);
				}
				if (v.size() > 0 && i == v.size())
					v[v.size() - 1] = i - 1;

				break;
			}
			default: {
				throw(std::exception("Unhandled init order case"));
			}
		}
		//end scramble elements
	}


};











~-----------------------------------------------~
C:\Users\Josh\Documents\Visual Studio 2017\Projects\Sorting\Sorting\insertionsort.h
~-----------------------------------------------~
#pragma once

#include <list>

template<typename T, typename C>
inline void insertionsort(T _First, T _Last, C compare) {
	if (_First == _Last) return;
	for (T _Pos = std::next(_First); _Pos != _Last; ++_Pos) {
		T _Hole = _Pos;
		T _Prev = std::prev(_Pos);

		if (compare(*_Hole, *_Prev)) {
			typename T::value_type _Key = *_Pos;
			do {
				*_Hole = *_Prev;
			} while (--_Hole != _First && compare(_Key, *--_Prev));
			*_Hole = _Key;
		}
	}
}

template<class T>
inline void insertionsort(T _First, T _Last) {
	insertionsort(_First, _Last, std::less<>());
}

template<class T, class C>
inline void binaryinsertionsort(T _First, T _Last, C compare) {
	for (T _Pos = _First + 1; _Pos != _Last; ++_Pos) {
		T _Lo = _First, _Hi = _Pos;
		T _Mid = _First + ((_Pos - _First) >> 1);		
		
		do {
			//not stable and has more comparisons, but doesn't swap value in place
			/*if (compare(*_Pos, *_Mid))
				_Hi = _Mid;
			else if (compare(*_Mid, *_Pos))
				_Lo = _Mid + 1;
			else
				break;
			_Mid = _Lo + ((_Hi - _Lo) >> 1);*/

			//stable and less comparisons, but swaps value already in place
			if (compare(*_Pos, *_Mid))
				 _Hi = _Mid;
			else 
				_Lo = _Mid + 1;
			_Mid = _Lo + ((_Hi - _Lo) >> 1);

		} while (_Lo < _Hi);

		if (_Mid < _Pos) {
			typename T::value_type key = *_Pos;
			for (int _TPos = std::distance(_Mid, _Pos - 1); _TPos >= 0; --_TPos)
				*(_Mid + _TPos + 1) = *(_Mid + _TPos);
			*_Mid = key;
		}
	}
}

template<class T>
inline void binaryinsertionsort(T _First, T _Last) {
	binaryinsertionsort(_First, _Last, std::less<>());
}

template<class T, class C>
inline void shellsort(T _First, T _Last, C compare) {
	//ceil(.2 * (9 * pow(2.25, i - 1) - 4));//inverse = (ln((5x + 4) / 9) / ln(2.25)) + 1
	static std::list<int> gaps = { 1750, 701, 301, 132, 57, 23, 10, 4, 1 };

	int len = std::distance(_First, _Last);

	while (gaps.front() < len) gaps.push_front((int)((double)gaps.front() * 2.25));

	for (auto gap : gaps) {
		if (gap > len) continue;
		for (T _Pos = _First + gap; _Pos != _Last; ++_Pos) {
			for (T _Prev = _Pos; _Prev - _First >= gap && compare(*_Prev, *(_Prev - gap)); _Prev -= gap) {
				T _PrevPos = _Prev - gap;
				iter_swap(_Prev, _PrevPos);
			}
		}
	}
}

template<class T>
inline void shellsort(T _First, T _Last) {
	shellsort(_First, _Last, std::less<>());
}

template<class T, class C>
inline void stdinsertionsort(T _First, T _Last, C compare) {
	std::_Insertion_sort_unchecked(_First, _Last, compare);
}

template<class T>
inline void stdinsertionsort(T _First, T _Last) {
	std::_Insertion_sort_unchecked(_First, _Last);
}


























~-----------------------------------------------~
C:\Users\Josh\Documents\Visual Studio 2017\Projects\Sorting\Sorting\introselect.h
~-----------------------------------------------~
/*
* The MIT License (MIT)
*
* Copyright (c) 2018 Morwenn
*
* Permission is hereby granted, free of charge, to any person obtaining a copy
* of this software and associated documentation files (the "Software"), to deal
* in the Software without restriction, including without limitation the rights
* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
* copies of the Software, and to permit persons to whom the Software is
* furnished to do so, subject to the following conditions:
*
* The above copyright notice and this permission notice shall be included in
* all copies or substantial portions of the Software.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
* THE SOFTWARE.
*/
#ifndef CPPSORT_DETAIL_INTROSELECT_H_
#define CPPSORT_DETAIL_INTROSELECT_H_

////////////////////////////////////////////////////////////
// Headers
////////////////////////////////////////////////////////////
#include <iterator>
#include <utility>

namespace {

namespace detail {
namespace isd {
template<typename Iterator, typename Compare>
auto iter_sort3(Iterator a, Iterator b, Iterator c,
				Compare compare)
	-> Iterator {
	iter_swap_if(b, c, compare);
	iter_swap_if(a, c, compare);
	iter_swap_if(a, b, std::move(compare));
	return b; // Return median of 3
}
}

template<typename Predicate, typename ForwardIterator>
auto partition_impl(ForwardIterator first, ForwardIterator last, Predicate pred,
					std::forward_iterator_tag)
	-> ForwardIterator {
	while (true) {
		if (first == last)
			return first;
		if (!pred(*first))
			break;
		++first;
	}
	for (ForwardIterator p = first; ++p != last;) {
		if (pred(*p)) {
			iter_swap(first, p);
			++first;
		}
	}
	return first;
}

template<typename Predicate, typename BidirectionalIterator>
auto partition_impl(BidirectionalIterator first, BidirectionalIterator last, Predicate pred,
					std::bidirectional_iterator_tag)
	-> BidirectionalIterator {
	while (true) {
		while (true) {
			if (first == last)
				return first;
			if (!pred(*first))
				break;
			++first;
		}
		do {
			if (first == --last)
				return first;
		} while (!pred(*last));
		iter_swap(first, last);
		++first;
	}
}

template<typename ForwardIterator, typename Predicate>
auto partition(ForwardIterator first, ForwardIterator last, Predicate pred)
-> ForwardIterator {
	return partition_impl<std::add_lvalue_reference_t<Predicate>>(
		std::move(first), std::move(last), pred,
		typename std::iterator_traits<ForwardIterator>::iterator_category{}
	);
}
}

// Returns floor(log2(n)), assumes n > 0.
template<class T>
inline int fastlog2(T n) {
	int log = 0;
	while (n >>= 1) ++log;
	return log;
}

template<typename Iterator, typename Compare>
auto iter_swap_if(Iterator lhs, Iterator rhs, Compare compare) -> void {
	if (compare(*rhs, *lhs)) {
		iter_swap(lhs, rhs);
	}
}

template<typename BidirectionalIterator, typename Compare>
auto small_sort(BidirectionalIterator first, BidirectionalIterator last,
				typename std::iterator_traits<BidirectionalIterator>::difference_type,
				Compare compare)
	-> void {
	insertionsort(std::move(first), std::move(last),
				   std::move(compare));
}

template<typename ForwardIterator, typename Compare>
auto iter_median_5(ForwardIterator it1, ForwardIterator it2, ForwardIterator it3,
				   ForwardIterator it4, ForwardIterator it5,
				   Compare compare)
	-> ForwardIterator {
	// Median of 5, adapted from https://stackoverflow.com/a/481398/

	iter_swap_if(it1, it2, compare);
	iter_swap_if(it3, it4, compare);

	if (compare(*it1, *it3)) {
		iter_swap(it1, it5);
		iter_swap_if(it1, it2, compare);
	}
	else {
		iter_swap(it3, it5);
		iter_swap_if(it3, it4, compare);
	}

	if (compare(*it1, *it3)) {
		if (compare(*it2, *it3)) {
			return it3;
		}
		return it2;
	}
	else {
		if (compare(*it4, *it1)) {
			return it1;
		}
		return it4;
	}
}

template<typename ForwardIterator, typename Compare>
auto iter_median_rest(ForwardIterator first, typename std::iterator_traits<ForwardIterator>::difference_type size,
					  Compare compare)
	-> ForwardIterator {

	switch (size) {
		case 0:
		case 1:
		case 2:
			return first;
		case 3: {
			auto it1 = first;
			auto it2 = ++first;
			auto it3 = ++first;
			iter_swap_if(it1, it2, compare);
			iter_swap_if(it2, it3, compare);
			iter_swap_if(it1, it2, compare);
			return it2;
		}
		case 4: {
			auto it1 = first;
			auto it2 = ++first;
			auto it3 = ++first;
			auto it4 = ++first;
			iter_swap_if(it1, it2, compare);
			iter_swap_if(it3, it4, compare);
			iter_swap_if(it1, it3, compare);
			iter_swap_if(it2, it4, compare);
			iter_swap_if(it2, it3, compare);
			return it2;
		}
		case 5: {
			auto it1 = first;
			auto it2 = ++first;
			auto it3 = ++first;
			auto it4 = ++first;
			auto it5 = ++first;
			return iter_median_5(it1, it2, it3, it4, it5,
								 std::move(compare));
		}
		default:
			throw std::exception("unreachable");
	}
}

template<typename ForwardIterator, typename Compare>
auto intro_select(ForwardIterator first, ForwardIterator last,
				 typename std::iterator_traits<ForwardIterator>::difference_type nth_pos,
				 typename std::iterator_traits<ForwardIterator>::difference_type size, int bad_allowed,
				 Compare compare)
	->ForwardIterator;

template<typename ForwardIterator, typename Compare>
auto median_of_medians(ForwardIterator first, ForwardIterator last,
					   typename std::iterator_traits<ForwardIterator>::difference_type size,
					   Compare compare)
	-> ForwardIterator {

	if (size <= 5) {
		return iter_median_rest(first, size, std::move(compare));
	}

	// Iterator over the collection
	auto it = first;
	// Points to the next value to replace by a median-of-5
	auto medians_it = first;

	// We handle first the biggest part that can be rounded to a power
	// of 5, then we handle the rest
	auto rounded_size = (size / 5) * 5;

	// Handle elements 5 by 5

	for (typename std::iterator_traits<ForwardIterator>::difference_type i = 0; i < rounded_size / 5; ++i) {
		auto it1 = it;
		auto it2 = ++it;
		auto it3 = ++it;
		auto it4 = ++it;
		auto it5 = ++it;

		auto median = iter_median_5(it1, it2, it3, it4, it5, compare);
		iter_swap(medians_it, median);
		++medians_it;
		++it;
	}

	// Handle remaining elements
	if (rounded_size != size) {
		auto last_median = iter_median_rest(it, size - rounded_size, compare);
		iter_swap(last_median, medians_it);
		++medians_it;
	}

	// Rest variables for the next iteration
	last = medians_it;
	size = rounded_size == size ? size / 5 : size / 5 + 1;

	// Mutual recursion with intro_select
	return intro_select(first, last, size / 2, size, ::fastlog2(size),
					   std::move(compare));
}

////////////////////////////////////////////////////////////
// Get iterator to last element

template<typename Iterator>
auto last_it(Iterator first, Iterator, typename std::iterator_traits<Iterator>::difference_type size,
			 std::forward_iterator_tag)
	-> Iterator {
	return std::next(first, size - 1);
}

template<typename Iterator>
auto last_it(Iterator, Iterator last, typename std::iterator_traits<Iterator>::difference_type,
			 std::bidirectional_iterator_tag)
	-> Iterator {
	return std::prev(last);
}

template<typename Iterator>
auto last_it(Iterator first, Iterator last, typename std::iterator_traits<Iterator>::difference_type size)
-> Iterator {
	using category = typename std::iterator_traits<Iterator>::iterator_category;
	return last_it(first, last, size, category{});
}

////////////////////////////////////////////////////////////
// Pick a pivot for quicksort and quickselect

template<typename ForwardIterator, typename Compare>
auto pick_pivot(ForwardIterator first, ForwardIterator last,
				typename std::iterator_traits<ForwardIterator>::difference_type size, int bad_allowed,
				Compare compare)
	-> std::pair<ForwardIterator, ForwardIterator> {
	if (bad_allowed > 0) {
		auto it1 = std::next(first, size / 8);
		auto it2 = std::next(it1, size / 8);
		auto it3 = std::next(it2, size / 8);
		auto middle = std::next(it3, size / 2 - 3 * (size / 8));
		auto it4 = std::next(middle, size / 8);
		auto it5 = std::next(it4, size / 8);
		auto it6 = std::next(it5, size / 8);
		auto last_1 = last_it(it6, last, size - size / 2 - 3 * (size / 8));

		detail::isd::iter_sort3(first, it1, it2, compare);
		detail::isd::iter_sort3(it3, middle, it4, compare);
		detail::isd::iter_sort3(it5, it6, last_1, compare);
		auto median_it = detail::isd::iter_sort3(it1, middle, it4, std::move(compare));
		return std::make_pair(median_it, last_1);
	}
	else {
		auto last_1 = last_it(first, last, size);
		auto median_it = median_of_medians(first, last, size, compare);
		return std::make_pair(median_it, last_1);
	}
}

////////////////////////////////////////////////////////////
// Forward nth_element based on intro_select

template<typename ForwardIterator, typename Compare>
auto intro_select(ForwardIterator first, ForwardIterator last,
				 typename std::iterator_traits<ForwardIterator>::difference_type nth_pos,
				 typename std::iterator_traits<ForwardIterator>::difference_type size, int bad_allowed,
				 Compare compare)
	-> ForwardIterator {

	if (size <= 32) {
		small_sort(first, last, size, std::move(compare));
		return std::next(first, nth_pos);
	}

	// Choose pivot as either median of 9 or median of medians
	auto temp = pick_pivot(first, last, size, bad_allowed, compare);
	auto median_it = temp.first;
	auto last_1 = temp.second;

	// Put the pivot at position std::prev(last) and partition
	iter_swap(median_it, last_1);
	auto middle1 = detail::partition(
		first, last_1,
		[&](const auto& elem) { return compare(elem, *last_1); }
	);

	// Put the pivot in its final position and partition
	iter_swap(middle1, last_1);
	
	auto middle2 = detail::partition(
		std::next(middle1), last,
		[&](const auto& elem) { return not compare(*middle1, elem); }
	);

	// Recursive call: heuristic trick here: in real world cases,
	// the middle partition is more likely to be smaller than the
	// right one, so computing its size should generally be cheaper
	auto size_left = std::distance(first, middle1);
	auto size_middle = std::distance(middle1, middle2);
	auto size_right = size - size_left - size_middle;

	// TODO: unroll tail recursion
	// We're done if the nth element is in the middle partition
	if (nth_pos < size_left) {
		return intro_select(first, middle1, nth_pos,
						   size_left, --bad_allowed,
						   std::move(compare));
	}
	else if (nth_pos > size_left + size_middle) {
		return intro_select(middle2, last, nth_pos - size_left - size_middle,
						   size_right, --bad_allowed,
						   std::move(compare));
	}
	// Return an iterator to the nth element
	return std::next(middle1, nth_pos - size_left);
}
}

#endif // CPPSORT_DETAIL_INTROSELECT_H_




~-----------------------------------------------~
C:\Users\Josh\Documents\Visual Studio 2017\Projects\Sorting\Sorting\melsort.h
~-----------------------------------------------~
#pragma once

#include <algorithm>
#include <functional>
#include <iterator>
#include <list>
#include <utility>
#include <vector>

template<
	typename InputIterator1,
	typename InputIterator2,
	typename OutputIterator,
	typename Compare = std::less<>
>
auto merge_move(InputIterator1 first1, InputIterator1 last1,
				InputIterator2 first2, InputIterator2 last2,
				OutputIterator result, Compare compare = {})
	-> OutputIterator {
	for (; first1 != last1; ++result) {
		if (first2 == last2) {
			return std::move(first1, last1, result);
		}

		if (compare(*first2, *first1)) {
			*result = std::move(*first2);
			++first2;
		}
		else {
			*result = std::move(*first1);
			++first1;
		}
	}
	return std::move(first2, last2, result);
}

template<
	typename ForwardIterator,
	typename Compare = std::less<>
>
auto melsort(ForwardIterator first, ForwardIterator last, Compare compare = {})
-> void {
	using value_type = typename std::iterator_traits<ForwardIterator>::value_type;
	std::vector<std::list<value_type>> lists;

	////////////////////////////////////////////////////////////
	// Create encroaching lists

	for (auto it = first; it != last; ++it) {
		bool found = false;
		for (auto& list : lists) {
			if (not compare(list.front(), *it)) {
				list.emplace_front(std::move(*it));
				found = true;
				break;
			}
			if (not compare(*it, list.back())) {
				list.emplace_back(std::move(*it));
				found = true;
				break;
			}
		}

		if (not found) {
			lists.emplace_back();
			lists.back().emplace_back(std::move(*it));
		}
	}

	////////////////////////////////////////////////////////////
	// Merge encroaching lists

	while (lists.size() > 2) {
		if (lists.size() % 2 != 0) {
			auto last_it = std::prev(std::end(lists));
			auto last_1_it = std::prev(last_it);
			last_1_it->merge(*last_it, compare);
			lists.pop_back();
		}

		auto first_it = std::begin(lists);
		auto half_it = first_it + lists.size() / 2;
		while (half_it != std::end(lists)) {
			first_it->merge(*half_it, compare);
			++first_it;
			++half_it;
		}

		lists.erase(std::begin(lists) + lists.size() / 2, std::end(lists));
	}

	// Merge lists back into the original collection

	if (lists.size() == 2) {
		merge_move(
			std::begin(lists.front()), std::end(lists.front()),
			std::begin(lists.back()), std::end(lists.back()),
			first, compare
		);
	}
	else if (lists.size() == 1) {
		std::move(std::begin(lists.front()), std::end(lists.front()), first);
	}
}




~-----------------------------------------------~
C:\Users\Josh\Documents\Visual Studio 2017\Projects\Sorting\Sorting\mergeinsertionsort.h
~-----------------------------------------------~
///*
//* The MIT License (MIT)
//*
//* Copyright (c) 2016-2019 Morwenn
//*
//* Permission is hereby granted, free of charge, to any person obtaining a copy
//* of this software and associated documentation files (the "Software"), to deal
//* in the Software without restriction, including without limitation the rights
//* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
//* copies of the Software, and to permit persons to whom the Software is
//* furnished to do so, subject to the following conditions:
//*
//* The above copyright notice and this permission notice shall be included in
//* all copies or substantial portions of the Software.
//*
//* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
//* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
//* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
//* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
//* THE SOFTWARE.
//*/
//#ifndef CPPSORT_DETAIL_MERGE_INSERTION_SORT_H_
//#define CPPSORT_DETAIL_MERGE_INSERTION_SORT_H_
//
//////////////////////////////////////////////////////////////
//// Headers
//////////////////////////////////////////////////////////////
//#include <algorithm>
//#include <cstdint>
//#include <iterator>
//#include <list>
//#include <new>
//#include <type_traits>
//#include <utility>
//#include <vector>
//#include "cpp-sort/utility/as_function.h"
//#include "cpp-sort/utility/iter_move.h"
//#include "cpp-sort/detail/config.h"
//#include "cpp-sort/detail/iterator_traits.h"
//#include "cpp-sort/detail/memory.h"
//#include "cpp-sort/detail/move.h"
//#include "cpp-sort/detail/swap_if.h"
//#include "cpp-sort/detail/swap_ranges.h"
//#include "cpp-sort/detail/type_traits.h"
//
//
//namespace {
//////////////////////////////////////////////////////////////
//// Iterator used to sort groups
//
//template<typename Iterator>
//class group_iterator {
//public:
//
//	////////////////////////////////////////////////////////////
//	// Public types
//	using iterator_category = typename std::iterator_traits<Iterator>::iterator_category;
//	using iterator_type = Iterator;
//	using value_type = typename std::iterator_traits<Iterator>::value_type;
//	using difference_type = typename std::iterator_traits<Iterator>::difference_type;
//	using pointer = typename std::iterator_traits<Iterator>::pointer;
//	using reference = typename std::iterator_traits<Iterator>::reference;
//
//	////////////////////////////////////////////////////////////
//	// Constructors
//
//	group_iterator() = default;
//
//	group_iterator(Iterator it, difference_type size) :
//		_it(std::move(it)),
//		_size(size) {}
//
//	////////////////////////////////////////////////////////////
//	// Members access
//
//	auto base() const
//		-> iterator_type {
//		return _it;
//	}
//
//	auto size() const
//		-> difference_type {
//		return _size;
//	}
//
//	////////////////////////////////////////////////////////////
//	// Element access
//
//	auto operator*() const
//		-> reference {
//		return _it[_size - 1];
//	}
//
//	auto operator->() const
//		-> pointer {
//		return &(operator*());
//	}
//
//	////////////////////////////////////////////////////////////
//	// Increment/decrement operators
//
//	auto operator++()
//		-> group_iterator& {
//		std::advance(_it, _size);
//		return *this;
//	}
//
//	auto operator++(int)
//		-> group_iterator {
//		auto tmp = *this;
//		operator++();
//		return tmp;
//	}
//
//	auto operator--()
//		-> group_iterator& {
//		_it -= _size;
//		return *this;
//	}
//
//	auto operator--(int)
//		-> group_iterator {
//		auto tmp = *this;
//		operator--();
//		return tmp;
//	}
//
//	auto operator+=(difference_type increment)
//		-> group_iterator& {
//		std::advance(_it, _size * increment);
//		return *this;
//	}
//
//	auto operator-=(difference_type increment)
//		-> group_iterator& {
//		_it -= _size * increment;
//		return *this;
//	}
//
//	////////////////////////////////////////////////////////////
//	// Elements access operators
//
//	auto operator[](difference_type pos)
//		-> decltype(base()[pos * size() + size() - 1]) {
//		return base()[pos * size() + size() - 1];
//	}
//
//	auto operator[](difference_type pos) const
//		-> decltype(base()[pos * size() + size() - 1]) {
//		return base()[pos * size() + size() - 1];
//	}
//
//	////////////////////////////////////////////////////////////
//	// Comparison operators
//
//	friend auto operator==(const group_iterator& lhs, const group_iterator& rhs)
//		-> bool {
//		return lhs.base() == rhs.base();
//	}
//
//	friend auto operator!=(const group_iterator& lhs, const group_iterator& rhs)
//		-> bool {
//		return lhs.base() != rhs.base();
//	}
//
//	////////////////////////////////////////////////////////////
//	// Relational operators
//
//	friend auto operator<(const group_iterator& lhs, const group_iterator& rhs)
//		-> bool {
//		return lhs.base() < rhs.base();
//	}
//
//	friend auto operator<=(const group_iterator& lhs, const group_iterator& rhs)
//		-> bool {
//		return lhs.base() <= rhs.base();
//	}
//
//	friend auto operator>(const group_iterator& lhs, const group_iterator& rhs)
//		-> bool {
//		return lhs.base() > rhs.base();
//	}
//
//	friend auto operator>=(const group_iterator& lhs, const group_iterator& rhs)
//		-> bool {
//		return lhs.base() >= rhs.base();
//	}
//
//	////////////////////////////////////////////////////////////
//	// Arithmetic operators
//
//	friend auto operator+(group_iterator it, difference_type size)
//		-> group_iterator {
//		return it += size;
//	}
//
//	friend auto operator+(difference_type size, group_iterator it)
//		-> group_iterator {
//		return it += size;
//	}
//
//	friend auto operator-(group_iterator it, difference_type size)
//		-> group_iterator {
//		return it -= size;
//	}
//
//	friend auto operator-(const group_iterator& lhs, const group_iterator& rhs)
//		-> difference_type {
//		return (lhs.base() - rhs.base()) / lhs.size();
//	}
//
//private:
//
//	Iterator _it;
//	difference_type _size;
//};
//
//template<typename Iterator>
//auto iter_swap(group_iterator<Iterator> lhs, group_iterator<Iterator> rhs)
//-> void {
//	std::swap_ranges(lhs.base(), lhs.base() + lhs.size(), rhs.base());
//}
//
//////////////////////////////////////////////////////////////
//// Construction function
//
//template<typename Iterator>
//auto make_group_iterator(Iterator it, typename std::iterator_traits<group_iterator<Iterator>>::difference_type size)
//-> group_iterator<Iterator> {
//	return {it, size};
//}
//
//template<typename Iterator>
//auto make_group_iterator(group_iterator<Iterator> it, typename std::iterator_traits<group_iterator<Iterator>>::difference_type size)
//-> group_iterator<Iterator> {
//	return {it.base(), size * it.size()};
//}
//
//////////////////////////////////////////////////////////////
//// Merge-insertion sort
//
//template<
//	typename RandomAccessIterator,
//	typename Compare
//>
//auto merge_insertion_sort_impl(group_iterator<RandomAccessIterator> first,
//							   group_iterator<RandomAccessIterator> last,
//							   Compare compare)
//	-> void {
//	// Cache all the differences between a Jacobsthal number and its
//	// predecessor that fit in 64 bits, starting with the difference
//	// between the Jacobsthal numbers 4 and 3 (the previous ones are
//	// unneeded)
//	constexpr std::uint_fast64_t jacobsthal_diff[] = {
//		2u, 2u, 6u, 10u, 22u, 42u, 86u, 170u, 342u, 682u, 1366u,
//		2730u, 5462u, 10922u, 21846u, 43690u, 87382u, 174762u, 349526u, 699050u,
//		1398102u, 2796202u, 5592406u, 11184810u, 22369622u, 44739242u, 89478486u,
//		178956970u, 357913942u, 715827882u, 1431655766u, 2863311530u, 5726623062u,
//		11453246122u, 22906492246u, 45812984490u, 91625968982u, 183251937962u,
//		366503875926u, 733007751850u, 1466015503702u, 2932031007402u, 5864062014806u,
//		11728124029610u, 23456248059222u, 46912496118442u, 93824992236886u, 187649984473770u,
//		375299968947542u, 750599937895082u, 1501199875790165u, 3002399751580331u,
//		6004799503160661u, 12009599006321322u, 24019198012642644u, 48038396025285288u,
//		96076792050570576u, 192153584101141152u, 384307168202282304u, 768614336404564608u,
//		1537228672809129216u, 3074457345618258432u, 6148914691236516864u
//	};
//
//	auto size = std::distance(first, last);
//	if (size < 2) return;
//
//	// Whether there is a stray element not in a pair
//	// at the end of the chain
//	bool has_stray = (size % 2 != 0);
//
//	////////////////////////////////////////////////////////////
//	// Group elements by pairs
//
//	auto end = has_stray ? std::prev(last) : last;
//	for (auto it = first; it != end; it += 2) {
//		iter_swap_if(it, it + 1, compare);
//	}
//
//	////////////////////////////////////////////////////////////
//	// Recursively sort the pairs by max
//
//	merge_insertion_sort_impl(
//		make_group_iterator(first, 2),
//		make_group_iterator(end, 2),
//		compare
//	);
//
//	////////////////////////////////////////////////////////////
//	// Separate main chain and pend elements
//
//	using list_t = std::list<group_iterator<RandomAccessIterator>>;
//
//	// The first pend element is always part of the main chain,
//	// so we can safely initialize the list with the first two
//	// elements of the sequence
//	list_t chain = {first, std::next(first)};
//
//	// Upper bounds for the insertion of pend elements
//	std::vector<typename list_t::iterator> pend;
//	pend.reserve((size + 1) / 2 - 1);
//
//	for (auto it = first + 2; it != end; it += 2) {
//		auto tmp = chain.insert(std::end(chain), std::next(it));
//		pend.push_back(tmp);
//	}
//
//	// Add the last element to pend if it exists; when it
//	// exists, it always has to be inserted in the full chain,
//	// so giving it chain.end() as end insertion point is ok
//	if (has_stray) {
//		pend.push_back(std::end(chain));
//	}
//
//	////////////////////////////////////////////////////////////
//	// Binary insertion into the main chain
//
//	auto current_it = first + 2;
//	auto current_pend = std::begin(pend);
//
//	for (int k = 0; ; ++k) {
//		// Should be safe: in this code, std::distance should always return
//		// a positive number, so there is of risk comparing funny values
//		using size_type = std::common_type_t<
//			std::uint_fast64_t,
//			typename list_t::difference_type
//		>;
//
//		// Find next index
//		auto dist = jacobsthal_diff[k];
//		if (dist > static_cast<size_type>(std::distance(current_pend, std::end(pend)))) break;
//
//		auto it = std::next(current_it, dist * 2);
//		auto pe = std::next(current_pend, dist);
//
//		do {
//			--pe;
//			it -= 2;
//
//			auto insertion_point = std::upper_bound(
//				std::begin(chain), *pe, *it,
//				[=](const auto& lhs, const auto& rhs) mutable {
//				return compare(lhs, *rhs);
//			}
//			);
//			chain.insert(insertion_point, it);
//		} while (pe != current_pend);
//
//		std::advance(current_it, dist * 2);
//		std::advance(current_pend, dist);
//	}
//
//	// If there are pend elements left, insert them into
//	// the main chain, the order of insertion does not
//	// matter so forward traversal is ok
//	while (current_pend != std::end(pend)) {
//		auto insertion_point = std::upper_bound(
//			std::begin(chain), *current_pend, *current_it,
//			[=](const auto& lhs, const auto& rhs) mutable {
//			return compare(lhs, *rhs);
//		}
//		);
//		chain.insert(insertion_point, current_it);
//		current_it += 2;
//		++current_pend;
//	}
//
//	////////////////////////////////////////////////////////////
//	// Move values in order to a cache then back to origin
//
//	// Number of sub-iterators
//	auto full_size = size * first.size();
//
//	using rvalue_reference = remove_cvref_t<rvalue_reference_t<RandomAccessIterator>>;
//	std::unique_ptr<rvalue_reference, operator_deleter> cache(
//		static_cast<rvalue_reference*>(::operator new(full_size * sizeof(rvalue_reference))),
//		operator_deleter(full_size * sizeof(rvalue_reference))
//	);
//	destruct_n<rvalue_reference> d(0);
//	std::unique_ptr<rvalue_reference, destruct_n<rvalue_reference>&> h2(cache.get(), d);
//
//	rvalue_reference* buff_it = cache.get();
//	for (auto&& it : chain) {
//		auto begin = it.base();
//		auto end = begin + it.size();
//		buff_it = uninitialized_move(begin, end, buff_it, d);
//	}
//	detail::move(cache.get(), cache.get() + full_size, first.base());
//}
//
//template<typename RandomAccessIterator, typename Compare>
//auto merge_insertion_sort(RandomAccessIterator first, RandomAccessIterator last, Compare compare) -> void {
//	merge_insertion_sort_impl(
//		make_group_iterator(std::move(first), 1),
//		make_group_iterator(std::move(last), 1),
//		std::move(compare));
//}
//
////template<typename RandomAccessIterator>
////auto merge_insertion_sort(RandomAccessIterator first, RandomAccessIterator last) -> void {
////	merge_insertion_sort_impl(
////		make_group_iterator(std::move(first), 1),
////		make_group_iterator(std::move(last), 1),
////		std::less<>()
////	);
////}
//}
//
//#endif // CPPSORT_DETAIL_MERGE_INSERTION_SORT_H_
//
//


~-----------------------------------------------~
C:\Users\Josh\Documents\Visual Studio 2017\Projects\Sorting\Sorting\mergesort.h
~-----------------------------------------------~
#pragma once

#include "insertionsort.h"

namespace merge_sort {
template<class T, class C>
inline void merge(T _First, T _Mid, T _Last, C compare) {
	std::vector<T::value_type> _LeftCpy(_First, _Mid);
	std::vector<T::value_type> _RightCpy(_Mid, _Last);

	auto _LeftCpyP = _LeftCpy.begin();
	auto _RightCpyP = _RightCpy.begin();

	while (_LeftCpyP != _LeftCpy.end() && _RightCpyP != _RightCpy.end())
		*_First++ = compare(*_RightCpyP, *_LeftCpyP) ? *_RightCpyP++ : *_LeftCpyP++;

	std::copy(_LeftCpyP, _LeftCpy.end(), _First);
	std::copy(_RightCpyP, _RightCpy.end(), _First);
}
}

template<class T, class C>
inline void mergesort(T _First, T _Last, C compare) {
	auto mid = std::distance(_First, _Last) >> 1;
	if (!mid) return;

	T _Mid = _First + mid;
	mergesort(_First, _Mid, compare);
	mergesort(_Mid, _Last, compare);
	merge_sort::merge(_First, _Mid, _Last, compare);
}

template<class T>
inline void mergesort(T _First, T _Last) {
	mergesort(_First, _Last, std::less<>());
}


template<class T, class V, class C>
inline void allocmerge(T _First, T _Mid, T _Last, V _DestFirst, V _DestMid, V _DestLast, C compare) {
	std::copy(_First, _Mid, _DestFirst);
	std::copy(_Mid, _Last, _DestMid);

	V _LeftCpyP = _DestFirst;
	V _RightCpyP = _DestMid;

	while (_LeftCpyP != _DestMid && _RightCpyP != _DestLast)
		*_First++ = compare(*_RightCpyP, *_LeftCpyP) ? *_RightCpyP++ : *_LeftCpyP++;

	std::copy(_LeftCpyP, _DestMid, _First);
	std::copy(_RightCpyP, _DestLast, _First);
}

template<class T, class V, class C>
inline void allocmerge2(T _First, T _Mid, T _Last, V _DestFirst, V _DestMid, V _DestLast, C compare) {
	T _Left = _First;
	T _Right = _Mid;

	while (_Left != _Mid && _Right != _Last)
		*_DestFirst++ = compare(*_Right, *_Left) ? *_Right++ : *_Left++;

	std::copy(_Left, _Mid, _DestFirst);
	std::copy(_Right, _Last, _DestFirst);

	std::copy(_DestFirst, _DestMid, _First);
	std::copy(_DestMid, _DestLast, _Mid);
}

template<class T, class V, class C>
inline void _allocmergesort(T _First, T _Last, V _DestFirst, V _DestLast, C compare) {
	auto mid = std::distance(_First, _Last) >> 1;
	if (!mid) return;

	T _Mid = _First + mid;
	V _DestMid = _DestFirst + mid;
	_allocmergesort(_First, _Mid, _DestFirst, _DestMid, compare);
	_allocmergesort(_Mid, _Last, _DestMid, _DestLast, compare);
	allocmerge(_First, _Mid, _Last, _DestFirst, _DestMid, _DestLast, compare);
}

template<class T, class C>
inline void allocmergesort(T _First, T _Last, C compare) {
	std::vector<T::value_type> _Dest(std::distance(_First, _Last));
	_allocmergesort(_First, _Last, _Dest.begin(), _Dest.end(), compare);
}

template<class T>
inline void allocmergesort(T _First, T _Last) {
	allocmergesort(_First, _Last, std::less<>());
}


template<class T, class C>
inline void weavemerge(T _First, T _Mid, T _Last, C compare) {
	std::vector<T::value_type> _LeftCpy(_First, _Mid);
	std::vector<T::value_type> _RightCpy(_Mid, _Last);

	auto _LeftCpyP = _LeftCpy.begin();
	auto _RightCpyP = _RightCpy.begin();

	bool _BWeave = compare(*_LeftCpyP, *_RightCpyP);

	while (_LeftCpyP != _LeftCpy.end() && _RightCpyP != _RightCpy.end()) {
		*_First++ = _BWeave ? *_LeftCpyP++ : *_RightCpyP++;
		_BWeave = !_BWeave;
	}

	std::copy(_LeftCpyP, _LeftCpy.end(), _First);
	std::copy(_RightCpyP, _RightCpy.end(), _First);
}

template<class T, class C>
inline void weavemergesort(T _First, T _Last, C compare) {
	auto mid = std::distance(_First, _Last) >> 1;
	if (!mid) return;

	T _Mid = _First + mid;
	weavemergesort(_First, _Mid, compare);
	weavemergesort(_Mid, _Last, compare);
	weavemerge(_First, _Mid, _Last, compare);
	insertionsort(_First, _Last, compare);
}

template<class T>
inline void weavemergesort(T _First, T _Last) {
	weavemergesort(_First, _Last, std::less<>());
}

























~-----------------------------------------------~
C:\Users\Josh\Documents\Visual Studio 2017\Projects\Sorting\Sorting\neatsort.h
~-----------------------------------------------~
/*
* The MIT License (MIT)
*
* Copyright (c) 2016 Morwenn
*
* Permission is hereby granted, free of charge, to any person obtaining a copy
* of this software and associated documentation files (the "Software"), to deal
* in the Software without restriction, including without limitation the rights
* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
* copies of the Software, and to permit persons to whom the Software is
* furnished to do so, subject to the following conditions:
*
* The above copyright notice and this permission notice shall be included in
* all copies or substantial portions of the Software.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
* THE SOFTWARE.
*/
#ifndef CPPSORT_DETAIL_NEATSORT_H_
#define CPPSORT_DETAIL_NEATSORT_H_

////////////////////////////////////////////////////////////
// Headers
////////////////////////////////////////////////////////////
#include <algorithm>
#include <iterator>
#include <list>

namespace {

template<class InputIterator1, class InputIterator2, class OutputIterator, class Compare>
	auto merge(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, InputIterator2 last2, OutputIterator result, Compare comp = {}) -> OutputIterator {
	for (; first1 != last1; ++result) {
		if (first2 == last2)
			return std::copy(first1, last1, result);
		if (comp(*first2, *first1)) {
			*result = *first2;
			++first2;
		}
		else {
			*result = *first1;
			++first1;
		}
	}
	return std::copy(first2, last2, result);
}

template<typename ForwardIterator, typename Compare>
auto inplace_merge(ForwardIterator first, ForwardIterator middle, ForwardIterator last, Compare compare) -> void {
	using value_type = typename std::iterator_traits<ForwardIterator>::value_type;

	// Shrink the problem size on the left side
	while (compare(*first, *middle)) {
		++first;
	}

	// Try to allocate a temporary buffer and make sure
	// it will always be properly deleted
	auto size = std::distance(first, last);
	std::unique_ptr<value_type[]> buffer(new (std::nothrow) value_type[size]);

	// If there is enough memory, use the buffer for the merge
	if (buffer != nullptr) {
		::merge(first, middle, middle, last, buffer.get(), compare);
		std::move(buffer.get(), buffer.get() + size, first);
	}
	else // Hand-made in-place merge algorithm
	{
		ForwardIterator insertion_point = middle;
		for (; first != middle; ++first) {
			if (compare(*middle, *first)) {
				// *first should be in the right partition
				value_type tmp = std::move(*first);

				// Put *right in place
				*first = std::move(*middle);

				// Look for the place where to insert tmp
				ForwardIterator next = std::next(insertion_point);

				// Move everything smaller than tmp to the left
				std::move(std::next(middle), next, middle);
				while (next != last && compare(*next, tmp)) {
					*insertion_point++ = std::move(*next++);
				}

				// Insert tmp in the right place
				*insertion_point = std::move(tmp);
			}
		}
	}
}

template<typename RandomAccessIterator, typename Compare>
auto neatsort(RandomAccessIterator first, RandomAccessIterator last, Compare compare) -> void {
	// Some heuristic constant, see the original paper
	static constexpr double p = 1.3;

	if (std::distance(first, last) < 2) return;

	// Vector to store the beginning of each run
	std::list<RandomAccessIterator> runs = {first};

	auto current = first;
	auto next = std::next(first);

	////////////////////////////////////////////////////////////
	// Create runs

	while (true) {
		// Look for ascending run
		while (next != last && not compare(*next, *current)) {
			++current;
			++next;
		}

		// If the run is too small
		if (std::distance(runs.back(), next) == 1) {
			// Look for a descending run and reverse
			while (next != last && not compare(*current, *next)) {
				++current;
				++next;
			}
			std::reverse(runs.back(), next);

			// Check whether we can make a bigger run with
			// the following elements too
			while (next != last && not compare(*next, *current)) {
				++current;
				++next;
			}

			// If the beginning of the run is greater than the
			// end of the previous run, make that a big run
			if (runs.size() > 1 && compare(*std::prev(runs.back()), *runs.back())) {
				runs.pop_back();
			}
		}

		// Store the beginning of the next run
		runs.push_back(next);
		if (next == last) break;

		++current;
		++next;
	}

	////////////////////////////////////////////////////////////
	// Merge runs

	while (runs.size() > 3) {
		auto j = std::begin(runs);
		while (j != std::end(runs)) {
			// Beginning of the runs
			auto&& one = j++;
			if (j == std::end(runs)) break;
			auto&& two = j++;
			if (j == std::end(runs)) break;
			auto&& three = j++;
			if (j == std::end(runs)) break;

			if (std::distance(*one, *two) < p * (std::distance(*two, *three) + std::distance(*three, *j))) {
				::inplace_merge(*one, *two, *three, compare);
				runs.erase(two);
				--j;
			}
			else {
				::inplace_merge(*two, *three, *j, compare);
				runs.erase(three);
			}
		}
	}

	// Merge potential remaining runs
	if (runs.size() == 3) {
		::inplace_merge(
			*std::begin(runs),
			*std::next(std::begin(runs)),
			*std::next(std::next(std::begin(runs))),
			compare
		);
	}
}
template<class T>
inline void neatsort(T _First, T _Last) {
	neatsort(_First, _Last, std::less<>());
}
}

#endif // CPPSORT_DETAIL_NEATSORT_H_


~-----------------------------------------------~
C:\Users\Josh\Documents\Visual Studio 2017\Projects\Sorting\Sorting\patiencesort.h
~-----------------------------------------------~
/*
* The MIT License (MIT)
*
* Copyright (c) 2016 JuSch92
* Modified in 2016 by Morwenn for inclusion into cpp-sort
*
* Permission is hereby granted, free of charge, to any person obtaining a copy
* of this software and associated documentation files (the "Software"), to deal
* in the Software without restriction, including without limitation the rights
* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
* copies of the Software, and to permit persons to whom the Software is
* furnished to do so, subject to the following conditions:
*
* The above copyright notice and this permission notice shall be included in
* all copies or substantial portions of the Software.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
* THE SOFTWARE.
*/
#ifndef CPPSORT_DETAIL_PATIENCE_SORT_H_
#define CPPSORT_DETAIL_PATIENCE_SORT_H_

////////////////////////////////////////////////////////////
// Headers
////////////////////////////////////////////////////////////
#include <algorithm>
#include <array>
#include <cmath>
#include <cstddef>
#include <iterator>
#include <list>
#include <memory>
#include <vector>

namespace  {
constexpr std::size_t kValuesPerBlock = 800;

template<typename T>
struct RunBlock {
	RunBlock* next;
	RunBlock* prev;
	int next_free_pos_;
	T values[kValuesPerBlock];
	bool is_front;
	RunBlock() :
		next(nullptr),
		prev(nullptr),
		next_free_pos_(0),
		is_front(false) {}
};

template<typename T>
class RunPool {
	class iterator {
	public:
		using self_type = iterator;
		using value_type = T;
		using reference = value_type & ;
		using pointer = value_type * ;
		using difference_type = std::size_t;
		using iterator_category = std::bidirectional_iterator_tag;

		iterator(RunBlock<value_type>* block, std::size_t index) : block_(block), index_(index) {}

		self_type& operator++() {
			index_++;
			if (index_ >= kValuesPerBlock) {
				index_ -= kValuesPerBlock;
				block_ = block_->next;
				return *this;
			}
			return *this;
		}
		self_type& operator++(int) {
			self_type& temp = *this;
			index_++;
			if (index_ >= kValuesPerBlock) {
				index_ -= kValuesPerBlock;
				block_ = block_->next;
				return temp;
			}
			return temp;
		}
		self_type& operator--() {
			index_--;
			if (index_ < 0) {
				index_ += kValuesPerBlock;
				block_ = block_->prev;
			}
			return *this;
		}
		self_type& operator--(int i) {
			self_type& temp = *this;
			index_--;
			if (index_ < 0) {
				index_ += kValuesPerBlock;
				block_ = block_->prev;
			}
			return temp;
		}
		reference operator*() {
			return block_->values[index_];
		}
		pointer operator->() {
			return &block_->values[index_];
		}
		bool operator==(const self_type& rhs) {
			return &block_->values[index_] == &rhs.block_[rhs.index_];
		}
		bool operator!=(const self_type& rhs) {
			return &block_->values[index_] != &rhs.block_->values[rhs.index_];
		}

		RunBlock<T>* block_;
		std::size_t index_;
	};

public:
	RunPool() :
		begin_back_(Alloc()),
		end_back_(begin_back_),
		size_(0),
		begin_front_(nullptr),
		end_front_(nullptr),
		end_block_(begin_back_) {}

	RunPool(const RunPool&) = delete;
	RunPool& operator=(const RunPool&) = delete;
	RunPool(RunPool&&) = default;
	RunPool& operator=(RunPool&&) = default;

	void Add(T &value) {
		if (end_back_->next_free_pos_ < kValuesPerBlock) {
			end_back_->values[end_back_->next_free_pos_] = value;
		}
		else {
			RunBlock<T>* temp = Alloc();
			temp->values[0] = value;
			temp->prev = end_back_;
			end_back_->next = temp;
			end_back_ = temp;
			end_block_ = temp;
			size_ += kValuesPerBlock;
		}
		end_back_->next_free_pos_++;
	}

	void AddFront(T &value) {
		if (begin_front_ == nullptr) {
			begin_front_ = Alloc();
			begin_front_->next_free_pos_ = kValuesPerBlock - 1;
			begin_front_->is_front = true;
			begin_front_->next = begin_back_;

			end_front_ = begin_front_;
			begin_back_->prev = end_front_;
		}

		if (begin_front_->next_free_pos_ < 0) {
			RunBlock<T>* temp = Alloc();
			temp->is_front = true;
			temp->next = begin_front_;
			temp->values[kValuesPerBlock - 1] = value;
			temp->next_free_pos_ = kValuesPerBlock - 2;

			begin_front_->prev = temp;
			begin_front_ = temp;
			size_ += kValuesPerBlock;

		}
		else {
			begin_front_->values[begin_front_->next_free_pos_] = value;
			begin_front_->next_free_pos_--;
		}
	}

	std::size_t size() const {
		int size_total = size_;
		size_total += end_back_->next_free_pos_;

		if (begin_front_ != nullptr) {
			size_total += kValuesPerBlock - begin_front_->next_free_pos_ - 1;
		}
		return size_total;
	}

	T& operator[](std::size_t t) {
		RunBlock<T>* temp = begin_back_;
		while (t >= kValuesPerBlock) {
			temp = temp->next;
			t -= kValuesPerBlock;
		}
		return temp->values[t];
	}

	iterator begin() {
		if (begin_front_ == nullptr) {
			return iterator(begin_back_, 0);
		}
		else {
			return iterator(begin_front_, begin_front_->next_free_pos_ + 1);
		}

	}

	iterator end() {        // points to the last element plus one
		if (end_block_->next_free_pos_ >= kValuesPerBlock) {
			return iterator(end_block_, kValuesPerBlock);
		}
		return iterator(end_block_, end_block_->next_free_pos_);

	}

	iterator last() {       // points to the last element
		if (end_block_->next_free_pos_ > 0) {
			return iterator(end_block_, end_block_->next_free_pos_ - 1);
		}
		else {
			return iterator(end_block_->prev, kValuesPerBlock - 1);
		}
	}

	T& back() {
		int next_free = end_block_->next_free_pos_;
		if (next_free <= 0) {
			return end_block_->prev->values[kValuesPerBlock - 1];
		}
		else {
			return end_block_->values[next_free - 1];
		}
	}

	static void SetMemSize(std::size_t s) {
		mem_blocks_ = s;
	}

	static void Init() {
		memory_ = new RunBlock<T>[mem_blocks_];
		next_free_ = memory_;
	}

	static void Release() {
		delete[] memory_;
		memory_ = nullptr;
	}

	static RunBlock<T>* Alloc() {
		RunBlock<T>* ret = next_free_;
		next_free_++;
		return ret;
	}

private:
	RunBlock<T>* begin_back_;
	RunBlock<T>* end_back_;
	RunBlock<T>* begin_front_;
	RunBlock<T>* end_front_;
	RunBlock<T>* end_block_;
	std::size_t size_;

	static RunBlock<T>* memory_;
	static RunBlock<T>* next_free_;
	static std::size_t mem_blocks_;
};

template<typename T>
RunBlock<T>* RunPool<T>::memory_ = nullptr;

template<typename T>
RunBlock<T>* RunPool<T>::next_free_ = nullptr;

template<typename T>
std::size_t RunPool<T>::mem_blocks_;

const float kMaxSortedness = 0.35f;
const float kRunPoolSize = 1.5f;
const float kBlockPoolFactor = 15.0f;

struct RunInfo {
	std::size_t array_index, elem_index, run_size;
public:
	RunInfo() {}

	RunInfo(std::size_t arr_index, std::size_t el_index, std::size_t run_count) {
		array_index = arr_index;
		elem_index = el_index;
		run_size = run_count;
	}
};

template<typename RandomAccessIterator>
class PatienceSorting {
public:

	using value_type = typename std::iterator_traits<RandomAccessIterator>::value_type;
	using value_vector = std::vector<value_type>;
	using run_info_list = std::list<RunInfo>;

	void Sort(RandomAccessIterator begin, RandomAccessIterator end) {
		std::vector<RunPool<value_type>*> runs;
		GenerateRuns(begin, end, runs);
		Merge(begin, runs);
		// release pool memory of runs and runblocks
		RunPool<value_type>::Release();
		Release();
	}

private:
	std::vector<value_type> lasts_;
	std::vector<value_type> heads_;
	long num_elements_ = 0;
	std::size_t num_runs_ = 0;
	float sortedness_ = 0.0f;
	int values_not_in_order_ = 0;

	static RunPool<value_type>* memory_;
	static RunPool<value_type>* next_free_;
	static std::size_t run_blocks_;

	void GenerateRuns(RandomAccessIterator begin, RandomAccessIterator end, std::vector<RunPool<value_type>*>& runs) {
		runs.clear();
		num_elements_ = std::distance(begin, end);
		num_runs_ = static_cast<std::size_t>(std::sqrt(num_elements_));

		// calculate the degree of disorder
		values_not_in_order_ = GetOrderLevel(begin, end);
		sortedness_ = values_not_in_order_ / static_cast<float>(num_elements_);

		// fallback to std::sort if input data is too random
		if (sortedness_ > kMaxSortedness) {
			std::sort(begin, end);
			return;
		}

		// Pool for runs
		SetMemSize(num_runs_ * kRunPoolSize);
		Init();

		// Pool for runblocks
		RunPool<value_type>::SetMemSize(GetMemPoolSize(num_elements_, num_runs_));
		RunPool<value_type>::Init();

		runs.reserve(num_runs_);
		lasts_.reserve(num_elements_);
		heads_.reserve(num_elements_);

		for (auto it = begin; it != end; ++it) {

			// binary search the right run to insert the current element
			value_type value = *it;
			auto key = std::lower_bound(lasts_.begin(), lasts_.end(), value, [](value_type& v1, value_type v2) { return v1 > v2; });

			if (key != lasts_.end()) {      // if suitable run is found, append
				std::size_t i = std::distance(lasts_.begin(), key);
				runs[i]->Add(value);
				lasts_[i] = value;

				// if we add to the first run, try to add as many elements as possible to avoid expensive binary search
				if (i == 0) {
					auto next_value = std::next(it);
					while (next_value != end
						   && *next_value > lasts_[i]) {
						++it;
						runs[0]->Add(*it);
						lasts_[0] = *it;
					}
				}
			}
			else {      // no suitable run found, so we try to add the element to the begin of a run

						// binary search the beginnings to find a suitable run
				key = std::lower_bound(heads_.begin(), heads_.end(), value);
				if (key == heads_.end()) {      // no suitable run found, create a new run and add it to sorted runs vector

					RunPool<value_type>* run = Alloc();
					new(run) RunPool<value_type>();      // necessary, otherwise the objects are not initialized -> memory error
					runs.push_back(run);

					runs.back()->Add(value);
					lasts_.push_back(value);
					heads_.push_back(value);
				}
				else {
					// suitable run found, so append to its beginning.
					std::size_t i = std::distance(heads_.begin(), key);
					runs[i]->AddFront(value);
					heads_[i] = value;
				}
			}
		}
	}

	void Merge(RandomAccessIterator begin, std::vector<RunPool<value_type>*>& runs) {
		// if no runs exist, input is probably empty, so exit here
		if (runs.size() == 0) {
			return;
		}

		// if only 1 run exists, this means the input data is in ascending order or in reversed, but
		// by adding to the front of a run it is automatically reversed
		if (runs.size() < 2) {
			// copy content to target array
			auto end = runs[0]->last();
			auto first_copy = begin;
			for (auto it = runs[0]->begin(); it != end; ++it) {
				*first_copy = *it;
				first_copy++;
			}
			*first_copy = runs[0]->back();
			return;
		}

		std::sort(runs.begin(), runs.end(), [](const RunPool<value_type>* a, const RunPool<value_type>* b) { return
				  a->size() <
				  b->size(); });
		value_vector elems1;
		value_vector elems2(num_elements_);
		elems1.reserve(num_elements_);
		run_info_list run_infos;
		std::size_t next_empty_arr_loc = 0;
		std::array<value_vector *, 2> arrs;
		arrs[0] = &elems1;
		arrs[1] = &elems2;

		// copy sorted runs consecutively to the first ping-pong array and save the information
		// in which array it is, at which index it starts and its size to an additional list element
		for (std::size_t i = 0; i < runs.size(); i++) {

			std::size_t temp_index = next_empty_arr_loc;
			auto it = runs[i]->begin();
			auto end = runs[i]->last();
			for (; it != end; ++it) {
				elems1.push_back(*it);
				temp_index++;
			}
			elems1.push_back(*it);

			RunInfo run_info;
			run_info.array_index = 0;
			run_info.elem_index = next_empty_arr_loc;
			run_info.run_size = runs[i]->size();
			run_infos.push_back(run_info);
			next_empty_arr_loc += runs[i]->size();
		}

		auto cur_run = run_infos.begin();
		const auto beginRun = cur_run;

		// Ping-pong merge until only 2 runs are left
		while (run_infos.size() > 2) {
			auto next_run = std::next(cur_run, 1);
			if (cur_run == run_infos.end() || std::next(cur_run, 1) == run_infos.end() ||
				(cur_run->run_size + next_run->run_size) >
				(beginRun->run_size + (std::next(beginRun, 1)->run_size))) {
				cur_run = run_infos.begin();
			}
			next_run = std::next(cur_run, 1);
			if (cur_run->array_index == 0) {          // blindly merge curRun and curRuns next into Elems2
				BlindMerge(arrs, elems2, cur_run, 1);
			}
			else {
				BlindMerge(arrs, elems1, cur_run, 0);
			}
			cur_run->run_size += next_run->run_size;
			run_infos.erase(next_run);
			cur_run++;
		}

		// merge the last 2 runs directly to the output
		cur_run = run_infos.begin();
		BlindMerge(arrs, begin, cur_run);
	}

	// Merge 2 sorted runs into a ping-pong array
	void BlindMerge(std::array<value_vector *, 2> &arrs, value_vector &write,
					typename std::list<RunInfo>::iterator cur_run, std::size_t arr_index) {
		auto next_run = std::next(cur_run, 1);
		std::size_t one = cur_run->elem_index,
			two = next_run->elem_index,
			k = cur_run->elem_index;
		value_vector &curr_arr = *arrs[cur_run->array_index];
		value_vector &next_arr = *arrs[next_run->array_index];

		while ((one - cur_run->elem_index) < cur_run->run_size &&
			(two - next_run->elem_index) < next_run->run_size) {

			if (curr_arr[one] < next_arr[two]) {
				write[k] = curr_arr[one];
				one++;
			}
			else {
				write[k] = next_arr[two];
				two++;
			}
			k++;
		}
		// if both runs don't have the same size, copy the remaining elements over
		if ((one - cur_run->elem_index) < cur_run->run_size) {
			for (std::size_t i = (one - cur_run->elem_index); i < cur_run->run_size; i++) {
				write[k] = curr_arr[i + cur_run->elem_index];
				k++;
			}
		}
		else {
			for (std::size_t i = (two - next_run->elem_index); i < next_run->run_size; i++) {
				write[k] = next_arr[i + next_run->elem_index];
				k++;
			}
		}
		cur_run->array_index = arr_index;
	}

	// Merge the last 2 runs directly to the output
	void BlindMerge(std::array<value_vector *, 2> &arrs, RandomAccessIterator begin,
					typename std::list<RunInfo>::iterator cur_run) {
		auto next_run = std::next(cur_run, 1);
		std::size_t one = cur_run->elem_index,
			two = next_run->elem_index;
		value_vector &curr_arr = *arrs[cur_run->array_index];
		value_vector &next_arr = *arrs[next_run->array_index];

		while ((one - cur_run->elem_index) < cur_run->run_size &&
			(two - next_run->elem_index) < next_run->run_size) {

			if (curr_arr[one] < next_arr[two]) {
				*begin = curr_arr[one];
				one++;
			}
			else {
				*begin = next_arr[two];
				two++;
			}
			begin++;
		}
		if ((one - cur_run->elem_index) < cur_run->run_size) {
			for (std::size_t i = (one - cur_run->elem_index); i < cur_run->run_size; i++) {
				*begin = curr_arr[i + cur_run->elem_index];
				begin++;
			}
		}
		else {
			for (std::size_t i = (two - next_run->elem_index); i < next_run->run_size; i++) {
				*begin = next_arr[i + next_run->elem_index];
				begin++;
			}
		}
	}

	static void SetMemSize(std::size_t s) {
		run_blocks_ = s;
	}

	static void Init() {
		memory_ = new RunPool<value_type>[run_blocks_];
		next_free_ = memory_;
	}

	static void Release() {
		delete[] memory_;
		memory_ = nullptr;
	}

	// Fetch a new memory block from the pool
	static RunPool<value_type>* Alloc() {
		RunPool<value_type>* ret = next_free_;
		next_free_++;
		return ret;
	}

	// Counts how many elements in the input sequence are not in ascending order
	int GetOrderLevel(RandomAccessIterator first, RandomAccessIterator last) {
		int k = 0;
		last -= 1;
		for (RandomAccessIterator i = first; i != last; ++i) {
			k += (*i > *(i + 1));
		}
		return k;
	}

	std::size_t GetMemPoolSize(std::size_t num_elements, std::size_t num_runs) {

		std::size_t x = num_elements;
		while (x >= 100) {
			x /= 100;
		}
		std::size_t y = num_elements / x;

		return num_runs * std::sqrt(kBlockPoolFactor * (num_elements / y));
	}
};

template<typename RandomAccessIterator>
RunPool<typename std::iterator_traits<RandomAccessIterator>::value_type>* PatienceSorting<RandomAccessIterator>::memory_ = nullptr;

template<typename RandomAccessIterator>
RunPool<typename std::iterator_traits<RandomAccessIterator>::value_type>* PatienceSorting<RandomAccessIterator>::next_free_ = nullptr;

template<typename RandomAccessIterator>
std::size_t PatienceSorting<RandomAccessIterator>::run_blocks_;

template<typename RandomAccessIterator>
auto patience_sort(RandomAccessIterator begin, RandomAccessIterator end)
-> void {
	PatienceSorting<RandomAccessIterator> ps;
	ps.Sort(begin, end);
}

template <class RandomAccessIterator>
void patiencesort(RandomAccessIterator begin, RandomAccessIterator end) {
	PatienceSorting<RandomAccessIterator>  ps;
	ps.Sort(begin, end);
}

template <class RandomAccessIterator, class C>
void patiencesort(RandomAccessIterator begin, RandomAccessIterator end, C compare) {
	patiencesort(begin, end);
}
}

#endif // CPPSORT_DETAIL_PATIENCE_SORT_H_































//#ifndef PATIENCESORT_H
//#define PATIENCESORT_H
//
//#include <vector>
//#include <list>
//#include <array>
//#include <algorithm>
//
//#include "RunPool.h"
//
//
//const float kMaxSortedness = 0.35f;
//const float kRunPoolSize = 1.5f;
//const float kBlockPoolFactor = 15.0f;
//
//
//struct RunInfo {
//	size_t array_index, elem_index, run_size;
//public:
//	RunInfo() {}
//
//	RunInfo(size_t arr_index, size_t el_index, size_t run_count) {
//		array_index = arr_index;
//		elem_index = el_index;
//		run_size = run_count;
//	}
//};
//
//template <class RAI>
//class PatienceSorting {
//public:
//
//	typedef typename RAI::value_type        ValueType;
//	typedef std::vector<ValueType>          ValueVector;
//	typedef std::list<RunInfo>              RunInfoList;
//
//
//	void Sort(RAI begin, RAI end) {
//		std::vector<RunPool<ValueType>*> runs;
//		GenerateRuns(begin, end, runs);
//		Merge(begin, runs);
//	}
//
//
//private:
//	std::vector<ValueType> lasts_;
//	std::vector<ValueType> heads_;
//	long num_elements_ = 0;
//	size_t num_runs_ = 0;
//	float sortedness_ = 0.0f;
//	int values_not_in_order_ = 0;
//
//	static RunPool<ValueType>* memory_;
//	static RunPool<ValueType>* next_free_;
//	static size_t run_blocks_;
//
//	void GenerateRuns(RAI begin, RAI end, std::vector<RunPool<ValueType>*>& runs) {
//		runs.clear();
//		num_elements_ = std::distance(begin, end);
//		num_runs_ = static_cast<size_t>(sqrt(num_elements_));
//
//		// calculate the degree of disorder
//		values_not_in_order_ = GetOrderLevel(begin, end);
//		sortedness_ = values_not_in_order_ / static_cast<float>(num_elements_);
//
//		// fallback to std::sort if input data is too random
//		if (sortedness_ > kMaxSortedness) {
//			std::sort(begin, end);
//			return;
//		}
//
//		// Pool for runs
//		SetMemSize(num_runs_ * kRunPoolSize);
//		Init();
//
//		// Pool for runblocks
//		RunPool<ValueType>::SetMemSize(GetMemPoolSize(num_elements_, num_runs_));
//		RunPool<ValueType>::Init();
//
//
//		runs.reserve(num_runs_);
//		lasts_.reserve(num_elements_);
//		heads_.reserve(num_elements_);
//
//		for (auto it = begin; it != end; ++it) {
//
//			// binary search the right run to insert the current element
//			ValueType value = *it;
//			auto key = std::lower_bound(lasts_.begin(), lasts_.end(), value, [](ValueType& v1, ValueType v2) { return v1 > v2; });
//
//			if (key != lasts_.end()) {      // if suitable run is found, append
//				size_t i = std::distance(lasts_.begin(), key);
//				runs[i]->Add(value);
//				lasts_[i] = value;
//
//				// if we add to the first run, try to add as many elements as possible to avoid expensive binary search
//				if (i == 0) {
//					auto next_value = std::next(it, 1);
//					while (next_value != end
//						   && *next_value > lasts_[i]) {
//						it++;
//						runs[0]->Add(*it);
//						lasts_[0] = *it;
//					}
//				}
//			}
//			else {      // no suitable run found, so we try to add the element to the begin of a run
//
//						// binary search the beginnings to find a suitable run
//				key = std::lower_bound(heads_.begin(), heads_.end(), value);
//				if (key == heads_.end()) {      // no suitable run found, create a new run and add it to sorted runs vector
//
//					RunPool<ValueType>* run = Alloc();
//					new(run) RunPool<ValueType>();      // necessary, otherwise the objects are not initialized -> memory error
//					runs.push_back(run);
//
//					runs.back()->Add(value);
//					lasts_.push_back(value);
//					heads_.push_back(value);
//				}
//				else {
//					// suitable run found, so append to its beginning.
//					size_t i = std::distance(heads_.begin(), key);
//					runs[i]->AddFront(value);
//					heads_[i] = value;
//				}
//			}
//		}
//	}
//
//	void Merge(RAI begin, std::vector<RunPool<ValueType>*>& runs) {
//		// if no runs exist, input is probably empty, so exit here
//		if (runs.size() == 0) {
//			return;
//		}
//
//		// if only 1 run exists, this means the input data is in ascending order or in reversed, but
//		// by adding to the front of a run it is automatically reversed
//		if (runs.size() < 2) {
//			// copy content to target array
//			auto end = runs[0]->last();
//			auto first_copy = begin;
//			for (auto it = runs[0]->begin(); it != end; ++it) {
//				*first_copy = *it;
//				first_copy++;
//			}
//			*first_copy = runs[0]->back();
//			return;
//		}
//
//
//		std::sort(runs.begin(), runs.end(), [](const RunPool<ValueType>* a, const RunPool<ValueType>* b) { return
//				  a->size() <
//				  b->size(); });
//		ValueVector elems1;
//		ValueVector elems2(num_elements_);
//		elems1.reserve(num_elements_);
//		RunInfoList run_infos;
//		size_t next_empty_arr_loc = 0;
//		std::array<ValueVector *, 2> arrs;
//		arrs[0] = &elems1;
//		arrs[1] = &elems2;
//
//		// copy sorted runs consecutively to the first ping-pong array and save the information
//		// in which array it is, at which index it starts and its size to an additional list element
//		for (size_t i = 0; i < runs.size(); i++) {
//
//			size_t temp_index = next_empty_arr_loc;
//			auto it = runs[i]->begin();
//			auto end = runs[i]->last();
//			for (; it != end; ++it) {
//				elems1.push_back(*it);
//				temp_index++;
//			}
//			elems1.push_back(*it);
//
//			RunInfo run_info;
//			run_info.array_index = 0;
//			run_info.elem_index = next_empty_arr_loc;
//			run_info.run_size = runs[i]->size();
//			run_infos.push_back(run_info);
//			next_empty_arr_loc += runs[i]->size();
//		}
//
//		auto cur_run = run_infos.begin();
//		const auto beginRun = cur_run;
//
//		// Ping-pong merge until only 2 runs are left
//		while (run_infos.size() > 2) {
//			auto next_run = std::next(cur_run, 1);
//			if (cur_run == run_infos.end() || std::next(cur_run, 1) == run_infos.end() ||
//				(cur_run->run_size + next_run->run_size) >
//				(beginRun->run_size + (std::next(beginRun, 1)->run_size))) {
//				cur_run = run_infos.begin();
//			}
//			next_run = std::next(cur_run, 1);
//			if (cur_run->array_index == 0) {          // blindly merge curRun and curRuns next into Elems2
//				BlindMerge(arrs, elems2, cur_run, 1);
//			}
//			else {
//				BlindMerge(arrs, elems1, cur_run, 0);
//			}
//			cur_run->run_size += next_run->run_size;
//			run_infos.erase(next_run);
//			cur_run++;
//		}
//
//		// merge the last 2 runs directly to the output
//		cur_run = run_infos.begin();
//		BlindMerge(arrs, begin, cur_run);
//
//		// release pool memory of runs and runblocks
//		RunPool<ValueType>::Release();
//		Release();
//
//	}
//
//	// Merge 2 sorted runs into a ping-pong array
//	void BlindMerge(std::array<ValueVector *, 2> &arrs, ValueVector &write,
//					typename std::list<RunInfo>::iterator cur_run, size_t arr_index) {
//		auto next_run = std::next(cur_run, 1);
//		size_t one = cur_run->elem_index,
//			two = next_run->elem_index,
//			k = cur_run->elem_index;
//		ValueVector &curr_arr = *arrs[cur_run->array_index];
//		ValueVector &next_arr = *arrs[next_run->array_index];
//
//		while ((one - cur_run->elem_index) < cur_run->run_size &&
//			(two - next_run->elem_index) < next_run->run_size) {
//
//			if (curr_arr[one] < next_arr[two]) {
//				write[k] = curr_arr[one];
//				one++;
//			}
//			else {
//				write[k] = next_arr[two];
//				two++;
//			}
//			k++;
//		}
//		// if both runs don't have the same size, copy the remaining elements over
//		if ((one - cur_run->elem_index) < cur_run->run_size) {
//			for (size_t i = (one - cur_run->elem_index); i < cur_run->run_size; i++) {
//				write[k] = curr_arr[i + cur_run->elem_index];
//				k++;
//			}
//		}
//		else {
//			for (size_t i = (two - next_run->elem_index); i < next_run->run_size; i++) {
//				write[k] = next_arr[i + next_run->elem_index];
//				k++;
//			}
//		}
//		cur_run->array_index = arr_index;
//	}
//
//	// Merge the last 2 runs directly to the output
//	void BlindMerge(std::array<ValueVector *, 2> &arrs, RAI begin,
//					typename std::list<RunInfo>::iterator cur_run) {
//		auto next_run = std::next(cur_run, 1);
//		size_t one = cur_run->elem_index,
//			two = next_run->elem_index;
//		ValueVector &curr_arr = *arrs[cur_run->array_index];
//		ValueVector &next_arr = *arrs[next_run->array_index];
//
//		while ((one - cur_run->elem_index) < cur_run->run_size &&
//			(two - next_run->elem_index) < next_run->run_size) {
//
//			if (curr_arr[one] < next_arr[two]) {
//				*begin = curr_arr[one];
//				one++;
//			}
//			else {
//				*begin = next_arr[two];
//				two++;
//			}
//			begin++;
//		}
//		if ((one - cur_run->elem_index) < cur_run->run_size) {
//			for (size_t i = (one - cur_run->elem_index); i < cur_run->run_size; i++) {
//				*begin = curr_arr[i + cur_run->elem_index];
//				begin++;
//			}
//		}
//		else {
//			for (size_t i = (two - next_run->elem_index); i < next_run->run_size; i++) {
//				*begin = next_arr[i + next_run->elem_index];
//				begin++;
//			}
//		}
//	}
//
//	static void SetMemSize(size_t s) {
//		run_blocks_ = s;
//	}
//
//	static void Init() {
//		memory_ = new RunPool<ValueType>[run_blocks_];
//		next_free_ = memory_;
//	}
//
//	static void Release() {
//		delete[] memory_;
//		memory_ = NULL;
//	}
//
//	// Fetch a new memory block from the pool
//	static RunPool<ValueType>* Alloc() {
//		RunPool<ValueType>* ret = next_free_;
//		next_free_++;
//		return ret;
//	}
//
//	// Counts how many elements in the input sequence are not in ascending order
//	int GetOrderLevel(RAI first, RAI last) {
//		int k = 0;
//		last -= 1;
//		for (RAI i = first; i != last; ++i) {
//			k += (*i > *(i + 1));
//		}
//		return k;
//	}
//
//	size_t GetMemPoolSize(const size_t num_elements, const size_t num_runs) {
//
//		size_t x = num_elements;
//		while (x >= 100) {
//			x /= 100;
//		}
//		size_t y = num_elements / x;
//
//		return num_runs * sqrt(kBlockPoolFactor * (num_elements / y));
//	}
//};
//
//template <class RAI>
//RunPool<typename RAI::value_type>* PatienceSorting<RAI>::memory_ = NULL;
//
//template <class RAI>
//RunPool<typename RAI::value_type>* PatienceSorting<RAI>::next_free_ = NULL;
//
//template <class RAI>
//size_t PatienceSorting<RAI>::run_blocks_;
//
//
//// simple function that applies patience sorting in the same style as std::sort
//template <class RandomAccessIterator>
//void patiencesort(RandomAccessIterator begin, RandomAccessIterator end) {
//	PatienceSorting<RandomAccessIterator>  ps;
//	ps.Sort(begin, end);
//}
//
//template <class RandomAccessIterator, class C>
//void patiencesort(RandomAccessIterator begin, RandomAccessIterator end, C compare) {
//	patiencesort(begin, end);
//}
//
//#endif
//
//
//
//
//
//
//
//
//



~-----------------------------------------------~
C:\Users\Josh\Documents\Visual Studio 2017\Projects\Sorting\Sorting\pdqsort.h
~-----------------------------------------------~
/*
pdqsort.h - Pattern-defeating quicksort.

Copyright (c) 2015 Orson Peters

This software is provided 'as-is', without any express or implied warranty. In no event will the
authors be held liable for any damages arising from the use of this software.

Permission is granted to anyone to use this software for any purpose, including commercial
applications, and to alter it and redistribute it freely, subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the
original software. If you use this software in a product, an acknowledgment in the product
documentation would be appreciated but is not required.

2. Altered source versions must be plainly marked as such, and must not be misrepresented as
being the original software.

3. This notice may not be removed or altered from any source distribution.
*/

#define PDQSORT_H
#ifndef PDQSORT_H
#define PDQSORT_H

#include <algorithm>
#include <cstddef>
#include <functional>
#include <utility>
#include <iterator>

#if __cplusplus >= 201103L
#include <cstdint>
#include <type_traits>
#define PDQSORT_PREFER_MOVE(x) std::move(x)
#else
#define PDQSORT_PREFER_MOVE(x) (x)
#endif


namespace pdqsort_detail {
enum {
	// Partitions below this size are sorted using insertion sort.
	insertion_sort_threshold = 24,

	// Partitions above this size use Tukey's ninther to select the pivot.
	ninther_threshold = 128,

	// When we detect an already sorted partition, attempt an insertion sort that allows this
	// amount of element moves before giving up.
	partial_insertion_sort_limit = 8,

	// Must be multiple of 8 due to loop unrolling, and < 256 to fit in unsigned char.
	block_size = 64,

	// Cacheline size, assumes power of two.
	cacheline_size = 64

};

#if __cplusplus >= 201103L
template<class T> struct is_default_compare : std::false_type {};
template<class T> struct is_default_compare<std::less<T>> : std::true_type {};
template<class T> struct is_default_compare<std::greater<T>> : std::true_type {};
#endif

// Returns floor(log2(n)), assumes n > 0.
template<class T>
inline int log2(T n) {
	int log = 0;
	while (n >>= 1) ++log;
	return log;
}

// Sorts [begin, end) using insertion sort with the given comparison function.
template<class Iter, class Compare>
inline void insertion_sort(Iter begin, Iter end, Compare comp) {
	typedef typename std::iterator_traits<Iter>::value_type T;
	if (begin == end) return;

	for (Iter cur = begin + 1; cur != end; ++cur) {
		Iter sift = cur;
		Iter sift_1 = cur - 1;

		// Compare first so we can avoid 2 moves for an element already positioned correctly.
		if (comp(*sift, *sift_1)) {
			T tmp = PDQSORT_PREFER_MOVE(*sift);

			do { *sift-- = PDQSORT_PREFER_MOVE(*sift_1); } while (sift != begin && comp(tmp, *--sift_1));

			*sift = PDQSORT_PREFER_MOVE(tmp);
		}
	}
}

// Sorts [begin, end) using insertion sort with the given comparison function. Assumes
// *(begin - 1) is an element smaller than or equal to any element in [begin, end).
template<class Iter, class Compare>
inline void unguarded_insertion_sort(Iter begin, Iter end, Compare comp) {
	typedef typename std::iterator_traits<Iter>::value_type T;
	if (begin == end) return;

	for (Iter cur = begin + 1; cur != end; ++cur) {
		Iter sift = cur;
		Iter sift_1 = cur - 1;

		// Compare first so we can avoid 2 moves for an element already positioned correctly.
		if (comp(*sift, *sift_1)) {
			T tmp = PDQSORT_PREFER_MOVE(*sift);

			do { *sift-- = PDQSORT_PREFER_MOVE(*sift_1); } while (comp(tmp, *--sift_1));

			*sift = PDQSORT_PREFER_MOVE(tmp);
		}
	}
}

// Attempts to use insertion sort on [begin, end). Will return false if more than
// partial_insertion_sort_limit elements were moved, and abort sorting. Otherwise it will
// successfully sort and return true.
template<class Iter, class Compare>
inline bool partial_insertion_sort(Iter begin, Iter end, Compare comp) {
	typedef typename std::iterator_traits<Iter>::value_type T;
	if (begin == end) return true;

	int limit = 0;
	for (Iter cur = begin + 1; cur != end; ++cur) {
		if (limit > partial_insertion_sort_limit) return false;

		Iter sift = cur;
		Iter sift_1 = cur - 1;

		// Compare first so we can avoid 2 moves for an element already positioned correctly.
		if (comp(*sift, *sift_1)) {
			T tmp = PDQSORT_PREFER_MOVE(*sift);

			do { *sift-- = PDQSORT_PREFER_MOVE(*sift_1); } while (sift != begin && comp(tmp, *--sift_1));

			*sift = PDQSORT_PREFER_MOVE(tmp);
			limit += cur - sift;
		}
	}

	return true;
}

template<class Iter, class Compare>
inline void sort2(Iter a, Iter b, Compare comp) {
	if (comp(*b, *a)) std::iter_swap(a, b);
}

// Sorts the elements *a, *b and *c using comparison function comp.
template<class Iter, class Compare>
inline void sort3(Iter a, Iter b, Iter c, Compare comp) {
	sort2(a, b, comp);
	sort2(b, c, comp);
	sort2(a, b, comp);
}

template<class T>
inline T* align_cacheline(T* p) {
#if defined(UINTPTR_MAX) && __cplusplus >= 201103L
	std::uintptr_t ip = reinterpret_cast<std::uintptr_t>(p);
#else
	std::size_t ip = reinterpret_cast<std::size_t>(p);
#endif
	ip = (ip + cacheline_size - 1) & -cacheline_size;
	return reinterpret_cast<T*>(ip);
}

template<class Iter>
inline void swap_offsets(Iter first, Iter last,
						 unsigned char* offsets_l, unsigned char* offsets_r,
						 int num, bool use_swaps) {
	typedef typename std::iterator_traits<Iter>::value_type T;
	if (use_swaps) {
		// This case is needed for the descending distribution, where we need
		// to have proper swapping for pdqsort to remain O(n).
		for (int i = 0; i < num; ++i) {
			std::iter_swap(first + offsets_l[i], last - offsets_r[i]);
		}
	}
	else if (num > 0) {
		Iter l = first + offsets_l[0]; Iter r = last - offsets_r[0];
		T tmp(PDQSORT_PREFER_MOVE(*l)); *l = PDQSORT_PREFER_MOVE(*r);
		for (int i = 1; i < num; ++i) {
			l = first + offsets_l[i]; *r = PDQSORT_PREFER_MOVE(*l);
			r = last - offsets_r[i]; *l = PDQSORT_PREFER_MOVE(*r);
		}
		*r = PDQSORT_PREFER_MOVE(tmp);
	}
}

// Partitions [begin, end) around pivot *begin using comparison function comp. Elements equal
// to the pivot are put in the right-hand partition. Returns the position of the pivot after
// partitioning and whether the passed sequence already was correctly partitioned. Assumes the
// pivot is a median of at least 3 elements and that [begin, end) is at least
// insertion_sort_threshold long. Uses branchless partitioning.
template<class Iter, class Compare>
inline std::pair<Iter, bool> partition_right_branchless(Iter begin, Iter end, Compare comp) {
	typedef typename std::iterator_traits<Iter>::value_type T;

	// Move pivot into local for speed.
	T pivot(PDQSORT_PREFER_MOVE(*begin));
	Iter first = begin;
	Iter last = end;

	// Find the first element greater than or equal than the pivot (the median of 3 guarantees
	// this exists).
	while (comp(*++first, pivot));

	// Find the first element strictly smaller than the pivot. We have to guard this search if
	// there was no element before *first.
	if (first - 1 == begin) while (first < last && !comp(*--last, pivot));
	else                    while (!comp(*--last, pivot));

	// If the first pair of elements that should be swapped to partition are the same element,
	// the passed in sequence already was correctly partitioned.
	bool already_partitioned = first >= last;
	if (!already_partitioned) {
		std::iter_swap(first, last);
		++first;
	}

	// The following branchless partitioning is derived from "BlockQuicksort: How Branch
	// Mispredictions dont affect Quicksort" by Stefan Edelkamp and Armin Weiss.
	unsigned char offsets_l_storage[block_size + cacheline_size];
	unsigned char offsets_r_storage[block_size + cacheline_size];
	unsigned char* offsets_l = align_cacheline(offsets_l_storage);
	unsigned char* offsets_r = align_cacheline(offsets_r_storage);
	int num_l, num_r, start_l, start_r;
	num_l = num_r = start_l = start_r = 0;

	while (last - first > 2 * block_size) {
		// Fill up offset blocks with elements that are on the wrong side.
		if (num_l == 0) {
			start_l = 0;
			Iter it = first;
			for (unsigned char i = 0; i < block_size;) {
				offsets_l[num_l] = i++; num_l += !comp(*it, pivot); ++it;
				offsets_l[num_l] = i++; num_l += !comp(*it, pivot); ++it;
				offsets_l[num_l] = i++; num_l += !comp(*it, pivot); ++it;
				offsets_l[num_l] = i++; num_l += !comp(*it, pivot); ++it;
				offsets_l[num_l] = i++; num_l += !comp(*it, pivot); ++it;
				offsets_l[num_l] = i++; num_l += !comp(*it, pivot); ++it;
				offsets_l[num_l] = i++; num_l += !comp(*it, pivot); ++it;
				offsets_l[num_l] = i++; num_l += !comp(*it, pivot); ++it;
			}
		}
		if (num_r == 0) {
			start_r = 0;
			Iter it = last;
			for (unsigned char i = 0; i < block_size;) {
				offsets_r[num_r] = ++i; num_r += comp(*--it, pivot);
				offsets_r[num_r] = ++i; num_r += comp(*--it, pivot);
				offsets_r[num_r] = ++i; num_r += comp(*--it, pivot);
				offsets_r[num_r] = ++i; num_r += comp(*--it, pivot);
				offsets_r[num_r] = ++i; num_r += comp(*--it, pivot);
				offsets_r[num_r] = ++i; num_r += comp(*--it, pivot);
				offsets_r[num_r] = ++i; num_r += comp(*--it, pivot);
				offsets_r[num_r] = ++i; num_r += comp(*--it, pivot);
			}
		}

		// Swap elements and update block sizes and first/last boundaries.
		int num = std::min(num_l, num_r);
		swap_offsets(first, last, offsets_l + start_l, offsets_r + start_r,
					 num, num_l == num_r);
		num_l -= num; num_r -= num;
		start_l += num; start_r += num;
		if (num_l == 0) first += block_size;
		if (num_r == 0) last -= block_size;
	}

	int l_size = 0, r_size = 0;
	int unknown_left = (last - first) - ((num_r || num_l) ? block_size : 0);
	if (num_r) {
		// Handle leftover block by assigning the unknown elements to the other block.
		l_size = unknown_left;
		r_size = block_size;
	}
	else if (num_l) {
		l_size = block_size;
		r_size = unknown_left;
	}
	else {
		// No leftover block, split the unknown elements in two blocks.
		l_size = unknown_left / 2;
		r_size = unknown_left - l_size;
	}

	// Fill offset buffers if needed.
	if (unknown_left && !num_l) {
		start_l = 0;
		Iter it = first;
		for (unsigned char i = 0; i < l_size;) {
			offsets_l[num_l] = i++; num_l += !comp(*it, pivot); ++it;
		}
	}
	if (unknown_left && !num_r) {
		start_r = 0;
		Iter it = last;
		for (unsigned char i = 0; i < r_size;) {
			offsets_r[num_r] = ++i; num_r += comp(*--it, pivot);
		}
	}

	int num = std::min(num_l, num_r);
	swap_offsets(first, last, offsets_l + start_l, offsets_r + start_r, num, num_l == num_r);
	num_l -= num; num_r -= num;
	start_l += num; start_r += num;
	if (num_l == 0) first += l_size;
	if (num_r == 0) last -= r_size;

	// We have now fully identified [first, last)'s proper position. Swap the last elements.
	if (num_l) {
		offsets_l += start_l;
		while (num_l--) std::iter_swap(first + offsets_l[num_l], --last);
		first = last;
	}
	if (num_r) {
		offsets_r += start_r;
		while (num_r--) std::iter_swap(last - offsets_r[num_r], first), ++first;
		last = first;
	}

	// Put the pivot in the right place.
	Iter pivot_pos = first - 1;
	*begin = PDQSORT_PREFER_MOVE(*pivot_pos);
	*pivot_pos = PDQSORT_PREFER_MOVE(pivot);

	return std::make_pair(pivot_pos, already_partitioned);
}

// Partitions [begin, end) around pivot *begin using comparison function comp. Elements equal
// to the pivot are put in the right-hand partition. Returns the position of the pivot after
// partitioning and whether the passed sequence already was correctly partitioned. Assumes the
// pivot is a median of at least 3 elements and that [begin, end) is at least
// insertion_sort_threshold long.
template<class Iter, class Compare>
inline std::pair<Iter, bool> partition_right(Iter begin, Iter end, Compare comp) {
	typedef typename std::iterator_traits<Iter>::value_type T;

	// Move pivot into local for speed.
	T pivot(PDQSORT_PREFER_MOVE(*begin));

	Iter first = begin;
	Iter last = end;

	// Find the first element greater than or equal than the pivot (the median of 3 guarantees
	// this exists).
	while (comp(*++first, pivot));

	// Find the first element strictly smaller than the pivot. We have to guard this search if
	// there was no element before *first.
	if (first - 1 == begin) while (first < last && !comp(*--last, pivot));
	else                    while (!comp(*--last, pivot));

	// If the first pair of elements that should be swapped to partition are the same element,
	// the passed in sequence already was correctly partitioned.
	bool already_partitioned = first >= last;

	// Keep swapping pairs of elements that are on the wrong side of the pivot. Previously
	// swapped pairs guard the searches, which is why the first iteration is special-cased
	// above.
	while (first < last) {
		std::iter_swap(first, last);
		while (comp(*++first, pivot));
		while (!comp(*--last, pivot));
	}

	// Put the pivot in the right place.
	Iter pivot_pos = first - 1;
	*begin = PDQSORT_PREFER_MOVE(*pivot_pos);
	*pivot_pos = PDQSORT_PREFER_MOVE(pivot);

	return std::make_pair(pivot_pos, already_partitioned);
}

// Similar function to the one above, except elements equal to the pivot are put to the left of
// the pivot and it doesn't check or return if the passed sequence already was partitioned.
// Since this is rarely used (the many equal case), and in that case pdqsort already has O(n)
// performance, no block quicksort is applied here for simplicity.
template<class Iter, class Compare>
inline Iter partition_left(Iter begin, Iter end, Compare comp) {
	typedef typename std::iterator_traits<Iter>::value_type T;

	T pivot(PDQSORT_PREFER_MOVE(*begin));
	Iter first = begin;
	Iter last = end;

	while (comp(pivot, *--last));

	if (last + 1 == end) while (first < last && !comp(pivot, *++first));
	else                 while (!comp(pivot, *++first));

	while (first < last) {
		std::iter_swap(first, last);
		while (comp(pivot, *--last));
		while (!comp(pivot, *++first));
	}

	Iter pivot_pos = last;
	*begin = PDQSORT_PREFER_MOVE(*pivot_pos);
	*pivot_pos = PDQSORT_PREFER_MOVE(pivot);

	return pivot_pos;
}


template<class Iter, class Compare, bool Branchless>
inline void pdqsort_loop(Iter begin, Iter end, Compare comp, int bad_allowed, bool leftmost = true) {
	typedef typename std::iterator_traits<Iter>::difference_type diff_t;

	// Use a while loop for tail recursion elimination.
	while (true) {
		diff_t size = end - begin;

		// Insertion sort is faster for small arrays.
		if (size < insertion_sort_threshold) {
			if (leftmost) ::insertion_sort(begin, end, comp);
			else unguarded_insertion_sort(begin, end, comp);
			return;
		}

		// Choose pivot as median of 3 or pseudomedian of 9.
		diff_t s2 = size / 2;
		if (size > ninther_threshold) {
			sort3(begin, begin + s2, end - 1, comp);
			sort3(begin + 1, begin + (s2 - 1), end - 2, comp);
			sort3(begin + 2, begin + (s2 + 1), end - 3, comp);
			sort3(begin + (s2 - 1), begin + s2, begin + (s2 + 1), comp);
			std::iter_swap(begin, begin + s2);
		}
		else sort3(begin + s2, begin, end - 1, comp);

		// If *(begin - 1) is the end of the right partition of a previous partition operation
		// there is no element in [begin, end) that is smaller than *(begin - 1). Then if our
		// pivot compares equal to *(begin - 1) we change strategy, putting equal elements in
		// the left partition, greater elements in the right partition. We do not have to
		// recurse on the left partition, since it's sorted (all equal).
		if (!leftmost && !comp(*(begin - 1), *begin)) {
			begin = partition_left(begin, end, comp) + 1;
			continue;
		}

		// Partition and get results.
		std::pair<Iter, bool> part_result =
			Branchless ? partition_right_branchless(begin, end, comp)
			: partition_right(begin, end, comp);
		Iter pivot_pos = part_result.first;
		bool already_partitioned = part_result.second;

		// Check for a highly unbalanced partition.
		diff_t l_size = pivot_pos - begin;
		diff_t r_size = end - (pivot_pos + 1);
		bool highly_unbalanced = l_size < size / 8 || r_size < size / 8;

		// If we got a highly unbalanced partition we shuffle elements to break many patterns.
		if (highly_unbalanced) {
			// If we had too many bad partitions, switch to heapsort to guarantee O(n log n).
			if (--bad_allowed == 0) {
				std::make_heap(begin, end, comp);
				std::sort_heap(begin, end, comp);
				return;
			}

			if (l_size >= insertion_sort_threshold) {
				std::iter_swap(begin, begin + l_size / 4);
				std::iter_swap(pivot_pos - 1, pivot_pos - l_size / 4);

				if (l_size > ninther_threshold) {
					std::iter_swap(begin + 1, begin + (l_size / 4 + 1));
					std::iter_swap(begin + 2, begin + (l_size / 4 + 2));
					std::iter_swap(pivot_pos - 2, pivot_pos - (l_size / 4 + 1));
					std::iter_swap(pivot_pos - 3, pivot_pos - (l_size / 4 + 2));
				}
			}

			if (r_size >= insertion_sort_threshold) {
				std::iter_swap(pivot_pos + 1, pivot_pos + (1 + r_size / 4));
				std::iter_swap(end - 1, end - r_size / 4);

				if (r_size > ninther_threshold) {
					std::iter_swap(pivot_pos + 2, pivot_pos + (2 + r_size / 4));
					std::iter_swap(pivot_pos + 3, pivot_pos + (3 + r_size / 4));
					std::iter_swap(end - 2, end - (1 + r_size / 4));
					std::iter_swap(end - 3, end - (2 + r_size / 4));
				}
			}
		}
		else {
			// If we were decently balanced and we tried to sort an already partitioned
			// sequence try to use insertion sort.
			if (already_partitioned && partial_insertion_sort(begin, pivot_pos, comp)
				&& partial_insertion_sort(pivot_pos + 1, end, comp)) return;
		}

		// Sort the left partition first using recursion and do tail recursion elimination for
		// the right-hand partition.
		pdqsort_loop<Iter, Compare, Branchless>(begin, pivot_pos, comp, bad_allowed, leftmost);
		begin = pivot_pos + 1;
		leftmost = false;
	}
}
}


template<class Iter, class Compare>
inline void pdqsort(Iter begin, Iter end, Compare comp) {
	if (begin == end) return;

#if __cplusplus >= 201103L
	pdqsort_detail::pdqsort_loop<Iter, Compare,
		pdqsort_detail::is_default_compare<typename std::decay<Compare>::type>::value &&
		std::is_arithmetic<typename std::iterator_traits<Iter>::value_type>::value>(
			begin, end, comp, pdqsort_detail::log2(end - begin));
#else
	pdqsort_detail::pdqsort_loop<Iter, Compare, false>(
		begin, end, comp, pdqsort_detail::log2(end - begin));
#endif
}

template<class Iter>
inline void pdqsort(Iter begin, Iter end) {
	typedef typename std::iterator_traits<Iter>::value_type T;
	pdqsort(begin, end, std::less<T>());
}

template<class Iter, class Compare>
inline void pdqsort_branchless(Iter begin, Iter end, Compare comp) {
	if (begin == end) return;
	pdqsort_detail::pdqsort_loop<Iter, Compare, true>(
		begin, end, comp, pdqsort_detail::log2(end - begin));
}

template<class Iter>
inline void pdqsort_branchless(Iter begin, Iter end) {
	typedef typename std::iterator_traits<Iter>::value_type T;
	pdqsort_branchless(begin, end, std::less<T>());
}


#undef PDQSORT_PREFER_MOVE

#endif




















~-----------------------------------------------~
C:\Users\Josh\Documents\Visual Studio 2017\Projects\Sorting\Sorting\pigeonholesort.h
~-----------------------------------------------~
#pragma once

//template<class T, class C>
//void pigeonholesort(T _First, T _Last, C compare) {
//	std::pair<T, T> minmax = std::minmax_element(_First, _Last, compare);
//	int min = *minmax.first, max = *minmax.second;
//	const int size = max - min + 1;
//	std::vector<int> holes(size, 0);
//
//	for (T _Pos = _First; _Pos < _Last; ++_Pos)
//		holes[*_Pos - min] += 1;
//
//	int count = 0;
//	for (T _Pos = _First; count < size; ++count) {
//		while (0 < holes[count]) {
//			*_Pos++ = count + min;
//			--holes[count];
//		}
//	}
//}

template<class T, class C>
void pigeonholesort(T _First, T _Last, C compare) {
	std::pair<T, T> minmax = std::minmax_element(_First, _Last, compare);
	typename T::value_type min = *minmax.first, max = *minmax.second;
	const int size = max - min + 1;
	typename T::value_type zero = *_First - *_First;
	std::vector<std::deque<typename T::value_type>> holes(size);

	for (T _Pos = _First; _Pos < _Last; ++_Pos) {
		typename T::value_type one = (*_Pos - *_Pos + 1);
		holes[*_Pos - min].push_back(*_Pos);
	}

	int count = 0;
	for (T _Pos = _First; count < size; ++count) {
		while (holes[count].size()) {
			*_Pos++ = holes[count].front();
			holes[count].pop_front();
		}
	}
}

template<class T>
void pigeonholesort(T _First, T _Last) {
	pigeonholesort(_First, _Last, std::less<>());
}




















~-----------------------------------------------~
C:\Users\Josh\Documents\Visual Studio 2017\Projects\Sorting\Sorting\poplarsort.h
~-----------------------------------------------~
/*
* The MIT License (MIT)
*
* Copyright (c) 2016-2018 Morwenn
*
* Permission is hereby granted, free of charge, to any person obtaining a copy
* of this software and associated documentation files (the "Software"), to deal
* in the Software without restriction, including without limitation the rights
* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
* copies of the Software, and to permit persons to whom the Software is
* furnished to do so, subject to the following conditions:
*
* The above copyright notice and this permission notice shall be included in
* all copies or substantial portions of the Software.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
* THE SOFTWARE.
*/
#ifndef CPPSORT_DETAIL_POPLAR_SORT_H_
#define CPPSORT_DETAIL_POPLAR_SORT_H_

////////////////////////////////////////////////////////////
// Headers
////////////////////////////////////////////////////////////
#include <iterator>
#include <type_traits>
#include <utility>
#include <vector>

namespace detail {

template<typename Unsigned>
constexpr auto hyperfloor(Unsigned n) -> Unsigned {
	constexpr auto bound = std::numeric_limits<Unsigned>::digits / 2;
	for (std::size_t i = 1; i <= bound; i <<= 1) {
		n |= (n >> i);
	}
	return n & ~(n >> 1);
}

template<typename RandomAccessIterator>
struct poplar {
	RandomAccessIterator begin, end;
	typename std::make_unsigned_t<typename RandomAccessIterator::difference_type> size;
	auto root() const -> RandomAccessIterator {
		auto res = end;
		return --res;
	}
};

template<typename RandomAccessIterator, typename Size, typename Compare>
auto sift(RandomAccessIterator first, Size size, Compare compare) -> void {
	if (size < 2) return;

	auto root = first + (size - 1);
	auto child_root1 = root - 1;
	auto child_root2 = first + (size / 2 - 1);

	while (true) {
		auto max_root = root;
		if (compare((*max_root), (*child_root1))) {
			max_root = child_root1;
		}
		if (compare((*max_root), (*child_root2))) {
			max_root = child_root2;
		}
		if (max_root == root) return;

		iter_swap(root, max_root);

		size /= 2;
		if (size < 2) return;

		root = max_root;
		child_root1 = root - 1;
		child_root2 = max_root - (size - size / 2);
	}
}

template<typename RandomAccessIterator, typename Compare>
auto relocate(const std::vector<poplar<RandomAccessIterator>>& poplars, Compare compare) -> void {
	// Find the poplar with the bigger root
	// We can assume that there is always at least one poplar
	auto last = std::prev(std::end(poplars));
	auto bigger = last;
	for (auto it = std::begin(poplars); it != last; ++it) {
		if (compare((*bigger->root()), (*it->root()))) {
			bigger = it;
		}
	}

	if (bigger != last) {
		iter_swap(bigger->root(), last->root());
		sift(bigger->begin, bigger->size, std::move(compare));
	}
}

template<typename RandomAccessIterator, typename Compare>
auto make_poplar(RandomAccessIterator first, RandomAccessIterator last, Compare compare) -> void {
	using poplar_size_t = std::make_unsigned_t<RandomAccessIterator::difference_type>;
	poplar_size_t size = std::distance(first, last);
	if (size < 16) {
		// A sorted collection is a valid poplar heap;
		// when the heap is small, using insertion sort
		// should be faster
		insertion_sort(std::move(first), std::move(last), std::move(compare));
		return;
	}

	auto middle = first + size / 2;
	make_poplar(first, middle, compare);
	make_poplar(middle, std::prev(last), compare);
	sift(std::move(first), size, std::move(compare));
}

template<typename RandomAccessIterator, typename Compare>
auto poplar_sort(RandomAccessIterator first, RandomAccessIterator last, Compare compare) -> void {
	using poplar_size_t = std::make_unsigned_t<RandomAccessIterator::difference_type>;

	// Size of the unsorted subsequence
	poplar_size_t size = std::distance(first, last);
	if (size < 2) return;

	std::vector<poplar<RandomAccessIterator>> poplars;
	poplars.reserve((unsigned)log2(size));

	//
	// Size of the biggest poplar in the array, which always is a number
	// of the form 2^n - 1
	//
	// It's worth noting that the +1 never causes problems: we're only
	// using unsigned integers, so when size is the biggest representable
	// value for its type, size + 1 == 0 thanks to the behaviour of
	// unsigned overflow; hyperfloor(0) == 0, and subtracting 1 to that
	// gives back the biggest representable value, which happens to be
	// a number of the form 2^n - 1
	//
	poplar_size_t poplar_size = hyperfloor(size + 1u) - 1u;

	// Make the poplar heap
	auto it = first;
	do {
		if (poplar_size_t(std::distance(it, last)) >= poplar_size) {
			auto begin = it;
			auto end = it + poplar_size;
			make_poplar(begin, end, compare);
			poplars.push_back({begin, end, poplar_size});
			it = end;
		}
		else {
			poplar_size = (poplar_size + 1) / 2 - 1;
		}
	} while (poplar_size > 0);

	// Sort the poplar heap
	do {
		// Find the greatest element, put it in place
		relocate(poplars, compare);
		// If the last poplar had one element, destroy it
		if (poplars.back().size == 1) {
			poplars.pop_back();
			if (poplars.size() == 0) return;
			if (poplars.size() == 1) {
				if (poplars.back().size == 1) return;
				auto& back = poplars.back();
				auto old_end = back.end;
				auto new_size = (back.size - 1) / 2;
				auto middle = back.begin + new_size;
				back.end = middle;
				back.size = new_size;
				poplars.push_back({middle, --old_end, new_size});
			}
		}
		else {
			auto& back = poplars.back();
			auto old_end = back.end;
			auto new_size = (back.size - 1) / 2;
			auto middle = back.begin + new_size;
			back.end = middle;
			back.size = new_size;
			poplars.push_back({middle, --old_end, new_size});
		}

	} while (poplars.size() > 1);
}
}

template<class T, class C>
inline void poplarsort(T _First, T _Last, C compare) {
	::detail::poplar_sort(_First, _Last, compare);
}

#endif // CPPSORT_DETAIL_POPLAR_SORT_H_





















~-----------------------------------------------~
C:\Users\Josh\Documents\Visual Studio 2017\Projects\Sorting\Sorting\quickmergesort.h
~-----------------------------------------------~
#pragma once

#include <algorithm>
#include <functional>
#include <iterator>
#include <utility>

namespace {
// Number of elements to sort under which we perform insertion sort
static constexpr int insertion_limit = 32;

template<
	typename BidirectionalIterator,
	typename Compare = std::less<>
>
auto insertion_sort(BidirectionalIterator first, BidirectionalIterator last,
					Compare compare = {})
	-> void {
	if (first == last) return;

	for (BidirectionalIterator cur = std::next(first); cur != last; ++cur) {
		BidirectionalIterator sift = cur;
		BidirectionalIterator sift_1 = std::prev(cur);

		// Compare first so we can avoid 2 moves for
		// an element already positioned correctly.
		if (compare(*sift, *sift_1)) {
			auto tmp = std::move(*sift);
			do {
				*sift-- = std::move(*sift_1);
			} while (sift != first && compare(tmp, *--sift_1));
			*sift = std::move(tmp);
		}
	}
}

template<
	typename InputIterator1,
	typename InputIterator2,
	typename OutputIterator,
	typename Compare = std::less<>
>
auto half_inplace_merge(InputIterator1 first1, InputIterator1 last1,
						InputIterator2 first2, InputIterator2 last2,
						OutputIterator result, Compare compare = {})
	-> void {
	for (; first1 != last1; ++result) {
		if (first2 == last2) {
			std::swap_ranges(first1, last1, result);
			return;
		}

		if (compare(*first2, *first1)) {
			std::iter_swap(result, first2);
			++first2;
		}
		else {
			std::iter_swap(result, first1);
			++first1;
		}
	}
	// first2 through last2 are already in the right spot
}

template<
	typename BidirectionalIterator,
	typename Compare = std::less<>
>
auto buffered_inplace_merge(BidirectionalIterator first, BidirectionalIterator middle,
							BidirectionalIterator last, BidirectionalIterator buffer,
							Compare compare = {})
	-> void {
	auto buffer_end = std::swap_ranges(first, middle, buffer);
	half_inplace_merge(buffer, buffer_end,
					   middle, last,
					   first, compare);
}

template<
	typename BidirectionalIterator,
	typename Compare = std::less<>
>
auto internal_mergesort(BidirectionalIterator first, BidirectionalIterator last,
						BidirectionalIterator buffer, Compare compare = {})
	-> void {
	if (std::distance(first, last) <= insertion_limit) {
		::insertion_sort(first, last, compare);
		return;
	}

	auto middle = first + (last - first) / 2; // make sure left is smaller
	internal_mergesort(first, middle, buffer, compare);
	internal_mergesort(middle, last, buffer, compare);

	while (first != middle && not compare(*middle, *first)) {
		++first;
	}
	if (first == middle) return;

	buffered_inplace_merge(first, middle, last, buffer, compare);
}

template<
	typename RandomAccessIterator,
	typename Compare = std::less<>
>
auto quickmergesort(RandomAccessIterator first, RandomAccessIterator last,
					Compare compare = {})
	-> void {
	auto size = std::distance(first, last);
	while (size > insertion_limit) {
		auto pivot = first + (2 * (size / 3) - 2);
		std::nth_element(first, pivot, last, compare);
		internal_mergesort(first, pivot, pivot, compare);

		first = pivot;
		size = std::distance(first, last);
	}
	::insertion_sort(first, last, compare);
}
}




~-----------------------------------------------~
C:\Users\Josh\Documents\Visual Studio 2017\Projects\Sorting\Sorting\quicksort.h
~-----------------------------------------------~
#pragma once

template<class T, class C>
inline void MedianOfThree(T _First, T _Mid, T _Last, C compare) {
	using std::iter_swap;
	if (compare(*_Last, *_First))
		iter_swap(_First, _Last);
	if (compare(*_Mid, *_First))
		iter_swap(_Mid, _First);
	if (compare(*_Last, *_Mid))
		iter_swap(_Last, _Mid);
}

template<class T, class C>
inline T part(T _First, T _Last, C compare) {
	T _Mid = _First + ((_Last - _First) >> 1);
	MedianOfThree(_First, _Mid, _Last, compare);
	++_First; --_Last;
	auto p = *_Mid;

	for (;;) {
		while (compare(*_First, p)) ++_First;
		while (compare(p, *_Last)) --_Last;

		if (_First >= _Last) return _Last;

		iter_swap(_First, _Last);
		++_First; --_Last;
	}
}

template<class T, class C>
inline void _quicksort(const T _First, const T _Last, C compare) {
	if (_Last > _First) {
		T _Med = part(_First, _Last, compare);
		_quicksort(_First, _Med, compare);
		_quicksort(_Med + 1, _Last, compare);
	}
}

template<class T>
inline void quicksort(const T _First, const T _Last) {
	_quicksort(_First, _Last - 1, std::less<>());
}

template<class T, class C>
inline void quicksort(const T _First, const T _Last, C compare) {
	_quicksort(_First, _Last - 1, compare);
}


























~-----------------------------------------------~
C:\Users\Josh\Documents\Visual Studio 2017\Projects\Sorting\Sorting\radixsort.h
~-----------------------------------------------~
#pragma once

#include <queue>

template<class T, class C>
void radixsort(T _First, T _Last, C compare, const int BASE) {
	std::vector<std::queue<T::value_type>> bucket(BASE);

	typename std::iterator_traits<T>::value_type _Max = *_First;
	for (T _Pos = _First; _Pos != _Last; ++_Pos)
		if (compare(_Max, *_Pos))
			_Max = *_Pos;


	for (unsigned power = 1; _Max != 0; _Max /= BASE, power *= BASE) {
		for (T _Pos = _First; _Pos != _Last; ++_Pos) {
			unsigned bucketNumber = (unsigned)((*_Pos / power) % BASE);
			bucket[bucketNumber].push(*_Pos);
		}

		auto _Pos = _First;
		for (int i = 0; i < BASE; i++) {
			for (int j = 0; !bucket[i].empty(); j++, ++_Pos) {
				*_Pos = bucket[i].front();
				bucket[i].pop();
			}
		}
	}
}

template<class T, class C>
void radixsort_LSD_10(T _First, T _Last, C compare) {
	radixsort(_First, _Last, compare, 10);
}

template<class T>
void radixsort_LSD_10(T _First, T _Last) {
	radixsort_LSD_10(_First, _Last, std::less<>(), 10);
}

template<class T, class C>
void radixsort_LSD_2(T _First, T _Last, C compare) {
	radixsort(_First, _Last, compare, 2);
}

template<class T>
void radixsort_LSD_2(T _First, T _Last) {
	radixsort_LSD_2(_First, _Last, std::less<>(), 2);
}

template<class T, class C>
void radixsort_LSD_4(T _First, T _Last, C compare) {
	radixsort(_First, _Last, compare, 4);
}

template<class T>
void radixsort_LSD_4(T _First, T _Last) {
	radixsort_LSD_4(_First, _Last, std::less<>(), 4);
}

template<class T, class C>
void radixsort_LSD_16(T _First, T _Last, C compare) {
	radixsort(_First, _Last, compare, 16);
}

template<class T>
void radixsort_LSD_16(T _First, T _Last) {
	radixsort_LSD_16(_First, _Last, std::less<>(), 16);
}

template<class T, class C>
void radixsort_LSD_32(T _First, T _Last, C compare) {
	radixsort(_First, _Last, compare, 32);
}

template<class T>
void radixsort_LSD_32(T _First, T _Last) {
	radixsort_LSD_32(_First, _Last, std::less<>(), 32);
}

template<class T>
inline int getMaxLog(T _First, T _Last, unsigned base) {
	int max = 0;
	auto _Pos = _First;
	double logbase = log(base);
	for (; _Pos != _Last; ++_Pos) 
		max = std::max((int)(log((unsigned)*_Pos) / logbase), max);
	return max;
}

template<class T>
inline int getDigit(T v, unsigned power, unsigned radix) {
	return (int)(v / pow(radix, power)) % radix;
}

template<class T>
inline void multiSwap(T _First, T _Last, unsigned pos, unsigned to) {	
	for (unsigned i = pos; i < to; i++) {
		iter_swap((_First + i), (_First + i + 1));
	}	
}

template<class T>
inline void inPlaceRadixLSDSort(T _First, T _Last, unsigned radix) {
	auto length = std::distance(_First, _Last);
	std::vector<typename T::value_type> vregs(radix - 1);

	unsigned maxpower = getMaxLog(_First, _Last, radix);

	int pos = 0;
	for (unsigned p = 0; p <= maxpower; p++) {
		for (unsigned i = 0; i < vregs.size(); i++) 
			vregs[i] = length - 1;

		pos = 0;
		for (int i = 0; i < length; i++) {
			int digit = getDigit(_First[pos], p, radix);

			if (digit == 0) {
				pos++;
			}
			else {
				multiSwap(_First, _Last, pos, vregs[digit - 1]);

				for (int j = digit - 1; j > 0; j--) {
					--vregs[j - 1];
				}
			}
		}
	}
}

template<class T, class C>
inline void inPlaceRadixLSDSortBase10(T _First, T _Last, C compare) {
	inPlaceRadixLSDSort(_First, _Last, 10);
}

template<class T, class C>
inline void inPlaceRadixLSDSortBase2(T _First, T _Last, C compare) {
	inPlaceRadixLSDSort(_First, _Last, 2);
}

template<class T, class C>
inline void inPlaceRadixLSDSortBase4(T _First, T _Last, C compare) {
	inPlaceRadixLSDSort(_First, _Last, 4);
}

template<class T, class C>
inline void inPlaceRadixLSDSortBase16(T _First, T _Last, C compare) {
	inPlaceRadixLSDSort(_First, _Last, 16);
}

//TODO implement https://cs.stackexchange.com/questions/93563/fast-stable-almost-in-place-radix-and-merge-sorts




~-----------------------------------------------~
C:\Users\Josh\Documents\Visual Studio 2017\Projects\Sorting\Sorting\regionssort.h
~-----------------------------------------------~
#define ENABLE_REGIONSSORT 0

#if ENABLE_REGIONSSORT

#ifndef _S_GRAPHBASED_INCLUDED
#define _S_GRAPHBASED_INCLUDED
#include <math.h>

#include <atomic>
#include <thread>

//#define ILP_SORT
#define MAXP 100
#define MAXBITS 100
#ifndef MAX_RADIX
#define MAX_RADIX 8

#define PARALLEL_FOR_THRESHOLD 4000

#endif
#if MAX_RADIX > 8
typedef uint16_t radixCustomType;
#elif MAX_RADIX <= 8 
typedef uint8_t radixCustomType;
#endif

#define BUCKETS (1 << MAX_RADIX)
#define MAXDEPTH (MAXBITS/MAX_RADIX)

#ifndef BLOCK_DIVIDE
#define BLOCK_DIVIDE 800000
#endif

#ifndef K_BOUND
#define K_BOUND 20000
#endif

#define SERIAL_THRESHOLD 20000


#define INSERTION_COARSEN

#define INSERTION_THRESHOLD 32

#define newA(__E,__n) (__E*) malloc((__n)*sizeof(__E))

typedef int sizeT;
typedef int intT;
typedef unsigned char uint8_t;
typedef unsigned int uintT;

#define parallel_for_swap for 
#define parallel_for for
#define parallel_for_1 for

static int getWorkers() { return 1; }

#define cilk_spawn
#define cilk_sync

long global_K;
long global_N;

namespace utils {
template <class E>
struct addF { E operator() (const E& a, const E& b) const { return a + b; } };
template <class E>
struct identityF { E operator() (const E& x) { return x; } };
template <class T>
static int log2Up(T i) {
	int a = 0;
	T b = i - 1;
	while (b != 0) { b = b >> 1; a++; }
	return a;
}
template <class E1, class E2>
struct firstF { E1 operator() (std::pair<E1, E2> a) { return a.first; } };
}

#define _BSIZE 2048
#define _SCAN_LOG_BSIZE 10
#define _SCAN_BSIZE (1 << _SCAN_LOG_BSIZE)

// This code is part of the Problem Based Benchmark Suite (PBBS)
// Copyright (c) 2011 Guy Blelloch and the PBBS team
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights (to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

template <class T>
struct _seq {
	T* A;
	long n;
	_seq() { A = NULL; n = 0; }
	_seq(T* _A, long _n) : A(_A), n(_n) {}
	void del() { free(A); }
};

template <class E>
void brokenCompiler__(intT n, E* x, E v) {
	parallel_for(intT i = 0; i<n; i++) x[i] = v;
}

template <class E>
static E* newArray(intT n, E v) {
	E* x = (E*)malloc(n * sizeof(E));
	brokenCompiler__(n, x, v);
	return x;
}

namespace sequence {

template <class intT>
struct boolGetA {
	bool* A;
	boolGetA(bool* AA) : A(AA) {}
	intT operator() (intT i) { return (intT)A[i]; }
};

template <class ET, class intT>
struct getA {
	ET* A;
	getA(ET* AA) : A(AA) {}
	ET operator() (intT i) { return A[i]; }
};

template <class IT, class OT, class intT, class F>
struct getAF {
	IT* A;
	F f;
	getAF(IT* AA, F ff) : A(AA), f(ff) {}
	OT operator () (intT i) { return f(A[i]); }
};

#define nblocks(_n,_bsize) (1 + ((_n)-1)/(_bsize))

#define granular_for(_i, _st, _ne, _thresh, _body) { \
  if ((_ne - _st) > _thresh) { \
    {parallel_for(intT _i=_st; _i < _ne; _i++) { \
      _body \
    }} \
  } else { \
    {for (intT _i=_st; _i < _ne; _i++) { \
      _body \
    }} \
  } \
  }

#define blocked_for(_i, _s, _e, _bsize, _body)  {	\
    intT _ss = _s;					\
    intT _ee = _e;					\
    intT _n = _ee-_ss;					\
    intT _l = nblocks(_n,_bsize);			\
    parallel_for (intT _i = 0; _i < _l; _i++) {		\
      intT _s = _ss + _i * (_bsize);			\
      intT _e = std::min(_s + (_bsize), _ee);			\
      _body						\
	}						\
  }

template <class OT, class intT, class F, class G>
OT reduceSerial(intT s, intT e, F f, G g) {
	OT r = g(s);
	for (intT j = s + 1; j < e; j++) r = f(r, g(j));
	return r;
}

template <class OT, class intT, class F, class G>
OT reduce(intT s, intT e, F f, G g) {
	intT l = nblocks(e - s, _SCAN_BSIZE);
	if (l <= 1) return reduceSerial<OT>(s, e, f, g);
	OT *Sums = newA(OT, l);
	blocked_for(i, s, e, _SCAN_BSIZE,
				Sums[i] = reduceSerial<OT>(s, e, f, g););
	OT r = reduce<OT>((intT)0, l, f, getA<OT, intT>(Sums));
	free(Sums);
	return r;
}

template <class OT, class intT, class F>
OT reduce(OT* A, intT n, F f) {
	return reduce<OT>((intT)0, n, f, getA<OT, intT>(A));
}

template <class OT, class intT, class F>
OT reduce(OT* A, intT s, intT e, F f) {
	return reduce<OT>(s, e, f, getA<OT, intT>(A));
}

template <class OT, class intT>
OT plusReduce(OT* A, intT n) {
	return reduce<OT>((intT)0, n, utils::addF<OT>(), getA<OT, intT>(A));
}

template <class intT>
intT sum(bool *In, intT n) {
	return reduce<intT>((intT)0, n, utils::addF<intT>(), boolGetA<intT>(In));
}

// g is the map function (applied to each element)
// f is the reduce function
// need to specify OT since it is not an argument
template <class OT, class IT, class intT, class F, class G>
OT mapReduce(IT* A, intT n, F f, G g) {
	return reduce<OT>((intT)0, n, f, getAF<IT, OT, intT, G>(A, g));
}

template <class ET, class intT, class F, class G>
intT maxIndexSerial(intT s, intT e, F f, G g) {
	ET r = g(s);
	intT k = 0;
	for (intT j = s + 1; j < e; j++) {
		ET v = g(j);
		if (f(v, r)) { r = v; k = j; }
	}
	return k;
}

template <class ET, class intT, class F, class G>
intT maxIndex(intT s, intT e, F f, G g) {
	intT l = nblocks(e - s, _SCAN_BSIZE);
	if (l <= 2) return maxIndexSerial<ET>(s, e, f, g);
	else {
		intT *Idx = newA(intT, l);
		blocked_for(i, s, e, _SCAN_BSIZE,
					Idx[i] = maxIndexSerial<ET>(s, e, f, g););
		intT k = Idx[0];
		for (intT j = 1; j < l; j++)
			if (f(g(Idx[j]), g(k))) k = Idx[j];
		free(Idx);
		return k;
	}
}

template <class ET, class intT, class F>
intT maxIndex(ET* A, intT n, F f) {
	return maxIndex<ET>((intT)0, n, f, getA<ET, intT>(A));
}

template <class ET, class intT, class F, class G>
ET scanSerial(ET* Out, intT s, intT e, F f, G g, ET zero, bool inclusive, bool back) {
	ET r = zero;

	if (inclusive) {
		if (back) for (long i = e - 1; i >= s; i--) Out[i] = r = f(r, g(i));
		else for (intT i = s; i < e; i++) Out[i] = r = f(r, g(i));
	}
	else {
		if (back)
			for (long i = e - 1; i >= s; i--) {
				ET t = g(i);
				Out[i] = r;
				r = f(r, t);
			}
		else
			for (intT i = s; i < e; i++) {
				ET t = g(i);
				Out[i] = r;
				r = f(r, t);
			}
	}
	return r;
}

template <class ET, class intT, class F>
ET scanSerial(ET *In, ET* Out, intT n, F f, ET zero) {
	return scanSerial(Out, (intT)0, n, f, getA<ET, intT>(In), zero, false, false);
}

// back indicates it runs in reverse direction
template <class ET, class intT, class F, class G>
ET scan(ET* Out, intT s, intT e, F f, G g, ET zero, bool inclusive, bool back) {
	intT n = e - s;
	intT l = nblocks(n, _SCAN_BSIZE);
	if (l <= 2) return scanSerial(Out, s, e, f, g, zero, inclusive, back);
	ET *Sums = newA(ET, nblocks(n, _SCAN_BSIZE));
	blocked_for(i, s, e, _SCAN_BSIZE,
				Sums[i] = reduceSerial<ET>(s, e, f, g););
	ET total = scan(Sums, (intT)0, l, f, getA<ET, intT>(Sums), zero, false, back);
	blocked_for(i, s, e, _SCAN_BSIZE,
				scanSerial(Out, s, e, f, g, Sums[i], inclusive, back););
	free(Sums);
	return total;
}

template <class ET, class intT, class F>
ET scan(ET *In, ET* Out, intT n, F f, ET zero) {
	return scan(Out, (intT)0, n, f, getA<ET, intT>(In), zero, false, false);
}

template <class ET, class intT, class F>
ET scanBack(ET *In, ET* Out, intT n, F f, ET zero) {
	return scan(Out, (intT)0, n, f, getA<ET, intT>(In), zero, false, true);
}

template <class ET, class intT, class F>
ET scanI(ET *In, ET* Out, intT n, F f, ET zero) {
	return scan(Out, (intT)0, n, f, getA<ET, intT>(In), zero, true, false);
}

template <class ET, class intT, class F>
ET scanIBack(ET *In, ET* Out, intT n, F f, ET zero) {
	return scan(Out, (intT)0, n, f, getA<ET, intT>(In), zero, true, true);
}

template <class ET, class intT>
ET plusScan(ET *In, ET* Out, intT n) {
	return scan(Out, (intT)0, n, utils::addF<ET>(), getA<ET, intT>(In),
		(ET)0, false, false);
}

template <class intT>
intT enumerate(bool *In, intT* Out, intT n) {
	return scan(Out, (intT)0, n, utils::addF<intT>(), boolGetA<intT>(In),
		(intT)0, false, false);
}


#define _F_BSIZE (2*_SCAN_BSIZE)

// sums a sequence of n boolean flags
// an optimized version that sums blocks of 4 booleans by treating
// them as an integer
// Only optimized when n is a multiple of 512 and Fl is 4byte aligned
template <class intT>
intT sumFlagsSerial(bool *Fl, intT n) {
	intT r = 0;
	if (n >= 128 && (n & 511) == 0 && ((long)Fl & 3) == 0) {
		int* IFl = (int*)Fl;
		for (int k = 0; k < (n >> 9); k++) {
			int rr = 0;
			for (int j = 0; j < 128; j++) rr += IFl[j];
			r += (rr & 255) + ((rr >> 8) & 255) + ((rr >> 16) & 255) + ((rr >> 24) & 255);
			IFl += 128;
		}
	}
	else for (intT j = 0; j < n; j++) r += Fl[j];
	return r;
}

template <class intT>
inline bool checkBit(long* Fl, intT i) {
	return Fl[i / 64] & ((long)1 << (i % 64));
}

template<class intT>
intT sumBitFlagsSerial(long* Fl, intT s, intT e) {
	intT res = 0;
	while (s % 64 && s < e) {
		if (checkBit(Fl, s)) ++res;
		s++;
	}
	if (s == e)
		return res;
	while (e % 64) {
		if (checkBit(Fl, e - 1)) ++res;
		e--;
	}
	// Do the rest with popcount
	intT be = e / 64;
	intT bs = s / 64;
	for (intT i = bs; i < be; ++i) {
		res += _popcnt64(Fl[i]);
	}
	return res;
}


template <class ET, class intT, class F>
_seq<ET> packSerial(ET* Out, bool* Fl, intT s, intT e, F f) {
	if (Out == NULL) {
		intT m = sumFlagsSerial(Fl + s, e - s);
		Out = newA(ET, m);
	}
	intT k = 0;
	for (intT i = s; i < e; i++) if (Fl[i]) Out[k++] = f(i);
	return _seq<ET>(Out, k);
}

template <class ET, class intT, class F>
void packSerial01(ET* Out0, ET* Out1, long* Fl, intT s, intT e, F f) {
	if (Out0 == NULL) {
		intT m = e - s - sumBitFlagsSerial(Fl, e, s);
		Out0 = newA(ET, m);
	}
	if (Out1 == NULL) {
		intT m = sumBitFlagsSerial(Fl, e, s);
		Out1 = newA(ET, m);
	}
	intT k0 = 0;
	intT k1 = 0;
	for (intT i = s; i < e; ++i) {
		if (checkBit(Fl, i))
			Out1[k1++] = f(i);
		else
			Out0[k0++] = f(i);
	}
}

template <class ET, class intT, class F>
void packSerial0(ET* Out, long* Fl, intT s, intT e, F f) {
	if (Out == NULL) {
		intT m = e - s - sumBitFlagsSerial(Fl, e, s);
		Out = newA(ET, m);
	}
	intT k = 0;
	for (intT i = s; i < e; i++) {
		if (!checkBit(Fl, i)) {
			Out[k++] = f(i);
		}
	}
}

template <class ET, class intT, class F>
void packSerial1(ET* Out, long* Fl, intT s, intT e, F f) {
	if (Out == NULL) {
		intT m = sumBitFlagsSerial(Fl, e, s);
		Out = newA(ET, m);
	}
	intT k = 0;
	for (intT i = s; i < e; i++) if (checkBit(Fl, i)) Out[k++] = f(i);
}

template <class T>
T prefixSumSerial(T* data, intT s, intT e) {
	T res = 0;
	for (intT i = s; i < e; ++i) {
		res += data[i];
		data[i] = res - data[i];
	}
	return res;
}

template <class T>
void addSerial(T* data, intT s, intT e, T val) {
	for (intT i = s; i < e; ++i)
		data[i] += val;
}

template <class T>
T prefixSum(T* data, intT s, intT e) {
	intT l = nblocks(e - s, _SCAN_BSIZE);
	if (l <= 1) return prefixSumSerial(data, s, e);
	T* sums = newA(T, l);
	blocked_for(i, s, e, _SCAN_BSIZE,
				sums[i] = prefixSumSerial<T>(data, s, e););
	T res = prefixSumSerial(sums, 0, l);
	blocked_for(i, s, e, _SCAN_BSIZE,
				addSerial(data, s, e, sums[i]););
	return res;
}

template <class ET, class intT, class F>
_seq<ET> pack(ET* Out, bool* Fl, intT s, intT e, F f) {
	intT l = nblocks(e - s, _F_BSIZE);
	if (l <= 1) return packSerial(Out, Fl, s, e, f);
	intT *Sums = newA(intT, l);
	blocked_for(i, s, e, _F_BSIZE, Sums[i] = sumFlagsSerial(Fl + s, e - s););
	intT m = plusScan(Sums, Sums, l);
	if (Out == NULL) Out = newA(ET, m);
	blocked_for(i, s, e, _F_BSIZE, packSerial(Out + Sums[i], Fl, s, e, f););
	free(Sums);
	return _seq<ET>(Out, m);
}

template <class ET, class intT, class F>
void splitSerial(ET* OutFalse, ET* OutTrue, bool* Fl, intT s, intT e, F f) {
	intT kT = 0;
	intT kF = 0;
	for (intT i = s; i < e; i++)
		if (Fl[i]) OutTrue[kT++] = f(i);
		else OutFalse[kF++] = f(i);
}

// Given a boolean array, splits so false (0) elements are at the bottom
// and true (1) elements are at the top of the output (of lenght e-s).
// As usual s is a start index, e is an end index and
// f is a function of type [s,e-1) -> ET
template <class ET, class intT, class F>
int split(ET* Out, bool*  Fl, intT s, intT e, F f) {
	intT l = nblocks(e - s, _F_BSIZE);
	intT *SumsTrue = newA(intT, l);
	blocked_for(i, s, e, _F_BSIZE, SumsTrue[i] = sumFlagsSerial(Fl + s, e - s););
	intT numTrue = plusScan(SumsTrue, SumsTrue, l);
	intT numFalse = (e - s) - numTrue;
	ET* OutTrue = Out + numFalse;
	blocked_for(i, s, e, _F_BSIZE,
				splitSerial(Out + _F_BSIZE * i - SumsTrue[i],
							OutTrue + SumsTrue[i],
							Fl, s, e, f););
	free(SumsTrue);
	return numFalse;
}

template <class ET, class intT, class F>
std::pair<_seq<ET>, _seq<ET> > pack2(ET* Out, bool* Fl1, bool* Fl2,
								intT s, intT e, F f) {
	intT l = nblocks(e - s, _F_BSIZE);
	intT *Sums1 = newA(intT, l);
	intT *Sums2 = newA(intT, l);
	blocked_for(i, s, e, _F_BSIZE,
				Sums1[i] = sumFlagsSerial(Fl1 + s, e - s);
	Sums2[i] = sumFlagsSerial(Fl2 + s, e - s););
	intT m1 = plusScan(Sums1, Sums1, l);
	intT m2 = plusScan(Sums2, Sums2, l);
	ET* Out1;
	ET* Out2;
	if (Out == NULL) {
		Out1 = newA(ET, m1);
		Out2 = newA(ET, m2);
	}
	else {
		Out1 = Out;
		Out2 = Out + m1;
	}
	blocked_for(i, s, e, _F_BSIZE,
				packSerial(Out1 + Sums1[i], Fl1, s, e, f);
	packSerial(Out2 + Sums2[i], Fl2, s, e, f););
	free(Sums1); free(Sums2);
	return std::pair<_seq<ET>, _seq<ET> >(_seq<ET>(Out1, m1), _seq<ET>(Out2, m2));
}
// Custom pack2 to be used with bitvector as flags (used for example for wavelet trees)
template <class ET, class intT, class F>
std::pair<_seq<ET>, _seq<ET> > pack2(ET* Out, long* Fl, intT s, intT e, F f) {
	// If interval empty
	if (s >= e)
		return std::pair<_seq<ET>, _seq<ET> >(_seq<ET>(Out, 0), _seq<ET>(Out, 0));
	intT l = nblocks(e - s, _F_BSIZE);
	intT *Sums1 = newA(intT, l);
	intT *Sums2 = newA(intT, l);
	blocked_for(i, s, e, _F_BSIZE,
				Sums2[i] = sumBitFlagsSerial(Fl, s, e); // count ones
	Sums1[i] = (e - s - Sums2[i]);); // calculate zeros
	intT m1 = plusScan(Sums1, Sums1, l);
	intT m2 = plusScan(Sums2, Sums2, l);
	ET* Out1;
	ET* Out2;
	if (Out == NULL) {
		Out1 = newA(ET, m1);
		Out2 = newA(ET, m2);
	}
	else {
		Out1 = Out;
		Out2 = Out + m1;
	}
	blocked_for(i, s, e, _F_BSIZE,
				packSerial01(Out1 + Sums1[i], Out2 + Sums2[i], Fl, s, e, f););
	//packSerial0(Out1+Sums1[i], Fl, s, e, f);
	//packSerial1(Out2+Sums2[i], Fl, s, e, f););
	free(Sums1); free(Sums2);
	return std::pair<_seq<ET>, _seq<ET> >(_seq<ET>(Out1, m1), _seq<ET>(Out2, m2));
}

template <class ET, class intT>
intT pack(ET* In, ET* Out, bool* Fl, intT n) {
	return pack(Out, Fl, (intT)0, n, getA<ET, intT>(In)).n;
}

template <class ET, class intT>
intT split(ET* In, ET* Out, bool* Fl, intT n) {
	return split(Out, Fl, (intT)0, n, getA<ET, intT>(In));
}

template <class ET, class intT>
std::pair<intT, intT> pack2(ET* In, ET* Out, bool* Fl1, bool* Fl2, intT n) {
	std::pair<_seq<ET>, _seq<ET> > r;
	r = pack2(Out, Fl1, Fl2, (intT)0, n, getA<ET, intT>(In));
	return std::pair<intT, intT>(r.first.n, r.second.n);
}

// Custom pack which takes an input and one flag array and puts all elements where 0 is set on the left side and alle the other elements on to the right
template <class ET, class intT>
intT pack2Bit(ET* In, ET* Out, long* Flags, intT s, intT e) {
	std::pair<_seq<ET>, _seq<ET> > r;
	r = pack2(Out, Flags, s, e, getA<ET, intT>(In));
	return r.first.n;
}

template <class ET, class intT>
_seq<ET> pack(ET* In, bool* Fl, intT n) {
	return pack((ET*)NULL, Fl, (intT)0, n, getA<ET, intT>(In));
}

template <class OT, class intT, class F>
_seq<OT> packMap(bool* Fl, intT n, F& f) {
	return pack((OT*)NULL, Fl, (intT)0, n, f);
}

template <class intT>
intT packIndex(intT* Out, bool* Fl, intT n) {
	return pack(Out, Fl, (intT)0, n, utils::identityF<intT>()).n;
}

template <class intT>
_seq<intT> packIndex(bool* Fl, intT n) {
	return pack((intT *)NULL, Fl, (intT)0, n, utils::identityF<intT>());
}

template <class ET, class intT, class PRED>
intT filterSerial(ET* In, ET* Out, intT n, PRED p) {
	intT k = 0;
	for (intT i = 0; i < n; i++)
		if (p(In[i])) Out[k++] = In[i];
	return k;
}

template <class ET, class intT, class PRED>
intT filter(ET* In, ET* Out, intT n, PRED p) {
	if (n < _F_BSIZE)
		return filterSerial(In, Out, n, p);
	bool *Fl = newA(bool, n);
	parallel_for(intT i = 0; i < n; i++) Fl[i] = (bool)p(In[i]);
	intT  m = pack(In, Out, Fl, n);
	free(Fl);
	return m;
}

// Avoids reallocating the bool array
template <class ET, class intT, class PRED>
intT filter(ET* In, ET* Out, bool* Fl, intT n, PRED p) {
	if (n < _F_BSIZE)
		return filterSerial(In, Out, n, p);
	parallel_for(intT i = 0; i < n; i++) Fl[i] = (bool)p(In[i]);
	intT  m = pack(In, Out, Fl, n);
	return m;
}

template <class ET, class intT, class PRED>
_seq<ET> filter(ET* In, intT n, PRED p) {
	bool *Fl = newA(bool, n);
	parallel_for(intT i = 0; i < n; i++) Fl[i] = (bool)p(In[i]);
	_seq<ET> R = pack(In, Fl, n);
	free(Fl);
	return R;
}

// Faster for a small number in output (about 40% or less)
// Destroys the input.   Does not need a bool array.
template <class ET, class intT, class PRED>
intT filterf(ET* In, ET* Out, intT n, PRED p) {
	intT b = _F_BSIZE;
	if (n < b)
		return filterSerial(In, Out, n, p);
	intT l = nblocks(n, b);
	b = nblocks(n, l);
	intT *Sums = newA(intT, l + 1);
	{
		parallel_for(intT i = 0; i < l; i++) {
			intT s = i * b;
			intT e = min(s + b, n);
			intT k = s;
			for (intT j = s; j < e; j++)
				if (p(In[j])) In[k++] = In[j];
			Sums[i] = k - s;
		}
	}
	intT m = plusScan(Sums, Sums, l);
	Sums[l] = m;
	{
		parallel_for(intT i = 0; i < l; i++) {
			ET* I = In + i * b;
			ET* O = Out + Sums[i];
			for (intT j = 0; j < Sums[i + 1] - Sums[i]; j++) {
				O[j] = I[j];
			}
		}
	}
	free(Sums);
	return m;
}

}

class SimpleBlock {
public:
	sizeT start;
	sizeT size;
	long counts[BUCKETS];
	long bucketEnds[BUCKETS];
	SimpleBlock() {

	}
	void init(sizeT offset, sizeT end) {
		this->start = offset;
		this->size = end - offset;
		for (int i = 0; i < BUCKETS; i++) {
			counts[i] = 0;
		}
	}
};

template <class E, class F>
void sortSimpleBlock(E* A, SimpleBlock *block, F extract) {

	struct metaData meta(extract._offset, true, false, block->counts);
	ska_sort(A + block->start, A + block->start + block->size, extract._f, meta);
	block->bucketEnds[0] = block->start + block->counts[0];
	for (int i = 1; i < BUCKETS; i++) {
		block->bucketEnds[i] = block->counts[i] + block->bucketEnds[i - 1];
	}
}

class Edge {
public:
	sizeT amount;
	sizeT start;
	int from;
	int to;

	Edge() {
		this->start = 0;
		this->amount = 0;
		this->from = 0;
		this->to = 0;
	}

	Edge(sizeT start, sizeT amount, int from, int to) {
		this->start = start;
		this->amount = amount;
		this->from = from;
		this->to = to;
	}



	void setEmpty() {
		amount = 0;
	}

	bool isTrivial() {
		return (from == to) || (amount <= 0);
	}

	void printEdge() {
#ifdef LONG_ARRAY
		printf("Edge: start: %ld, amount %ld, from %d -> to %d\n", start, amount, from, to);
#else
		printf("Edge: start: %d, amount %d, from %d -> to %d\n", start, amount, from, to);
#endif
	}

	bool compareEdge(Edge *anotherEdge) {
		if (this->from != anotherEdge->from) {
			return false;
		}
		if (this->to != anotherEdge->to) {
			return false;
		}
		if (this->amount != anotherEdge->amount) {
			return false;
		}
		if (this->start != anotherEdge->start) {
			return false;
		}
		return true;
	}
};

#define MAX_PARALLEL_EDGES (MAXP * BUCKETS + BUCKETS + 5)

struct Triangle {

	int from;
	int to;
	sizeT offset1;
	sizeT offset2;
	sizeT amount;
	Triangle() {

	}

	void setEmpty() {
		amount = 0;
	}
	bool isEmpty() {
		return amount == 0;
	}

	bool isTrivial() {
		return amount == 0 || to == from;
	}
	void printTriangle() {
		if (isEmpty()) {
			printf("Empty Triangle\n");
		}
#ifndef LONG_ARRAY
		printf("Triangle: (%d -> %d) amount %d \n", from, to, amount);
		printf("offset1 : %d offset2 %d\n", offset1, offset2);
#endif
	}
};

//template<class sizeT>
void makeTriangle(Triangle  *triangle, Edge  *firstEdge, Edge * secondEdge, sizeT firstRemaining, sizeT secondRemaining) {

	triangle->from = firstEdge->from;

	triangle->to = secondEdge->to;

	triangle->offset1 = firstEdge->start + firstEdge->amount - firstRemaining;
	triangle->offset2 = secondEdge->start + secondEdge->amount - secondRemaining;
	sizeT amount = std::min(firstRemaining, secondRemaining);
	triangle->amount = amount;
}

void makeTrianglefromDynamicEdge(Triangle  *triangle, Edge  *firstEdge, Edge * secondEdge, sizeT amount) {
	triangle->from = firstEdge->from;
	triangle->to = secondEdge->to;
	triangle->offset1 = firstEdge->start;
	triangle->offset2 = secondEdge->start;
	triangle->amount = amount;
}

template <class E>
void serialExecuteTriangle(E *A, Triangle  *triangle) {
	E* start = A + triangle->offset2;
	std::swap_ranges(start, start + triangle->amount, A + triangle->offset1);
}

template <class E>
void parallelExecuteTriangle(E *A, Triangle  *triangle) {
	parallel_for_swap(sizeT index = 0; index < triangle->amount; index++) {
		sizeT from = triangle->offset2 + index;
		sizeT to = triangle->offset1 + index;
		E temp = A[from];
		A[from] = A[to];
		A[to] = temp;
	}

}

template <class E>
void executeTriangle(E *A, Triangle  *triangle) {

	if (triangle->amount < PARALLEL_FOR_THRESHOLD) {
		serialExecuteTriangle(A, triangle);
	}
	else {
		parallelExecuteTriangle(A, triangle);
	}

}

void getPrefixSum(std::vector<uint8_t> &input, std::vector<uint8_t> &res) {
	long sum = 0;
	for (int i = 0; i < input.size(); i++) {
		res[i] = sum;
		sum += input[i];
	}
	res[input.size()] = sum;
}

void getPrefixSum(uint8_t *input, uint8_t *res, int size) {
	long sum = 0;
	for (int i = 0; i < size; i++) {
		res[i] = sum;
		sum += input[i];
	}
	res[size] = sum;
}

void getSerialPrefixSum(Edge  ** input, sizeT *res, int size) {
	sizeT sum = 0;
	for (int i = 0; i < size; i++) {
		res[i] = sum;
		sum += input[i]->amount;
	}
	res[size] = sum;
}


void getParallelPrefixSum(Edge  ** input, sizeT *res, int size) {
	parallel_for_swap(int i = 0; i < size; i++) {
		res[i] = input[i]->amount;
	}
	long total = sequence::plusScan(res, res, size);
	res[size] = total;
}


void getSerialPrefixSumReal(Edge  * input, sizeT *res, int size) {
	sizeT sum = 0;
	for (int i = 0; i < size; i++) {
		res[i] = sum;
		sum += input[i].amount;
	}
	res[size] = sum;
}

void getParallelPrefixSumReal(Edge  * input, sizeT *res, int size) {
	parallel_for_swap(int i = 0; i < size; i++) {
		res[i] = input[i].amount;
	}
	sizeT total = sequence::plusScan(res, res, size);
	res[size] = total;
}

void getPrefixSum(std::vector<Edge*> &input, std::vector<sizeT> &res) {
	sizeT sum = 0;
	for (int i = 0; i < input.size(); i++) {
		res.push_back(sum);
		sum += input[i]->amount;
	}
	res.push_back(sum);
}

void getPrefixSumLong(sizeT *input, sizeT *res, int size) {
	long sum = 0;
	for (int i = 0; i < size; i++) {
		res[i] = sum;
		sum += input[i];
	}
	res[size] = sum;
}

void getPrefixSum(sizeT offset, sizeT* count, sizeT* prefixSum, int length) {
	prefixSum[0] = offset + count[0];
	for (int i = 1; i < length; i++) {
		prefixSum[i] = count[i] + prefixSum[i - 1];
	}
}

void printPrefixSum(std::vector<sizeT> ps) {
#ifdef LONG_ARRAY
	printf("ps size %lu\n", ps.size());
	for (int i = 0; i < ps.size(); i++) {
		printf("%ld |", ps[i]);
	}
#else
	printf("ps size %lu\n", ps.size());
	for (int i = 0; i < ps.size(); i++) {
		printf("%d |", ps[i]);
	}
#endif
	printf("\n");
}

class CycleGraph {

public:
	std::vector<Edge > graphFromEdges[BUCKETS];


	CycleGraph() {
		for (int bucket = 0; bucket < BUCKETS; bucket++) {
			graphFromEdges[bucket].clear();
		}
	}

	void addEdge(Edge  *e) {
		if (e->isTrivial()) {
			return;
		}
		graphFromEdges[e->from].push_back(*e);
	}

	Edge * getNextEdge(int node) {
		int sz = graphFromEdges[node].size();
		while (sz && graphFromEdges[node][sz - 1].amount == 0) {
			sz--;
		}
		if (sz == 0) {
			return NULL;
		}
		graphFromEdges[node].resize(sz);
		return &graphFromEdges[node][sz - 1];
	}

	bool hasEdges(int node) {
		return getNextEdge(node) != NULL;
	}
	class CyclePlan {
	public:
		int length;
		sizeT starts[BUCKETS];
		sizeT amount;
		CyclePlan() {
			length = 0;
		}
		template <class E>
		void executeCycle(E* A) {
			if (amount < PARALLEL_FOR_THRESHOLD) {
				for (sizeT pos = 0; pos < amount; pos++) {
					E save = A[starts[length - 1] + pos];
					for (int i = length - 1; i > 0; i--) {
						A[starts[i] + pos] = A[starts[i - 1] + pos];
					}
					A[starts[0] + pos] = save;
				}
			}
			else {
				parallel_for_swap(sizeT pos = 0; pos < amount; pos++) {
					E save = A[starts[length - 1] + pos];
					for (int i = length - 1; i > 0; i--) {
						A[starts[i] + pos] = A[starts[i - 1] + pos];
					}
					A[starts[0] + pos] = save;
				}
			}
		}
	};
	class Cycle {
	public:
		Edge * path[BUCKETS];
		int visited[BUCKETS];
		int pathIndex;
		sizeT amount;
		int cycle_start;
		int cycle_length;
		int currentNode;
		CyclePlan cyclePlan;
		Cycle(int node) {
			currentNode = node;
			pathIndex = 0;
			cycle_start = 0;
			cycle_length = 0;
			amount = 0;
			for (int i = 0; i < BUCKETS; i++) {
				visited[i] = -1;
			}
		}

		bool getNextCycle(CycleGraph *graphcycle, CyclePlan *cyclePlan) {
			if (!graphcycle->hasEdges(currentNode)) {
				//we are done with this node.
				return false;
			}

			do {
				visited[currentNode] = pathIndex;
				path[pathIndex] = graphcycle->getNextEdge(currentNode);
				currentNode = path[pathIndex]->to;
				pathIndex++;
			} while (visited[currentNode] == -1);



			cycle_start = visited[currentNode];
			amount = path[cycle_start]->amount;
			for (int i = cycle_start; i < pathIndex; i++) {
				amount = std::min(amount, path[i]->amount);
				visited[path[i]->from] = -1;
				cyclePlan->starts[i - cycle_start] = path[i]->start;
			}
			cyclePlan->amount = amount;
			cyclePlan->length = pathIndex - cycle_start;
			cycle_length = pathIndex - cycle_start;
			pathIndex = cycle_start;
			return true;
		}

		void consumeCycle() {
			parallel_for(int i = cycle_start; i < cycle_start + cycle_length; i++) {
				path[i]->amount -= amount;
				path[i]->start += amount;
			}
		}

	};

	void createCycleGraph(int buckets, sizeT P, SimpleBlock *blocks, const long *countryEnds) {
		int currentCountry = 0;
		sizeT currentRegionStart = 0;
		for (sizeT currentBlock = 0; currentBlock < P; currentBlock++) {
			for (int currentValue = 0; currentValue < BUCKETS; currentValue++) {
				while (currentCountry < BUCKETS) {
					if (blocks[currentBlock].bucketEnds[currentValue] <= countryEnds[currentCountry]) {
						//if country is a superset of the current bucket inside current block.
						//both sides of comparison are exclusive.

						sizeT currentRegionEnd = blocks[currentBlock].bucketEnds[currentValue];
						Edge  edge = Edge(currentRegionStart, currentRegionEnd - currentRegionStart, currentCountry, currentValue);
						addEdge(&edge);
						currentRegionStart = currentRegionEnd;
						break;
					}
					else {
						// some parts of the bucket is not included in the country.
						// Region will include the intersection of the country and the bucket.
						sizeT currentRegionEnd = countryEnds[currentCountry];
						Edge  edge = Edge(currentRegionStart, currentRegionEnd - currentRegionStart, currentCountry, currentValue);
						addEdge(&edge);
						currentRegionStart = currentRegionEnd;
						currentCountry++;
					}
				}
			}
		}

	}
	void printGraph() {
		printf("No Printing Function!\n");
	}

	void verifyGraph(int node) {
		std::vector<Edge *> toEdges;
		std::vector<Edge *> fromEdges;
		sizeT toSum = 0;
		for (int i = 0; i < toEdges.size(); i++) {
			if (toEdges[i]->isTrivial())
				continue;
			toSum += toEdges[i]->amount;
		}
		sizeT fromSum = 0;
		for (int i = 0; i < fromEdges.size(); i++) {
			if (fromEdges[i]->isTrivial())
				continue;
			fromSum += fromEdges[i]->amount;
		}
		if (toSum != fromSum) {
			printf("Graph Invariants don't hold!\n");
			std::vector<sizeT> toPrefixSum;
			std::vector<sizeT> fromPrefixSum;
			getPrefixSum(toEdges, toPrefixSum);
			getPrefixSum(fromEdges, fromPrefixSum);
			printPrefixSum(toPrefixSum);
			printPrefixSum(fromPrefixSum);
			while (1);
		}

	}


};

class EdgeListGraph {

public:
	std::vector< Edge > graphToEdges[BUCKETS];
	std::vector< Edge > graphFromEdges[BUCKETS];
	int * order;
	int * rank;

	EdgeListGraph(int P, int *rank, int *order) {
		for (int bucket = 0; bucket < BUCKETS; bucket++) {
			graphToEdges[bucket].clear();
			graphFromEdges[bucket].clear();
		}
		this->rank = rank;
		this->order = order;
	}

	void addEdge(Edge  *e) {
		if (e->isTrivial()) {
			return;
		}


		if (rank[e->to] < rank[e->from]) {
			graphToEdges[e->to].push_back(*e);
		}
		else {
			graphFromEdges[e->from].push_back(*e);
		}
	}

	void getFromEdgesSubgraph(int node, std::vector< Edge *> &res) {
		res.clear();
		for (int i = 0; i < graphFromEdges[node].size(); i++) {
			res.push_back(&graphFromEdges[node][i]);
		}
	}

	void getToEdgesSubgraph(int node, std::vector< Edge  *> &res) {
		res.clear();
		for (int i = 0; i < graphToEdges[node].size(); i++) {
			res.push_back(&graphToEdges[node][i]);
		}
	}

	void printGraph() {
		printf("Printing Graph!\n");
		printf("Edges Counts\n");
		std::vector < Edge  *> parallelFromEdges;
		std::vector < Edge  *> parallelToEdges;
		for (int node = 0; node < BUCKETS; node++) {
			printf("vector for node %d\n", node);
			this->getFromEdgesSubgraph(node, parallelFromEdges);
			this->getToEdgesSubgraph(node, parallelToEdges);
		}

	}


	void createParallelGraph(long buckets, long P, SimpleBlock *blocks, const long *countryEnds) {
		int currentCountry = 0;
		long currentRegionStart = 0;
		for (int currentBlock = 0; currentBlock < P; currentBlock++) {
			for (int currentValue = 0; currentValue < BUCKETS; currentValue++) {

				while (currentCountry < BUCKETS) {
					if (blocks[currentBlock].bucketEnds[currentValue] <= countryEnds[currentCountry]) {
						//if country is a superset of the current bucket inside current block.
						//both sides of comparison are exclusive.

						long currentRegionEnd = blocks[currentBlock].bucketEnds[currentValue];
						Edge  edge = Edge(currentRegionStart, currentRegionEnd - currentRegionStart, currentCountry, currentValue);



						addEdge(&edge);
						currentRegionStart = currentRegionEnd;
						break;
					}
					else {
						// some parts of the bucket is not included in the country.
						// Region will include the intersection of the country and the bucket.
						long currentRegionEnd = countryEnds[currentCountry];

						Edge  edge = Edge(currentRegionStart, currentRegionEnd - currentRegionStart, currentCountry, currentValue);
						addEdge(&edge);
						currentRegionStart = currentRegionEnd;
						currentCountry++;
					}
				}
			}
		}

	}

	static sizeT getAmount(Edge  * e) {
		return e->amount;
	}

	static sizeT getAmount(Edge  &e) {
		return e.amount;
	}

	static  Edge * getL(Edge  *e) {
		return e;
	}
	static  Edge * getL(Edge  &e) {
		return &e;
	}

	void matchEdgesToTriangle(Edge * fromEdge, Edge  * toEdge, Triangle * result) {
		sizeT toRemaining = toEdge->amount;
		sizeT fromRemaining = fromEdge->amount;
		sizeT min;
		if (toRemaining < fromRemaining) {
			min = toRemaining;
		}
		else {
			min = fromRemaining;
		}
		makeTrianglefromDynamicEdge(result, toEdge, fromEdge, min);
		toEdge->amount -= min;
		toEdge->start += min;
		fromEdge->amount -= min;
		fromEdge->start += min;
	}


	template<class T>
	int extractTriangles(std::vector<T> &fromRegions, int fromSize, std::vector<T> &toRegions, int toSize, Triangle * triangles, int triangles_count) {

		if (fromSize == 0 || toSize == 0) {
			return triangles_count;
		}

		int fromP = 0;
		int toP = 0;

		while (true) {

			for (; toP < toSize && !getAmount(toRegions[toP]); toP++) {

			}

			for (; fromP < fromSize && !getAmount(fromRegions[fromP]); fromP++) {

			}

			if (toP == toSize || fromP == fromSize) {
				break;
			}

			matchEdgesToTriangle(getL(fromRegions[fromP]), getL(toRegions[toP]), &triangles[triangles_count]);
			triangles_count = triangles_count + 1;
		}

		return triangles_count;
	}


	int extractTriangles(std::vector< Edge > &fromRegions, std::vector< Edge > &toRegions, Triangle * triangles, int triangles_count) {
		return extractTriangles(fromRegions, (int)fromRegions.size(), toRegions, (int)toRegions.size(), triangles, triangles_count);

	}

	int extractTriangles(std::vector< Edge *> &fromRegions, std::vector< Edge *> &toRegions, Triangle * triangles, int triangles_count) {
		return extractTriangles(fromRegions, (int)fromRegions.size(), toRegions, (int)toRegions.size(), triangles, triangles_count);

	}

	int getEdgesCount(int node) {
		return graphToEdges[node].size() + graphFromEdges[node].size();
	}

	void deleteNode(int node) {
		std::vector< Edge >().swap(graphToEdges[node]);
		std::vector< Edge >().swap(graphFromEdges[node]);
	}



	void extractNode2(int node, Triangle * triangles, int* triangles_count) {
		std::vector< Edge > fromRegions;
		fromRegions = graphFromEdges[node];
		std::vector< Edge > toRegions;
		toRegions = graphToEdges[node];


#ifdef EXTRACT_2CYCLES
		///////////////////////EXTRACTING two-cycles START/////////////////////////
		vector< Edge *> edgesPerNodeFrom[BUCKETS];
		vector< Edge *> edgesPerNodeTo[BUCKETS];
		for (int i = 0; i < fromRegions.size(); i++) {
			edgesPerNodeFrom[fromRegions[i].to].push_back(&fromRegions[i]);
		}

		for (int i = 0; i < toRegions.size(); i++) {
			edgesPerNodeTo[toRegions[i].from].push_back(&toRegions[i]);
		}

		if (toRegions.size() < BUCKETS - (rank[node] + 1)) {
			for (int i = 0; i < toRegions.size(); i++) {
				int bucket = toRegions[i].from;
				*triangles_count = extractTriangles(edgesPerNodeFrom[bucket], edgesPerNodeTo[bucket], triangles, *triangles_count);
				edgesPerNodeFrom[bucket].clear();
				edgesPerNodeTo[bucket].clear();
			}

		}
		else {
			if (fromRegions.size() < BUCKETS - (rank[node] + 1)) {
				for (int i = 0; i < fromRegions.size(); i++) {
					int bucket = fromRegions[i].to;
					*triangles_count = extractTriangles(edgesPerNodeFrom[bucket], edgesPerNodeTo[bucket], triangles, *triangles_count);
					edgesPerNodeFrom[bucket].clear();
					edgesPerNodeTo[bucket].clear();
				}
			}
			else {
				for (int index = rank[node] + 1; index < BUCKETS; index++) {
					int bucket = order[index];
					*triangles_count = extractTriangles(edgesPerNodeFrom[bucket], edgesPerNodeTo[bucket], triangles, *triangles_count);
				}
			}
		}
		///////////////////////EXTRACTING two-cycles END/////////////////////////
#endif
		*triangles_count = extractTriangles(fromRegions, toRegions, triangles, *triangles_count);
	}
	void consumeTriangle(Triangle  *triangle) {

		if (triangle->isTrivial()) {
			return;
		}

		Edge  edge(triangle->offset1, triangle->amount, triangle->from, triangle->to);

		if (rank[triangle->to] < rank[triangle->from]) {
			graphToEdges[triangle->to].push_back(edge);
		}
		else {
			graphFromEdges[triangle->from].push_back(edge);
		}
	}

	~EdgeListGraph() {
		for (int bucket = 0; bucket < BUCKETS; bucket++) {
			graphToEdges[bucket].clear();
			graphFromEdges[bucket].clear();
		}
	}

};


template <class E, class F>
void radixSortOneLevel(E* A, sizeT n, int doneOffset, F f, sizeT processors, int depth);

struct SortedBucket {
	int bucket;
	sizeT size;
};

sizeT sortedBucketSize(SortedBucket sb) {
	return -sb.size;
}

template <class E, class F>
void insertion_sort(E* A, long n, F f) {
	for (int i = 0; i < n; i++) {
		E x = A[i];
		int j = i - 1;
		while (j >= 0 && f(A[j]) > f(x)) {
			A[j + 1] = A[j];
			j--;
		}
		A[j + 1] = x;
	}
	return;
}

template< class _Type, typename F>
inline void insertionSortSimilarToSTLnoSelfAssignment(_Type* a, unsigned long a_size, F extract) {

	for (unsigned long i = 1; i < a_size; i++) {
		if (a[i] < a[i - 1])		// no need to do (j > 0) compare for the first iteration
		{
			_Type currentElement = a[i];
			auto compare = extract(currentElement);
			a[i] = a[i - 1];
			unsigned long j;
			for (j = i - 1; j > 0 && compare < extract(a[j - 1]); j--) {
				a[j] = a[j - 1];
			}
			a[j] = currentElement;	// always necessary work/write
		}
		  // Perform no work at all if the first comparison fails - i.e. never assign an element to itself!
	}
}

template <class E, class F, class Z>
bool multiBitSwapBasedSort(E *A, sizeT n, int buckets, sizeT K, long *internalCounts, F extract, Z f, int depth, int doneOffset) {

	if (n < SERIAL_THRESHOLD || K == 1) {
#ifdef INSERTION_COARSEN
		if (n < INSERTION_THRESHOLD) {
			insertionSortSimilarToSTLnoSelfAssignment(A, n, f);
			return false;
		}
#endif
		// if this is the last recursion, we don't care about counts of buckets
		if (extract._offset == 0) {
			internalCounts = NULL;
		}

#ifdef ILP_SORT  
		if (n > 1024) {
			struct metaData meta(extract._offset, true, false, internalCounts);
			ska_sort(A, A + n, f, meta);
			return meta.done;
		}
		else {
			_RadixSort_Unsigned_PowerOf2Radix_1(A, internalCounts, (long)n, BUCKETS, extract);
		}
		return true;
#else 
		return true;
#endif 


	}


	SimpleBlock *blocks = new SimpleBlock[K];
	parallel_for_1(int i = 0; i < K; i++) {
		unsigned long start = (long)i * n / K;
		unsigned long end = ((long)(i + 1) * n) / K;
		blocks[i].init(start, end);
		sortSimpleBlock(A, &blocks[i], extract);
	}

	parallel_for_1(int bucket = 0; bucket < BUCKETS; bucket++) {
		internalCounts[bucket] = 0;
		for (sizeT i = 0; i < K; i++) {
			internalCounts[bucket] += blocks[i].counts[bucket];
		}
	}

	long countryEnds[BUCKETS];

	countryEnds[0] = internalCounts[0];
	for (int i = 1; i < BUCKETS; i++) {
		countryEnds[i] = internalCounts[i] + countryEnds[i - 1];
	}

	int order[BUCKETS];
	int rank[BUCKETS];
	SortedBucket sbs[BUCKETS];
	for (int i = 0; i < BUCKETS; i++) {
		sbs[i].bucket = i;
		sbs[i].size = internalCounts[i];
	}
	insertion_sort(sbs, BUCKETS, sortedBucketSize);
	sizeT nextKs[BUCKETS];
	int countNonZero = 0;
	sizeT local = K;

	const long max_triangles = (K * BUCKETS + BUCKETS + 1) + BUCKETS;
	Triangle  * triangles = new Triangle[max_triangles];

	for (int i = 0; i < BUCKETS; i++) {
		order[i] = sbs[i].bucket;
		rank[order[i]] = i;
		sizeT count = internalCounts[order[i]];
		sizeT nextK = (sizeT)ceil((1.0 * (global_K * count) / global_N));
		nextKs[order[i]] = nextK;
		if (count) {
			countNonZero++;
		}
	}

#ifdef CYCLE
	CycleGraph cycleGraph;
	cycleGraph.createCycleGraph(BUCKETS, K, blocks, countryEnds);
	vector<CycleGraph::CyclePlan> cyclePlan(BUCKETS * K + BUCKETS + 1);

	for (int index = 0; index < countNonZero; index++) {
		int node = order[index];
		CycleGraph::Cycle cycle(node);
		int planc = 0;
		while (cycle.getNextCycle(&cycleGraph, &cyclePlan[planc++])) {
			cycle.consumeCycle();
		}
		parallel_for_1(int i = 0; i < planc - 1; i++) {
			cyclePlan[i].executeCycle(A);
		}
		sizeT startOfCountry;
		if (node == 0) {
			startOfCountry = 0;
		}
		else {
			startOfCountry = countryEnds[node - 1];
		}
		sizeT nextK = nextKs[node];
		if (internalCounts[node] < INSERTION_THRESHOLD) {
			radixSortOneLevel(A + startOfCountry, internalCounts[node], doneOffset, f, nextK, depth + 1);
		}
		else {
			cilk_spawn radixSortOneLevel(A + startOfCountry, internalCounts[node], doneOffset, f, nextK, depth + 1);
		}
	}
	cilk_sync;
	delete blocks;
	return false;
#else


	EdgeListGraph graph(K, rank, order);
	graph.createParallelGraph(BUCKETS, K, blocks, countryEnds);

	int triangles_count;


	for (int index = 0; index < countNonZero; index++) {
		int node = order[index];
		triangles_count = 0;
		graph.extractNode2(node, triangles, &triangles_count);
		parallel_for_1(int i = 0; i < triangles_count; i++) {
			executeTriangle(A, &triangles[i]);
		}

		sizeT startOfCountry;
		if (node == 0) {
			startOfCountry = 0;
		}
		else {
			startOfCountry = countryEnds[node - 1];
		}

		sizeT nextK = nextKs[node];
		if (internalCounts[node] < INSERTION_THRESHOLD) {

			radixSortOneLevel(A + startOfCountry, internalCounts[node], doneOffset, f, nextK, depth + 1);
		}
		else {
			cilk_spawn radixSortOneLevel(A + startOfCountry, internalCounts[node], doneOffset, f, nextK, depth + 1);

		}

		graph.deleteNode(node);

		for (int i = 0; i < triangles_count; i++) {
			graph.consumeTriangle(&triangles[i]);
		}

	}

	cilk_sync;

	delete triangles;
	delete blocks;
#endif
	return false;
}
#endif

template <class E, class F, class K>
K findMaxHelper(E* A, sizeT n, F f, sizeT P, K t) {

	K* temp = (K*)malloc(sizeof(E) * (P + 1));
	parallel_for(unsigned long i = 0; i <P; i++) {
		unsigned long start = i * (long)n / P;
		unsigned long end = ((long)(i + 1) * n) / P;
		K local_max = 0;
		for (; start < end; start++) {
			K current = f(A[start]);
			if (current > local_max) {
				local_max = current;
			}

		}
		temp[i] = local_max;
	}

	K global_max = temp[0];

	for (int i = 0; i < P; i++) {
		if (temp[i] > global_max) {
			global_max = temp[i];
		}
	}
	free(temp);
	return global_max;
}

template <class E, class F, class K>
K findMax(E* A, sizeT n, F f, K temp) {
	K maxV = findMaxHelper(A, n, f, (sizeT)1000 * getWorkers(), temp);
	return maxV;
}

int roundUpToRadixMultiple(int num) {
	if (num % MAX_RADIX == 0) {
		return num;
	}
	else {
		return ((num / MAX_RADIX) + 1)  * MAX_RADIX;
	}
}

int roundUpBits(int num) {

	int multipleOfRadix = roundUpToRadixMultiple(num);
#ifdef BITS_HACK
#if MAX_RADIX == 8
	if (multipleOfRadix >= num + 2) {
		return num + 2;
	}
#endif
#endif 
	return multipleOfRadix;
}

// a function to extract "bits" bits starting at bit location "offset"
template <class E, class F>
struct eBits {
	F _f;  int _mask;  intT _offset;
	eBits(int bits, intT offset, F f) : _mask((1 << bits) - 1),
		_offset(offset), _f(f) {}
	inline intT operator() (E p) { return (_mask&(_f(p)) >> _offset); }
};

template <class E, class F>
void radixSortOneLevel(E* A, sizeT n, int doneOffset, F f, sizeT K, int depth) {
	if (doneOffset <= 0 || n <= 1) {
		return;
	}

	int bits = MAX_RADIX;
	int buckets = BUCKETS;

	int start = std::max(doneOffset - bits, 0);


	bool needToRecurse = true;


	long localCounts[BUCKETS];
	needToRecurse = multiBitSwapBasedSort(A, n, buckets, K, localCounts, eBits<E, F>(doneOffset - start, start, f), f, depth, start);

	if (start <= 0)
		return;

	if (needToRecurse) {
		long sum = 0;
		for (int i = 0; i < BUCKETS; i++) {
			radixSortOneLevel(A + sum, localCounts[i], start, f, (sizeT)1, depth + 1);
			sum += localCounts[i];

		}

	}

	}

template <class E, class F>
void radixSortRoutine(sizeT index, E* A, sizeT n, int doneOffset, F f) {
	sizeT K;
#ifdef CYCLE
	K = getWorkers();
#else

	sizeT optimalCache = (n * sizeof(E)) / BLOCK_DIVIDE;
	if (optimalCache >  getWorkers() && optimalCache <= K_BOUND) {
		K = optimalCache;
	}
	else {
		if (optimalCache < getWorkers()) {
			K = getWorkers();
		}
		else {
			K = K_BOUND;
		}
	}

#endif
	global_K = K;
	global_N = n;

	radixSortOneLevel(A, n, doneOffset, f, K, 0);

};

template <class E, class F, class K>
void iSort(E *A, sizeT n, K m, F f) {
	int bits = roundUpBits(utils::log2Up(m));
	radixSortRoutine((sizeT)0, A, n, bits, f);
}

template <class T, class F>
static void parallelIntegerSort(T *A, sizeT n, F f) {
	T temp;
	T maxV = findMax(A, n, f, temp);
	iSort(A, n, maxV + 1, f);
}

template <class T>
static void parallelIntegerSort(T *A, sizeT n) {
	parallelIntegerSort(A, n, utils::identityF<T>());
}

//template <class T1, class T2, class F>
//void parallelIntegerSort(std::pair<T1, T2> *A, sizeT n, F f) {
//	T1 temp;
//	T1 maxV = findMax(A, n, f, temp);
//	iSort(A, n, maxV + 1, f);
//}
//
//template <class T1, class T2>
//void parallelIntegerSort(std::pair<T1, T2> *A, sizeT n) {
//	parallelIntegerSort(A, n, utils::firstF<T1, T2>());
//}

template<class T, class C>
inline void regionssort(T _First, T _Last, C compare) {
	parallelIntegerSort(&_First[0], std::distance(_First, _Last));
}

template<class T>
inline void regionssort(T _First, T _Last) {
	regionssort(_First, _Last, std::less<>());
}

#endif















~-----------------------------------------------~
C:\Users\Josh\Documents\Visual Studio 2017\Projects\Sorting\Sorting\resource.h
~-----------------------------------------------~
//{{NO_DEPENDENCIES}}
// Microsoft Visual C++ generated include file.
// Used by Sorting.rc
//
#define IDD_DIALOG                      101
#define IDD_OPTIONS                     106
#define IDD_TABLEVIEW                   108
#define CB_COLOR_MODE                   1002
#define CB_VISUALIZATION_TYPE           1003
#define CB_ALGORITHMS                   1007
#define CBTN_ACCESSES                   1008
#define CBTN_COMPARISONS                1009
#define CBTN_ASSIGNMENTS                1011
#define CBTN_PRE_SWAP                   1012
#define CBTN_POST_SWAP                  1013
#define CBTN_SOUND                      1020
#define CBTN_FAST_DRAW                  1021
#define EDC_DRAW_SPEED_FACTOR           1023
#define EDC_SLEEP_TIME                  1024
#define EDC_SIZE                        1025
#define BTN_RUN_ALL                     1026
#define BTN_ADD                         1027
#define BTN_REMOVE                      1028
#define CB_INSTRUMENTS                  1029
#define EDC_MIN_FREQ                    1030
#define EDC_MAX_FREQ                    1031
#define EDC_ON_VELOCITY                 1032
#define EDC_OFF_VELOCITY                1033
#define EDC_NOTE_DURATION               1034
#define SPN_DRAW_SPEED                  1035
#define CBTN_COMPLEXITY                 1038
#define CBTN_COUNTS                     1039
#define CBTN_RUNTIME                    1040
#define IDC_COMBO1                      1044
#define CB_INIT_VALUES                  1044
#define CB_INIT_ORDER                   1045
#define LV_SORT_TABLE                   1046

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        110
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1047
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif




~-----------------------------------------------~
C:\Users\Josh\Documents\Visual Studio 2017\Projects\Sorting\Sorting\RtMidi.h
~-----------------------------------------------~
/**********************************************************************/
/*! \class RtMidi
	\brief An abstract base class for realtime MIDI input/output.

	This class implements some common functionality for the realtime
	MIDI input/output subclasses RtMidiIn and RtMidiOut.

	RtMidi GitHub site: https://github.com/thestk/rtmidi
	RtMidi WWW site: http://www.music.mcgill.ca/~gary/rtmidi/

	RtMidi: realtime MIDI i/o C++ classes
	Copyright (c) 2003-2019 Gary P. Scavone

	Permission is hereby granted, free of charge, to any person
	obtaining a copy of this software and associated documentation files
	(the "Software"), to deal in the Software without restriction,
	including without limitation the rights to use, copy, modify, merge,
	publish, distribute, sublicense, and/or sell copies of the Software,
	and to permit persons to whom the Software is furnished to do so,
	subject to the following conditions:

	The above copyright notice and this permission notice shall be
	included in all copies or substantial portions of the Software.

	Any person wishing to distribute modifications to the Software is
	asked to send the modifications to the original developer so that
	they can be incorporated into the canonical version.  This is,
	however, not a binding provision of this license.

	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
	EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
	IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR
	ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF
	CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
	WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
*/
/**********************************************************************/

/*!
  \file RtMidi.h
 */

#ifndef RTMIDI_H
#define RTMIDI_H

#if defined _WIN32 || defined __CYGWIN__
#if defined(RTMIDI_EXPORT)
#define RTMIDI_DLL_PUBLIC __declspec(dllexport)
#else
#define RTMIDI_DLL_PUBLIC
#endif
#else
#if __GNUC__ >= 4
#define RTMIDI_DLL_PUBLIC __attribute__( (visibility( "default" )) )
#else
#define RTMIDI_DLL_PUBLIC
#endif
#endif

#define RTMIDI_VERSION "4.0.0"

#include <exception>
#include <iostream>
#include <string>
#include <vector>

/************************************************************************/
/*! \class RtMidiError
	\brief Exception handling class for RtMidi.

	The RtMidiError class is quite simple but it does allow errors to be
	"caught" by RtMidiError::Type. See the RtMidi documentation to know
	which methods can throw an RtMidiError.
*/
/************************************************************************/

class RTMIDI_DLL_PUBLIC RtMidiError : public std::exception {
public:
 //! Defined RtMidiError types.
	enum Type {
		WARNING,           /*!< A non-critical error. */
		DEBUG_WARNING,     /*!< A non-critical error which might be useful for debugging. */
		UNSPECIFIED,       /*!< The default, unspecified error type. */
		NO_DEVICES_FOUND,  /*!< No devices found on system. */
		INVALID_DEVICE,    /*!< An invalid device ID was specified. */
		MEMORY_ERROR,      /*!< An error occured during memory allocation. */
		INVALID_PARAMETER, /*!< An invalid parameter was specified to a function. */
		INVALID_USE,       /*!< The function was called incorrectly. */
		DRIVER_ERROR,      /*!< A system driver error occured. */
		SYSTEM_ERROR,      /*!< A system error occured. */
		THREAD_ERROR       /*!< A thread error occured. */
	};

	//! The constructor.
	RtMidiError(const std::string& message, Type type = RtMidiError::UNSPECIFIED) throw()
		: message_(message), type_(type) {}

	  //! The destructor.
	virtual ~RtMidiError(void) throw() {}

	//! Prints thrown error message to stderr.
	virtual void printMessage(void) const throw() { std::cerr << '\n' << message_ << "\n\n"; }

	//! Returns the thrown error message type.
	virtual const Type& getType(void) const throw() { return type_; }

	//! Returns the thrown error message string.
	virtual const std::string& getMessage(void) const throw() { return message_; }

	//! Returns the thrown error message as a c-style string.
	virtual const char* what(void) const throw() { return message_.c_str(); }

protected:
	std::string message_;
	Type type_;
};

//! RtMidi error callback function prototype.
/*!
	\param type Type of error.
	\param errorText Error description.

	Note that class behaviour is undefined after a critical error (not
	a warning) is reported.
 */
typedef void(*RtMidiErrorCallback)(RtMidiError::Type type, const std::string &errorText, void *userData);

class MidiApi;

class RTMIDI_DLL_PUBLIC RtMidi {
public:
 //! MIDI API specifier arguments.
	enum Api {
		UNSPECIFIED,    /*!< Search for a working compiled API. */
		MACOSX_CORE,    /*!< Macintosh OS-X CoreMIDI API. */
		LINUX_ALSA,     /*!< The Advanced Linux Sound Architecture API. */
		UNIX_JACK,      /*!< The JACK Low-Latency MIDI Server API. */
		WINDOWS_MM,     /*!< The Microsoft Multimedia MIDI API. */
		RTMIDI_DUMMY,   /*!< A compilable but non-functional API. */
		NUM_APIS        /*!< Number of values in this enum. */
	};

	//! A static function to determine the current RtMidi version.
	static std::string getVersion(void) throw();

	//! A static function to determine the available compiled MIDI APIs.
	/*!
	  The values returned in the std::vector can be compared against
	  the enumerated list values.  Note that there can be more than one
	  API compiled for certain operating systems.
	*/
	static void getCompiledApi(std::vector<RtMidi::Api> &apis) throw();

	//! Return the name of a specified compiled MIDI API.
	/*!
	  This obtains a short lower-case name used for identification purposes.
	  This value is guaranteed to remain identical across library versions.
	  If the API is unknown, this function will return the empty string.
	*/
	static std::string getApiName(RtMidi::Api api);

	//! Return the display name of a specified compiled MIDI API.
	/*!
	  This obtains a long name used for display purposes.
	  If the API is unknown, this function will return the empty string.
	*/
	static std::string getApiDisplayName(RtMidi::Api api);

	//! Return the compiled MIDI API having the given name.
	/*!
	  A case insensitive comparison will check the specified name
	  against the list of compiled APIs, and return the one which
	  matches. On failure, the function returns UNSPECIFIED.
	*/
	static RtMidi::Api getCompiledApiByName(const std::string &name);

	//! Pure virtual openPort() function.
	virtual void openPort(unsigned int portNumber = 0, const std::string &portName = std::string("RtMidi")) = 0;

	//! Pure virtual openVirtualPort() function.
	virtual void openVirtualPort(const std::string &portName = std::string("RtMidi")) = 0;

	//! Pure virtual getPortCount() function.
	virtual unsigned int getPortCount() = 0;

	//! Pure virtual getPortName() function.
	virtual std::string getPortName(unsigned int portNumber = 0) = 0;

	//! Pure virtual closePort() function.
	virtual void closePort(void) = 0;

	void setClientName(const std::string &clientName);
	void setPortName(const std::string &portName);

	//! Returns true if a port is open and false if not.
	/*!
		Note that this only applies to connections made with the openPort()
		function, not to virtual ports.
	*/
	virtual bool isPortOpen(void) const = 0;

	//! Set an error callback function to be invoked when an error has occured.
	/*!
	  The callback function will be called whenever an error has occured. It is best
	  to set the error callback function before opening a port.
	*/
	virtual void setErrorCallback(RtMidiErrorCallback errorCallback = NULL, void *userData = 0) = 0;

protected:
	RtMidi();
	virtual ~RtMidi();
	MidiApi *rtapi_;
};

/**********************************************************************/
/*! \class RtMidiIn
	\brief A realtime MIDI input class.

	This class provides a common, platform-independent API for
	realtime MIDI input.  It allows access to a single MIDI input
	port.  Incoming MIDI messages are either saved to a queue for
	retrieval using the getMessage() function or immediately passed to
	a user-specified callback function.  Create multiple instances of
	this class to connect to more than one MIDI device at the same
	time.  With the OS-X, Linux ALSA, and JACK MIDI APIs, it is also
	possible to open a virtual input port to which other MIDI software
	clients can connect.
*/
/**********************************************************************/

// **************************************************************** //
//
// RtMidiIn and RtMidiOut class declarations.
//
// RtMidiIn / RtMidiOut are "controllers" used to select an available
// MIDI input or output interface.  They present common APIs for the
// user to call but all functionality is implemented by the classes
// MidiInApi, MidiOutApi and their subclasses.  RtMidiIn and RtMidiOut
// each create an instance of a MidiInApi or MidiOutApi subclass based
// on the user's API choice.  If no choice is made, they attempt to
// make a "logical" API selection.
//
// **************************************************************** //

class RTMIDI_DLL_PUBLIC RtMidiIn : public RtMidi {
public:

 //! User callback function type definition.
	typedef void(*RtMidiCallback)(double timeStamp, std::vector<unsigned char> *message, void *userData);

	//! Default constructor that allows an optional api, client name and queue size.
	/*!
	  An exception will be thrown if a MIDI system initialization
	  error occurs.  The queue size defines the maximum number of
	  messages that can be held in the MIDI queue (when not using a
	  callback function).  If the queue size limit is reached,
	  incoming messages will be ignored.

	  If no API argument is specified and multiple API support has been
	  compiled, the default order of use is ALSA, JACK (Linux) and CORE,
	  JACK (OS-X).

	  \param api        An optional API id can be specified.
	  \param clientName An optional client name can be specified. This
						will be used to group the ports that are created
						by the application.
	  \param queueSizeLimit An optional size of the MIDI input queue can be specified.
	*/
	RtMidiIn(RtMidi::Api api = UNSPECIFIED,
			 const std::string& clientName = "RtMidi Input Client",
			 unsigned int queueSizeLimit = 100);

   //! If a MIDI connection is still open, it will be closed by the destructor.
	~RtMidiIn(void) throw();

	//! Returns the MIDI API specifier for the current instance of RtMidiIn.
	RtMidi::Api getCurrentApi(void) throw();

	//! Open a MIDI input connection given by enumeration number.
	/*!
	  \param portNumber An optional port number greater than 0 can be specified.
						Otherwise, the default or first port found is opened.
	  \param portName An optional name for the application port that is used to connect to portId can be specified.
	*/
	void openPort(unsigned int portNumber = 0, const std::string &portName = std::string("RtMidi Input"));

	//! Create a virtual input port, with optional name, to allow software connections (OS X, JACK and ALSA only).
	/*!
	  This function creates a virtual MIDI input port to which other
	  software applications can connect.  This type of functionality
	  is currently only supported by the Macintosh OS-X, any JACK,
	  and Linux ALSA APIs (the function returns an error for the other APIs).

	  \param portName An optional name for the application port that is
					  used to connect to portId can be specified.
	*/
	void openVirtualPort(const std::string &portName = std::string("RtMidi Input"));

	//! Set a callback function to be invoked for incoming MIDI messages.
	/*!
	  The callback function will be called whenever an incoming MIDI
	  message is received.  While not absolutely necessary, it is best
	  to set the callback function before opening a MIDI port to avoid
	  leaving some messages in the queue.

	  \param callback A callback function must be given.
	  \param userData Optionally, a pointer to additional data can be
					  passed to the callback function whenever it is called.
	*/
	void setCallback(RtMidiCallback callback, void *userData = 0);

	//! Cancel use of the current callback function (if one exists).
	/*!
	  Subsequent incoming MIDI messages will be written to the queue
	  and can be retrieved with the \e getMessage function.
	*/
	void cancelCallback();

	//! Close an open MIDI connection (if one exists).
	void closePort(void);

	//! Returns true if a port is open and false if not.
	/*!
		Note that this only applies to connections made with the openPort()
		function, not to virtual ports.
	*/
	virtual bool isPortOpen() const;

	//! Return the number of available MIDI input ports.
	/*!
	  \return This function returns the number of MIDI ports of the selected API.
	*/
	unsigned int getPortCount();

	//! Return a string identifier for the specified MIDI input port number.
	/*!
	  \return The name of the port with the given Id is returned.
	  \retval An empty string is returned if an invalid port specifier
			  is provided. User code should assume a UTF-8 encoding.
	*/
	std::string getPortName(unsigned int portNumber = 0);

	//! Specify whether certain MIDI message types should be queued or ignored during input.
	/*!
	  By default, MIDI timing and active sensing messages are ignored
	  during message input because of their relative high data rates.
	  MIDI sysex messages are ignored by default as well.  Variable
	  values of "true" imply that the respective message type will be
	  ignored.
	*/
	void ignoreTypes(bool midiSysex = true, bool midiTime = true, bool midiSense = true);

	//! Fill the user-provided vector with the data bytes for the next available MIDI message in the input queue and return the event delta-time in seconds.
	/*!
	  This function returns immediately whether a new message is
	  available or not.  A valid message is indicated by a non-zero
	  vector size.  An exception is thrown if an error occurs during
	  message retrieval or an input connection was not previously
	  established.
	*/
	double getMessage(std::vector<unsigned char> *message);

	//! Set an error callback function to be invoked when an error has occured.
	/*!
	  The callback function will be called whenever an error has occured. It is best
	  to set the error callback function before opening a port.
	*/
	virtual void setErrorCallback(RtMidiErrorCallback errorCallback = NULL, void *userData = 0);

protected:
	void openMidiApi(RtMidi::Api api, const std::string &clientName, unsigned int queueSizeLimit);
};

/**********************************************************************/
/*! \class RtMidiOut
	\brief A realtime MIDI output class.

	This class provides a common, platform-independent API for MIDI
	output.  It allows one to probe available MIDI output ports, to
	connect to one such port, and to send MIDI bytes immediately over
	the connection.  Create multiple instances of this class to
	connect to more than one MIDI device at the same time.  With the
	OS-X, Linux ALSA and JACK MIDI APIs, it is also possible to open a
	virtual port to which other MIDI software clients can connect.
*/
/**********************************************************************/

class RTMIDI_DLL_PUBLIC RtMidiOut : public RtMidi {
public:
 //! Default constructor that allows an optional client name.
 /*!
   An exception will be thrown if a MIDI system initialization error occurs.

   If no API argument is specified and multiple API support has been
   compiled, the default order of use is ALSA, JACK (Linux) and CORE,
   JACK (OS-X).
 */
	RtMidiOut(RtMidi::Api api = UNSPECIFIED,
			  const std::string& clientName = "RtMidi Output Client");

   //! The destructor closes any open MIDI connections.
	~RtMidiOut(void) throw();

	//! Returns the MIDI API specifier for the current instance of RtMidiOut.
	RtMidi::Api getCurrentApi(void) throw();

	//! Open a MIDI output connection.
	/*!
		An optional port number greater than 0 can be specified.
		Otherwise, the default or first port found is opened.  An
		exception is thrown if an error occurs while attempting to make
		the port connection.
	*/
	void openPort(unsigned int portNumber = 0, const std::string &portName = std::string("RtMidi Output"));

	//! Close an open MIDI connection (if one exists).
	void closePort(void);

	//! Returns true if a port is open and false if not.
	/*!
		Note that this only applies to connections made with the openPort()
		function, not to virtual ports.
	*/
	virtual bool isPortOpen() const;

	//! Create a virtual output port, with optional name, to allow software connections (OS X, JACK and ALSA only).
	/*!
		This function creates a virtual MIDI output port to which other
		software applications can connect.  This type of functionality
		is currently only supported by the Macintosh OS-X, Linux ALSA
		and JACK APIs (the function does nothing with the other APIs).
		An exception is thrown if an error occurs while attempting to
		create the virtual port.
	*/
	void openVirtualPort(const std::string &portName = std::string("RtMidi Output"));

	//! Return the number of available MIDI output ports.
	unsigned int getPortCount(void);

	//! Return a string identifier for the specified MIDI port type and number.
	/*!
	  \return The name of the port with the given Id is returned.
	  \retval An empty string is returned if an invalid port specifier
			  is provided. User code should assume a UTF-8 encoding.
	*/
	std::string getPortName(unsigned int portNumber = 0);

	//! Immediately send a single message out an open MIDI output port.
	/*!
		An exception is thrown if an error occurs during output or an
		output connection was not previously established.
	*/
	void sendMessage(const std::vector<unsigned char> *message);

	//! Immediately send a single message out an open MIDI output port.
	/*!
		An exception is thrown if an error occurs during output or an
		output connection was not previously established.

		\param message A pointer to the MIDI message as raw bytes
		\param size    Length of the MIDI message in bytes
	*/
	void sendMessage(const unsigned char *message, size_t size);

	//! Set an error callback function to be invoked when an error has occured.
	/*!
	  The callback function will be called whenever an error has occured. It is best
	  to set the error callback function before opening a port.
	*/
	virtual void setErrorCallback(RtMidiErrorCallback errorCallback = NULL, void *userData = 0);

protected:
	void openMidiApi(RtMidi::Api api, const std::string &clientName);
};


// **************************************************************** //
//
// MidiInApi / MidiOutApi class declarations.
//
// Subclasses of MidiInApi and MidiOutApi contain all API- and
// OS-specific code necessary to fully implement the RtMidi API.
//
// Note that MidiInApi and MidiOutApi are abstract base classes and
// cannot be explicitly instantiated.  RtMidiIn and RtMidiOut will
// create instances of a MidiInApi or MidiOutApi subclass.
//
// **************************************************************** //

class RTMIDI_DLL_PUBLIC MidiApi {
public:

	MidiApi();
	virtual ~MidiApi();
	virtual RtMidi::Api getCurrentApi(void) = 0;
	virtual void openPort(unsigned int portNumber, const std::string &portName) = 0;
	virtual void openVirtualPort(const std::string &portName) = 0;
	virtual void closePort(void) = 0;
	virtual void setClientName(const std::string &clientName) = 0;
	virtual void setPortName(const std::string &portName) = 0;

	virtual unsigned int getPortCount(void) = 0;
	virtual std::string getPortName(unsigned int portNumber) = 0;

	inline bool isPortOpen() const { return connected_; }
	void setErrorCallback(RtMidiErrorCallback errorCallback, void *userData);

	//! A basic error reporting function for RtMidi classes.
	void error(RtMidiError::Type type, std::string errorString);

protected:
	virtual void initialize(const std::string& clientName) = 0;

	void *apiData_;
	bool connected_;
	std::string errorString_;
	RtMidiErrorCallback errorCallback_;
	bool firstErrorOccurred_;
	void *errorCallbackUserData_;
};

class RTMIDI_DLL_PUBLIC MidiInApi : public MidiApi {
public:

	MidiInApi(unsigned int queueSizeLimit);
	virtual ~MidiInApi(void);
	void setCallback(RtMidiIn::RtMidiCallback callback, void *userData);
	void cancelCallback(void);
	virtual void ignoreTypes(bool midiSysex, bool midiTime, bool midiSense);
	double getMessage(std::vector<unsigned char> *message);

	// A MIDI structure used internally by the class to store incoming
	// messages.  Each message represents one and only one MIDI message.
	struct MidiMessage {
		std::vector<unsigned char> bytes;

		//! Time in seconds elapsed since the previous message
		double timeStamp;

		// Default constructor.
		MidiMessage()
			: bytes(0), timeStamp(0.0) {}
	};

	struct MidiQueue {
		unsigned int front;
		unsigned int back;
		unsigned int ringSize;
		MidiMessage *ring;

		// Default constructor.
		MidiQueue()
			: front(0), back(0), ringSize(0), ring(0) {}
		bool push(const MidiMessage&);
		bool pop(std::vector<unsigned char>*, double*);
		unsigned int size(unsigned int *back = 0, unsigned int *front = 0);
	};

	// The RtMidiInData structure is used to pass private class data to
	// the MIDI input handling function or thread.
	struct RtMidiInData {
		MidiQueue queue;
		MidiMessage message;
		unsigned char ignoreFlags;
		bool doInput;
		bool firstMessage;
		void *apiData;
		bool usingCallback;
		RtMidiIn::RtMidiCallback userCallback;
		void *userData;
		bool continueSysex;

		// Default constructor.
		RtMidiInData()
			: ignoreFlags(7), doInput(false), firstMessage(true), apiData(0), usingCallback(false),
			userCallback(0), userData(0), continueSysex(false) {}
	};

protected:
	RtMidiInData inputData_;
};

class RTMIDI_DLL_PUBLIC MidiOutApi : public MidiApi {
public:

	MidiOutApi(void);
	virtual ~MidiOutApi(void);
	virtual void sendMessage(const unsigned char *message, size_t size) = 0;
};

// **************************************************************** //
//
// Inline RtMidiIn and RtMidiOut definitions.
//
// **************************************************************** //

inline RtMidi::Api RtMidiIn::getCurrentApi(void) throw() { return rtapi_->getCurrentApi(); }
inline void RtMidiIn::openPort(unsigned int portNumber, const std::string &portName) { rtapi_->openPort(portNumber, portName); }
inline void RtMidiIn::openVirtualPort(const std::string &portName) { rtapi_->openVirtualPort(portName); }
inline void RtMidiIn::closePort(void) { rtapi_->closePort(); }
inline bool RtMidiIn::isPortOpen() const { return rtapi_->isPortOpen(); }
inline void RtMidiIn::setCallback(RtMidiCallback callback, void *userData) { static_cast<MidiInApi *>(rtapi_)->setCallback(callback, userData); }
inline void RtMidiIn::cancelCallback(void) { static_cast<MidiInApi *>(rtapi_)->cancelCallback(); }
inline unsigned int RtMidiIn::getPortCount(void) { return rtapi_->getPortCount(); }
inline std::string RtMidiIn::getPortName(unsigned int portNumber) { return rtapi_->getPortName(portNumber); }
inline void RtMidiIn::ignoreTypes(bool midiSysex, bool midiTime, bool midiSense) { static_cast<MidiInApi *>(rtapi_)->ignoreTypes(midiSysex, midiTime, midiSense); }
inline double RtMidiIn::getMessage(std::vector<unsigned char> *message) { return static_cast<MidiInApi *>(rtapi_)->getMessage(message); }
inline void RtMidiIn::setErrorCallback(RtMidiErrorCallback errorCallback, void *userData) { rtapi_->setErrorCallback(errorCallback, userData); }

inline RtMidi::Api RtMidiOut::getCurrentApi(void) throw() { return rtapi_->getCurrentApi(); }
inline void RtMidiOut::openPort(unsigned int portNumber, const std::string &portName) { rtapi_->openPort(portNumber, portName); }
inline void RtMidiOut::openVirtualPort(const std::string &portName) { rtapi_->openVirtualPort(portName); }
inline void RtMidiOut::closePort(void) { rtapi_->closePort(); }
inline bool RtMidiOut::isPortOpen() const { return rtapi_->isPortOpen(); }
inline unsigned int RtMidiOut::getPortCount(void) { return rtapi_->getPortCount(); }
inline std::string RtMidiOut::getPortName(unsigned int portNumber) { return rtapi_->getPortName(portNumber); }
inline void RtMidiOut::sendMessage(const std::vector<unsigned char> *message) { static_cast<MidiOutApi *>(rtapi_)->sendMessage(&message->at(0), message->size()); }
inline void RtMidiOut::sendMessage(const unsigned char *message, size_t size) { static_cast<MidiOutApi *>(rtapi_)->sendMessage(message, size); }
inline void RtMidiOut::setErrorCallback(RtMidiErrorCallback errorCallback, void *userData) { rtapi_->setErrorCallback(errorCallback, userData); }

#endif


























~-----------------------------------------------~
C:\Users\Josh\Documents\Visual Studio 2017\Projects\Sorting\Sorting\RunPool.h
~-----------------------------------------------~
#ifndef RUNPOOL_H
#define RUNPOOL_H

//#include <bits/stl_iterator_base_types.h>



const size_t kValuesPerBlock = 800;

template <typename ValueType>
struct RunBlock {
	RunBlock *next;
	RunBlock *prev;
	int next_free_pos_;
	ValueType values[kValuesPerBlock];
	bool is_front;
	RunBlock()
		: next(NULL), prev(NULL), next_free_pos_(0), is_front(false) {}


};


template <typename ValueType>
class RunPool {

	class iterator {
	public:
		typedef iterator            self_type;
		typedef ValueType           value_type;
		typedef ValueType&          reference;
		typedef ValueType*          pointer;
		typedef size_t              difference_type;
		typedef std::bidirectional_iterator_tag iterator_category;

		iterator(RunBlock<ValueType>* block, size_t index) : block_(block), index_(index) {}

		self_type&  operator++() {      // prefix
			index_++;
			if (index_ >= kValuesPerBlock) {
				index_ -= kValuesPerBlock;
				block_ = block_->next;
				return *this;
			}
			return *this;
		}
		self_type&  operator++(int i) {     // postfix
			self_type& temp = *this;
			index_++;
			if (index_ >= kValuesPerBlock) {
				index_ -= kValuesPerBlock;
				block_ = block_->next;
				return temp;
			}
			return temp;
		}
		self_type&  operator--() {
			index_--;
			if (index_ < 0) {
				index_ += kValuesPerBlock;
				block_ = block_->prev;
			}
			return *this;
		}
		self_type&  operator--(int i) {
			self_type& temp = *this;
			index_--;
			if (index_ < 0) {
				index_ += kValuesPerBlock;
				block_ = block_->prev;
			}
			return temp;
		}
		reference   operator*() {
			return block_->values[index_];
		}
		pointer     operator->() {
			return &block_->values[index_];
		}
		bool        operator==(const self_type& rhs) {
			return &block_->values[index_] == &rhs.block_[rhs.index_];
		}
		bool        operator!=(const self_type& rhs) {
			return &block_->values[index_] != &rhs.block_->values[rhs.index_];
		}

		RunBlock<ValueType>*    block_;
		size_t                  index_;
	};


public:
	RunPool() {
		begin_back_ = Alloc();
		end_back_ = begin_back_;
		size_ = 0;
		begin_front_ = end_front_ = NULL;
		end_block_ = begin_back_;
	}


	RunPool(const RunPool&) = delete;
	RunPool& operator=(const RunPool&) = delete;
	RunPool(RunPool&&) = default;
	RunPool& operator=(RunPool&&) = default;


	void Add(ValueType &value) {
		if (end_back_->next_free_pos_ < kValuesPerBlock) {
			end_back_->values[end_back_->next_free_pos_] = value;
		}
		else {
			RunBlock<ValueType>* temp = Alloc();
			temp->values[0] = value;
			temp->prev = end_back_;
			end_back_->next = temp;
			end_back_ = temp;
			end_block_ = temp;
			size_ += kValuesPerBlock;
		}
		end_back_->next_free_pos_++;
	}


	void AddFront(ValueType &value) {
		if (begin_front_ == NULL) {
			begin_front_ = Alloc();
			begin_front_->next_free_pos_ = kValuesPerBlock - 1;
			begin_front_->is_front = true;
			begin_front_->next = begin_back_;

			end_front_ = begin_front_;
			begin_back_->prev = end_front_;
		}

		if (begin_front_->next_free_pos_ < 0) {
			RunBlock<ValueType>* temp = Alloc();
			temp->is_front = true;
			temp->next = begin_front_;
			temp->values[kValuesPerBlock - 1] = value;
			temp->next_free_pos_ = kValuesPerBlock - 2;

			begin_front_->prev = temp;
			begin_front_ = temp;
			size_ += kValuesPerBlock;

		}
		else {
			begin_front_->values[begin_front_->next_free_pos_] = value;
			begin_front_->next_free_pos_--;
		}
	}

	size_t  size() const {
		int size_total = size_;
		size_total += end_back_->next_free_pos_;

		if (begin_front_ != NULL) {
			size_total += kValuesPerBlock - begin_front_->next_free_pos_ - 1;
		}
		return size_total;
	}

	ValueType& operator[](size_t t) {
		RunBlock<ValueType>* temp = begin_back_;
		while (t >= kValuesPerBlock) {
			temp = temp->next;
			t -= kValuesPerBlock;
		}
		return temp->values[t];
	}

	iterator begin() {
		if (begin_front_ == NULL) {
			return iterator(begin_back_, 0);
		}
		else {
			return iterator(begin_front_, begin_front_->next_free_pos_ + 1);
		}

	}

	iterator end() {        // points to the last element plus one
		if (end_block_->next_free_pos_ >= kValuesPerBlock) {
			return iterator(end_block_, kValuesPerBlock);
		}
		return iterator(end_block_, end_block_->next_free_pos_);

	}

	iterator last() {       // points to the last element
		if (end_block_->next_free_pos_ > 0) {
			return iterator(end_block_, end_block_->next_free_pos_ - 1);
		}
		else {
			return iterator(end_block_->prev, kValuesPerBlock - 1);
		}
	}

	ValueType&back() {
		int next_free = end_block_->next_free_pos_;
		if (next_free <= 0) {
			return end_block_->prev->values[kValuesPerBlock - 1];
		}
		else {
			return end_block_->values[next_free - 1];
		}
	}

	static void SetMemSize(size_t s) {
		mem_blocks_ = s;
	}

	static void Init() {
		memory_ = new RunBlock<ValueType>[mem_blocks_];
		next_free_ = memory_;
	}

	static void Release() {
		delete[] memory_;
	}

	static RunBlock<ValueType>* Alloc() {
		RunBlock<ValueType>* ret = next_free_;
		next_free_++;
		return ret;
	}




private:
	RunBlock<ValueType>* begin_back_;
	RunBlock<ValueType>* end_back_;
	RunBlock<ValueType>* begin_front_;
	RunBlock<ValueType>* end_front_;
	RunBlock<ValueType>* end_block_;
	size_t size_;

	static RunBlock<ValueType>* memory_;
	static RunBlock<ValueType>* next_free_;
	static size_t mem_blocks_;
};

template <typename ValueType>
RunBlock<ValueType>* RunPool<ValueType>::memory_ = NULL;

template <typename ValueType>
RunBlock<ValueType>* RunPool<ValueType>::next_free_ = NULL;

template <typename ValueType>
size_t RunPool<ValueType>::mem_blocks_;

#endif












~-----------------------------------------------~
C:\Users\Josh\Documents\Visual Studio 2017\Projects\Sorting\Sorting\selectionsort.h
~-----------------------------------------------~
#pragma once

template<class T, class C>
inline void selectionsort(T _First, T _Last, C compare) {
	T _End = _Last - 1;
	while (_First < _End) {
		T _Pos = _First;
		T _Max = _First;
		while (_Pos <= _End) {
			if (compare(*_Max, *_Pos))
				_Max = _Pos;
			++_Pos;
		}
		iter_swap(_End, _Max);
		--_End;
	}
}

template<class T>
inline void selectionsort(T _First, T _Last) {
	selectionsort(_First, _Last, std::less<>());
}

template<class T, class C>
inline void doubleselectionsort(T _First, T _Last, C compare) {
	T _Left = _First, _Right = _Last;
	while (_Left < _Right) {
		std::pair<T, T> minmax = std::minmax_element(_Left, _Right--, compare);

		iter_swap(_Left, minmax.first);

		if (_Left == minmax.second)
			iter_swap(_Right, minmax.first);
		else
			iter_swap(_Right, minmax.second);

		++_Left;
	}
}

template<class T>
inline void doubleselectionsort(T _First, T _Last) {
	doubleselectionsort(_First, _Last, std::less<>());
}


























~-----------------------------------------------~
C:\Users\Josh\Documents\Visual Studio 2017\Projects\Sorting\Sorting\sillysort.h
~-----------------------------------------------~
#pragma once

template<class T, class C>
inline void _sillysort(T _First, T _Last, C compare) {
	if (_First < _Last) {
		T _Mid = _First + ((_Last - _First) >> 1);
		
		_sillysort(_First, _Mid, compare);
		_sillysort(_Mid + 1, _Last, compare);		
		
		if (!compare(*_First, *(_Mid + 1)))
			iter_swap(_First, (_Mid + 1));		
		 
		_sillysort(_First + 1, _Last, compare);
	}
}

template<class T, class C>
inline void sillysort(T _First, T _Last, C compare) {
	_sillysort(_First, _Last - 1, compare);
}

template<class T>
inline void sillysort(T _First, T _Last) {
	sillysort(_First, _Last, std::less<>());
}
























~-----------------------------------------------~
C:\Users\Josh\Documents\Visual Studio 2017\Projects\Sorting\Sorting\skasort.h
~-----------------------------------------------~
//          Copyright Malte Skarupke 2016.
// Distributed under the Boost Software License, Version 1.0.
//    (See http://www.boost.org/LICENSE_1_0.txt)

#pragma once

#include <cstdint>
#include <algorithm>
#include <type_traits>
#include <tuple>
#include <utility>

namespace detail {
template<typename count_type, typename It, typename OutIt, typename ExtractKey>
void counting_sort_impl(It begin, It end, OutIt out_begin, ExtractKey && extract_key) {
	count_type counts[256] = {};
	for (It it = begin; it != end; ++it) {
		++counts[extract_key(*it)];
	}
	count_type total = 0;
	for (count_type & count : counts) {
		count_type old_count = count;
		count = total;
		total += old_count;
	}
	for (; begin != end; ++begin) {
		std::uint8_t key = extract_key(*begin);
		out_begin[counts[key]++] = std::move(*begin);
	}
}
template<typename It, typename OutIt, typename ExtractKey>
void counting_sort_impl(It begin, It end, OutIt out_begin, ExtractKey && extract_key) {
	counting_sort_impl<std::uint64_t>(begin, end, out_begin, extract_key);
}
inline bool to_unsigned_or_bool(bool b) {
	return b;
}
inline unsigned char to_unsigned_or_bool(unsigned char c) {
	return c;
}
inline unsigned char to_unsigned_or_bool(signed char c) {
	return static_cast<unsigned char>(c) + 128;
}
inline unsigned char to_unsigned_or_bool(char c) {
	return static_cast<unsigned char>(c);
}
inline std::uint16_t to_unsigned_or_bool(char16_t c) {
	return static_cast<std::uint16_t>(c);
}
inline std::uint32_t to_unsigned_or_bool(char32_t c) {
	return static_cast<std::uint32_t>(c);
}
inline std::uint32_t to_unsigned_or_bool(wchar_t c) {
	return static_cast<std::uint32_t>(c);
}
inline unsigned short to_unsigned_or_bool(short i) {
	return static_cast<unsigned short>(i) + static_cast<unsigned short>(1 << (sizeof(short) * 8 - 1));
}
inline unsigned short to_unsigned_or_bool(unsigned short i) {
	return i;
}
inline unsigned int to_unsigned_or_bool(int i) {
	return static_cast<unsigned int>(i) + static_cast<unsigned int>(1 << (sizeof(int) * 8 - 1));
}
inline unsigned int to_unsigned_or_bool(unsigned int i) {
	return i;
}
inline unsigned long to_unsigned_or_bool(long l) {
	return static_cast<unsigned long>(l) + static_cast<unsigned long>(1l << (sizeof(long) * 8 - 1));
}
inline unsigned long to_unsigned_or_bool(unsigned long l) {
	return l;
}
inline unsigned long long to_unsigned_or_bool(long long l) {
	return static_cast<unsigned long long>(l) + static_cast<unsigned long long>(1ll << (sizeof(long long) * 8 - 1));
}
inline unsigned long long to_unsigned_or_bool(unsigned long long l) {
	return l;
}
inline std::uint32_t to_unsigned_or_bool(float f) {
	union {
		float f;
		std::uint32_t u;
	} as_union = {f};
	std::uint32_t sign_bit = -std::int32_t(as_union.u >> 31);
	return as_union.u ^ (sign_bit | 0x80000000);
}
inline std::uint64_t to_unsigned_or_bool(double f) {
	union {
		double d;
		std::uint64_t u;
	} as_union = {f};
	std::uint64_t sign_bit = -std::int64_t(as_union.u >> 63);
	return as_union.u ^ (sign_bit | 0x8000000000000000);
}
template<typename T>
inline size_t to_unsigned_or_bool(T * ptr) {
	return reinterpret_cast<size_t>(ptr);
}

template<size_t>
struct SizedRadixSorter;

template<>
struct SizedRadixSorter<1> {
	template<typename It, typename OutIt, typename ExtractKey>
	static bool sort(It begin, It end, OutIt buffer_begin, ExtractKey && extract_key) {
		counting_sort_impl(begin, end, buffer_begin, [&](auto && o) {
			return to_unsigned_or_bool(extract_key(o));
		});
		return true;
	}

	static constexpr size_t pass_count = 2;
};
template<>
struct SizedRadixSorter<2> {
	template<typename It, typename OutIt, typename ExtractKey>
	static bool sort(It begin, It end, OutIt buffer_begin, ExtractKey && extract_key) {
		std::ptrdiff_t num_elements = end - begin;
		if (num_elements <= (1ll << 32))
			return sort_inline<uint32_t>(begin, end, buffer_begin, buffer_begin + num_elements, extract_key);
		else
			return sort_inline<uint64_t>(begin, end, buffer_begin, buffer_begin + num_elements, extract_key);
	}

	template<typename count_type, typename It, typename OutIt, typename ExtractKey>
	static bool sort_inline(It begin, It end, OutIt out_begin, OutIt out_end, ExtractKey && extract_key) {
		count_type counts0[256] = {};
		count_type counts1[256] = {};

		for (It it = begin; it != end; ++it) {
			uint16_t key = to_unsigned_or_bool(extract_key(*it));
			++counts0[key & 0xff];
			++counts1[(key >> 8) & 0xff];
		}
		count_type total0 = 0;
		count_type total1 = 0;
		for (int i = 0; i < 256; ++i) {
			count_type old_count0 = counts0[i];
			count_type old_count1 = counts1[i];
			counts0[i] = total0;
			counts1[i] = total1;
			total0 += old_count0;
			total1 += old_count1;
		}
		for (It it = begin; it != end; ++it) {
			std::uint8_t key = to_unsigned_or_bool(extract_key(*it));
			out_begin[counts0[key]++] = std::move(*it);
		}
		for (OutIt it = out_begin; it != out_end; ++it) {
			std::uint8_t key = to_unsigned_or_bool(extract_key(*it)) >> 8;
			begin[counts1[key]++] = std::move(*it);
		}
		return false;
	}

	static constexpr size_t pass_count = 3;
};
template<>
struct SizedRadixSorter<4> {

	template<typename It, typename OutIt, typename ExtractKey>
	static bool sort(It begin, It end, OutIt buffer_begin, ExtractKey && extract_key) {
		std::ptrdiff_t num_elements = end - begin;
		if (num_elements <= (1ll << 32))
			return sort_inline<uint32_t>(begin, end, buffer_begin, buffer_begin + num_elements, extract_key);
		else
			return sort_inline<uint64_t>(begin, end, buffer_begin, buffer_begin + num_elements, extract_key);
	}
	template<typename count_type, typename It, typename OutIt, typename ExtractKey>
	static bool sort_inline(It begin, It end, OutIt out_begin, OutIt out_end, ExtractKey && extract_key) {
		count_type counts0[256] = {};
		count_type counts1[256] = {};
		count_type counts2[256] = {};
		count_type counts3[256] = {};

		for (It it = begin; it != end; ++it) {
			uint32_t key = to_unsigned_or_bool(extract_key(*it));
			++counts0[key & 0xff];
			++counts1[(key >> 8) & 0xff];
			++counts2[(key >> 16) & 0xff];
			++counts3[(key >> 24) & 0xff];
		}
		count_type total0 = 0;
		count_type total1 = 0;
		count_type total2 = 0;
		count_type total3 = 0;
		for (int i = 0; i < 256; ++i) {
			count_type old_count0 = counts0[i];
			count_type old_count1 = counts1[i];
			count_type old_count2 = counts2[i];
			count_type old_count3 = counts3[i];
			counts0[i] = total0;
			counts1[i] = total1;
			counts2[i] = total2;
			counts3[i] = total3;
			total0 += old_count0;
			total1 += old_count1;
			total2 += old_count2;
			total3 += old_count3;
		}
		for (It it = begin; it != end; ++it) {
			std::uint8_t key = to_unsigned_or_bool(extract_key(*it));
			out_begin[counts0[key]++] = std::move(*it);
		}
		for (OutIt it = out_begin; it != out_end; ++it) {
			std::uint8_t key = to_unsigned_or_bool(extract_key(*it)) >> 8;
			begin[counts1[key]++] = std::move(*it);
		}
		for (It it = begin; it != end; ++it) {
			std::uint8_t key = to_unsigned_or_bool(extract_key(*it)) >> 16;
			out_begin[counts2[key]++] = std::move(*it);
		}
		for (OutIt it = out_begin; it != out_end; ++it) {
			std::uint8_t key = to_unsigned_or_bool(extract_key(*it)) >> 24;
			begin[counts3[key]++] = std::move(*it);
		}
		return false;
	}

	static constexpr size_t pass_count = 5;
};
template<>
struct SizedRadixSorter<8> {
	template<typename It, typename OutIt, typename ExtractKey>
	static bool sort(It begin, It end, OutIt buffer_begin, ExtractKey && extract_key) {
		std::ptrdiff_t num_elements = end - begin;
		if (num_elements <= (1ll << 32))
			return sort_inline<uint32_t>(begin, end, buffer_begin, buffer_begin + num_elements, extract_key);
		else
			return sort_inline<uint64_t>(begin, end, buffer_begin, buffer_begin + num_elements, extract_key);
	}
	template<typename count_type, typename It, typename OutIt, typename ExtractKey>
	static bool sort_inline(It begin, It end, OutIt out_begin, OutIt out_end, ExtractKey && extract_key) {
		count_type counts0[256] = {};
		count_type counts1[256] = {};
		count_type counts2[256] = {};
		count_type counts3[256] = {};
		count_type counts4[256] = {};
		count_type counts5[256] = {};
		count_type counts6[256] = {};
		count_type counts7[256] = {};

		for (It it = begin; it != end; ++it) {
			uint64_t key = to_unsigned_or_bool(extract_key(*it));
			++counts0[key & 0xff];
			++counts1[(key >> 8) & 0xff];
			++counts2[(key >> 16) & 0xff];
			++counts3[(key >> 24) & 0xff];
			++counts4[(key >> 32) & 0xff];
			++counts5[(key >> 40) & 0xff];
			++counts6[(key >> 48) & 0xff];
			++counts7[(key >> 56) & 0xff];
		}
		count_type total0 = 0;
		count_type total1 = 0;
		count_type total2 = 0;
		count_type total3 = 0;
		count_type total4 = 0;
		count_type total5 = 0;
		count_type total6 = 0;
		count_type total7 = 0;
		for (int i = 0; i < 256; ++i) {
			count_type old_count0 = counts0[i];
			count_type old_count1 = counts1[i];
			count_type old_count2 = counts2[i];
			count_type old_count3 = counts3[i];
			count_type old_count4 = counts4[i];
			count_type old_count5 = counts5[i];
			count_type old_count6 = counts6[i];
			count_type old_count7 = counts7[i];
			counts0[i] = total0;
			counts1[i] = total1;
			counts2[i] = total2;
			counts3[i] = total3;
			counts4[i] = total4;
			counts5[i] = total5;
			counts6[i] = total6;
			counts7[i] = total7;
			total0 += old_count0;
			total1 += old_count1;
			total2 += old_count2;
			total3 += old_count3;
			total4 += old_count4;
			total5 += old_count5;
			total6 += old_count6;
			total7 += old_count7;
		}
		for (It it = begin; it != end; ++it) {
			std::uint8_t key = to_unsigned_or_bool(extract_key(*it));
			out_begin[counts0[key]++] = std::move(*it);
		}
		for (OutIt it = out_begin; it != out_end; ++it) {
			std::uint8_t key = to_unsigned_or_bool(extract_key(*it)) >> 8;
			begin[counts1[key]++] = std::move(*it);
		}
		for (It it = begin; it != end; ++it) {
			std::uint8_t key = to_unsigned_or_bool(extract_key(*it)) >> 16;
			out_begin[counts2[key]++] = std::move(*it);
		}
		for (OutIt it = out_begin; it != out_end; ++it) {
			std::uint8_t key = to_unsigned_or_bool(extract_key(*it)) >> 24;
			begin[counts3[key]++] = std::move(*it);
		}
		for (It it = begin; it != end; ++it) {
			std::uint8_t key = to_unsigned_or_bool(extract_key(*it)) >> 32;
			out_begin[counts4[key]++] = std::move(*it);
		}
		for (OutIt it = out_begin; it != out_end; ++it) {
			std::uint8_t key = to_unsigned_or_bool(extract_key(*it)) >> 40;
			begin[counts5[key]++] = std::move(*it);
		}
		for (It it = begin; it != end; ++it) {
			std::uint8_t key = to_unsigned_or_bool(extract_key(*it)) >> 48;
			out_begin[counts6[key]++] = std::move(*it);
		}
		for (OutIt it = out_begin; it != out_end; ++it) {
			std::uint8_t key = to_unsigned_or_bool(extract_key(*it)) >> 56;
			begin[counts7[key]++] = std::move(*it);
		}
		return false;
	}

	static constexpr size_t pass_count = 9;
};

template<typename>
struct RadixSorter;
template<>
struct RadixSorter<bool> {
	template<typename It, typename OutIt, typename ExtractKey>
	static bool sort(It begin, It end, OutIt buffer_begin, ExtractKey && extract_key) {
		size_t false_count = 0;
		for (It it = begin; it != end; ++it) {
			if (!extract_key(*it))
				++false_count;
		}
		size_t true_position = false_count;
		false_count = 0;
		for (; begin != end; ++begin) {
			if (extract_key(*begin))
				buffer_begin[true_position++] = std::move(*begin);
			else
				buffer_begin[false_count++] = std::move(*begin);
		}
		return true;
	}

	static constexpr size_t pass_count = 2;
};
template<>
struct RadixSorter<signed char> : SizedRadixSorter<sizeof(signed char)> {};
template<>
struct RadixSorter<unsigned char> : SizedRadixSorter<sizeof(unsigned char)> {};
template<>
struct RadixSorter<signed short> : SizedRadixSorter<sizeof(signed short)> {};
template<>
struct RadixSorter<unsigned short> : SizedRadixSorter<sizeof(unsigned short)> {};
template<>
struct RadixSorter<signed int> : SizedRadixSorter<sizeof(signed int)> {};
template<>
struct RadixSorter<unsigned int> : SizedRadixSorter<sizeof(unsigned int)> {};
template<>
struct RadixSorter<signed long> : SizedRadixSorter<sizeof(signed long)> {};
template<>
struct RadixSorter<unsigned long> : SizedRadixSorter<sizeof(unsigned long)> {};
template<>
struct RadixSorter<signed long long> : SizedRadixSorter<sizeof(signed long long)> {};
template<>
struct RadixSorter<unsigned long long> : SizedRadixSorter<sizeof(unsigned long long)> {};
template<>
struct RadixSorter<float> : SizedRadixSorter<sizeof(float)> {};
template<>
struct RadixSorter<double> : SizedRadixSorter<sizeof(double)> {};
template<>
struct RadixSorter<char> : SizedRadixSorter<sizeof(char)> {};
template<>
struct RadixSorter<wchar_t> : SizedRadixSorter<sizeof(wchar_t)> {};
template<>
struct RadixSorter<char16_t> : SizedRadixSorter<sizeof(char16_t)> {};
template<>
struct RadixSorter<char32_t> : SizedRadixSorter<sizeof(char32_t)> {};
template<typename K, typename V>
struct RadixSorter<std::pair<K, V>> {
	template<typename It, typename OutIt, typename ExtractKey>
	static bool sort(It begin, It end, OutIt buffer_begin, ExtractKey && extract_key) {
		bool first_result = RadixSorter<V>::sort(begin, end, buffer_begin, [&](auto && o) {
			return extract_key(o).second;
		});
		auto extract_first = [&](auto && o) {
			return extract_key(o).first;
		};

		if (first_result) {
			return !RadixSorter<K>::sort(buffer_begin, buffer_begin + (end - begin), begin, extract_first);
		}
		else {
			return RadixSorter<K>::sort(begin, end, buffer_begin, extract_first);
		}
	}

	static constexpr size_t pass_count = RadixSorter<K>::pass_count + RadixSorter<V>::pass_count;
};
template<typename K, typename V>
struct RadixSorter<const std::pair<K, V> &> {
	template<typename It, typename OutIt, typename ExtractKey>
	static bool sort(It begin, It end, OutIt buffer_begin, ExtractKey && extract_key) {
		bool first_result = RadixSorter<V>::sort(begin, end, buffer_begin, [&](auto && o) -> const V &
												 {
													 return extract_key(o).second;
												 });
		auto extract_first = [&](auto && o) -> const K &
		{
			return extract_key(o).first;
		};

		if (first_result) {
			return !RadixSorter<K>::sort(buffer_begin, buffer_begin + (end - begin), begin, extract_first);
		}
		else {
			return RadixSorter<K>::sort(begin, end, buffer_begin, extract_first);
		}
	}

	static constexpr size_t pass_count = RadixSorter<K>::pass_count + RadixSorter<V>::pass_count;
};
template<size_t I, size_t S, typename Tuple>
struct TupleRadixSorter {
	using NextSorter = TupleRadixSorter<I + 1, S, Tuple>;
	using ThisSorter = RadixSorter<typename std::tuple_element<I, Tuple>::type>;

	template<typename It, typename OutIt, typename ExtractKey>
	static bool sort(It begin, It end, OutIt out_begin, OutIt out_end, ExtractKey && extract_key) {
		bool which = NextSorter::sort(begin, end, out_begin, out_end, extract_key);
		auto extract_i = [&](auto && o) {
			return std::get<I>(extract_key(o));
		};
		if (which)
			return !ThisSorter::sort(out_begin, out_end, begin, extract_i);
		else
			return ThisSorter::sort(begin, end, out_begin, extract_i);
	}

	static constexpr size_t pass_count = ThisSorter::pass_count + NextSorter::pass_count;
};
template<size_t I, size_t S, typename Tuple>
struct TupleRadixSorter<I, S, const Tuple &> {
	using NextSorter = TupleRadixSorter<I + 1, S, const Tuple &>;
	using ThisSorter = RadixSorter<typename std::tuple_element<I, Tuple>::type>;

	template<typename It, typename OutIt, typename ExtractKey>
	static bool sort(It begin, It end, OutIt out_begin, OutIt out_end, ExtractKey && extract_key) {
		bool which = NextSorter::sort(begin, end, out_begin, out_end, extract_key);
		auto extract_i = [&](auto && o) -> decltype(auto) {
			return std::get<I>(extract_key(o));
		};
		if (which)
			return !ThisSorter::sort(out_begin, out_end, begin, extract_i);
		else
			return ThisSorter::sort(begin, end, out_begin, extract_i);
	}

	static constexpr size_t pass_count = ThisSorter::pass_count + NextSorter::pass_count;
};
template<size_t I, typename Tuple>
struct TupleRadixSorter<I, I, Tuple> {
	template<typename It, typename OutIt, typename ExtractKey>
	static bool sort(It, It, OutIt, OutIt, ExtractKey &&) {
		return false;
	}

	static constexpr size_t pass_count = 0;
};
template<size_t I, typename Tuple>
struct TupleRadixSorter<I, I, const Tuple &> {
	template<typename It, typename OutIt, typename ExtractKey>
	static bool sort(It, It, OutIt, OutIt, ExtractKey &&) {
		return false;
	}

	static constexpr size_t pass_count = 0;
};

template<typename... Args>
struct RadixSorter<std::tuple<Args...>> {
	using SorterImpl = TupleRadixSorter<0, sizeof...(Args), std::tuple<Args...>>;

	template<typename It, typename OutIt, typename ExtractKey>
	static bool sort(It begin, It end, OutIt buffer_begin, ExtractKey && extract_key) {
		return SorterImpl::sort(begin, end, buffer_begin, buffer_begin + (end - begin), extract_key);
	}

	static constexpr size_t pass_count = SorterImpl::pass_count;
};

template<typename... Args>
struct RadixSorter<const std::tuple<Args...> &> {
	using SorterImpl = TupleRadixSorter<0, sizeof...(Args), const std::tuple<Args...> &>;

	template<typename It, typename OutIt, typename ExtractKey>
	static bool sort(It begin, It end, OutIt buffer_begin, ExtractKey && extract_key) {
		return SorterImpl::sort(begin, end, buffer_begin, buffer_begin + (end - begin), extract_key);
	}

	static constexpr size_t pass_count = SorterImpl::pass_count;
};

template<typename T, size_t S>
struct RadixSorter<std::array<T, S>> {
	template<typename It, typename OutIt, typename ExtractKey>
	static bool sort(It begin, It end, OutIt buffer_begin, ExtractKey && extract_key) {
		auto buffer_end = buffer_begin + (end - begin);
		bool which = false;
		for (size_t i = S; i > 0; --i) {
			auto extract_i = [&, i = i - 1](auto && o)
			{
				return extract_key(o)[i];
			};
			if (which)
				which = !RadixSorter<T>::sort(buffer_begin, buffer_end, begin, extract_i);
			else
				which = RadixSorter<T>::sort(begin, end, buffer_begin, extract_i);
		}
		return which;
	}

	static constexpr size_t pass_count = RadixSorter<T>::pass_count * S;
};

template<typename T>
struct RadixSorter<const T> : RadixSorter<T> {};
template<typename T>
struct RadixSorter<T &> : RadixSorter<const T &> {};
template<typename T>
struct RadixSorter<T &&> : RadixSorter<T> {};
template<typename T>
struct RadixSorter<const T &> : RadixSorter<T> {};
template<typename T>
struct RadixSorter<const T &&> : RadixSorter<T> {};
// these structs serve two purposes
// 1. they serve as illustration for how to implement the to_radix_sort_key function
// 2. they help produce better error messages. with these overloads you get the
//    error message "no matching function for call to to_radix_sort(your_type)"
//    without these examples, you'd get the error message "to_radix_sort_key was
//    not declared in this scope" which is a much less useful error message
struct ExampleStructA { int i; };
struct ExampleStructB { float f; };
inline int to_radix_sort_key(ExampleStructA a) { return a.i; }
inline float to_radix_sort_key(ExampleStructB b) { return b.f; }
template<typename T, typename Enable = void>
struct FallbackRadixSorter : RadixSorter<decltype(to_radix_sort_key(std::declval<T>()))> {
	using base = RadixSorter<decltype(to_radix_sort_key(std::declval<T>()))>;

	template<typename It, typename OutIt, typename ExtractKey>
	static bool sort(It begin, It end, OutIt buffer_begin, ExtractKey && extract_key) {
		return base::sort(begin, end, buffer_begin, [&](auto && a) -> decltype(auto) {
			return to_radix_sort_key(extract_key(a));
		});
	}
};

template<typename...>
struct nested_void {
	using type = void;
};

template<typename... Args>
using void_t = typename nested_void<Args...>::type;

template<typename T>
struct has_subscript_operator_impl {
	template<typename U, typename = decltype(std::declval<U>()[0])>
	static std::true_type test(int);
	template<typename>
	static std::false_type test(...);

	using type = decltype(test<T>(0));
};

template<typename T>
using has_subscript_operator = typename has_subscript_operator_impl<T>::type;


template<typename T>
struct FallbackRadixSorter<T, void_t<decltype(to_unsigned_or_bool(std::declval<T>()))>>
	: RadixSorter<decltype(to_unsigned_or_bool(std::declval<T>()))> {};

template<typename T>
struct RadixSorter : FallbackRadixSorter<T> {};

template<typename T>
size_t radix_sort_pass_count = RadixSorter<T>::pass_count;

template<typename It, typename Func>
inline void unroll_loop_four_times(It begin, size_t iteration_count, Func && to_call) {
	size_t loop_count = iteration_count / 4;
	size_t remainder_count = iteration_count - loop_count * 4;
	for (; loop_count > 0; --loop_count) {
		to_call(begin);
		++begin;
		to_call(begin);
		++begin;
		to_call(begin);
		++begin;
		to_call(begin);
		++begin;
	}
	switch (remainder_count) {
		case 3:
			to_call(begin);
			++begin;
		case 2:
			to_call(begin);
			++begin;
		case 1:
			to_call(begin);
	}
}

template<typename It, typename F>
inline It custom_std_partition(It begin, It end, F && func) {
	for (;; ++begin) {
		if (begin == end)
			return end;
		if (!func(*begin))
			break;
	}
	It it = begin;
	for (++it; it != end; ++it) {
		if (!func(*it))
			continue;

		std::iter_swap(begin, it);
		++begin;
	}
	return begin;
}

struct PartitionInfo {
	PartitionInfo()
		: count(0) {}

	union {
		size_t count;
		size_t offset;
	};
	size_t next_offset;
};

template<size_t>
struct UnsignedForSize;
template<>
struct UnsignedForSize<1> {
	typedef uint8_t type;
};
template<>
struct UnsignedForSize<2> {
	typedef uint16_t type;
};
template<>
struct UnsignedForSize<4> {
	typedef uint32_t type;
};
template<>
struct UnsignedForSize<8> {
	typedef uint64_t type;
};
template<typename T>
struct SubKey;
template<size_t Size>
struct SizedSubKey {
	template<typename T>
	static auto sub_key(T && value, void *) {
		return to_unsigned_or_bool(value);
	}

	typedef SubKey<void> next;

	using sub_key_type = typename UnsignedForSize<Size>::type;
};
template<typename T>
struct SubKey<const T> : SubKey<T> {};
template<typename T>
struct SubKey<T &> : SubKey<T> {};
template<typename T>
struct SubKey<T &&> : SubKey<T> {};
template<typename T>
struct SubKey<const T &> : SubKey<T> {};
template<typename T>
struct SubKey<const T &&> : SubKey<T> {};
template<typename T, typename Enable = void>
struct FallbackSubKey
	: SubKey<decltype(to_radix_sort_key(std::declval<T>()))> {
	using base = SubKey<decltype(to_radix_sort_key(std::declval<T>()))>;

	template<typename U>
	static decltype(auto) sub_key(U && value, void * data) {
		return base::sub_key(to_radix_sort_key(value), data);
	}
};
template<typename T>
struct FallbackSubKey<T, void_t<decltype(to_unsigned_or_bool(std::declval<T>()))>>
	: SubKey<decltype(to_unsigned_or_bool(std::declval<T>()))> {};
template<typename T>
struct SubKey : FallbackSubKey<T> {};
template<>
struct SubKey<bool> {
	template<typename T>
	static bool sub_key(T && value, void *) {
		return value;
	}

	typedef SubKey<void> next;

	using sub_key_type = bool;
};
template<>
struct SubKey<void>;
template<>
struct SubKey<unsigned char> : SizedSubKey<sizeof(unsigned char)> {};
template<>
struct SubKey<unsigned short> : SizedSubKey<sizeof(unsigned short)> {};
template<>
struct SubKey<unsigned int> : SizedSubKey<sizeof(unsigned int)> {};
template<>
struct SubKey<unsigned long> : SizedSubKey<sizeof(unsigned long)> {};
template<>
struct SubKey<unsigned long long> : SizedSubKey<sizeof(unsigned long long)> {};
template<typename T>
struct SubKey<T *> : SizedSubKey<sizeof(T *)> {};
template<typename F, typename S, typename Current>
struct PairSecondSubKey : Current {
	static decltype(auto) sub_key(const std::pair<F, S> & value, void * sort_data) {
		return Current::sub_key(value.second, sort_data);
	}

	using next = typename std::conditional<std::is_same<SubKey<void>, typename Current::next>::value, SubKey<void>, PairSecondSubKey<F, S, typename Current::next>>::type;
};
template<typename F, typename S, typename Current>
struct PairFirstSubKey : Current {
	static decltype(auto) sub_key(const std::pair<F, S> & value, void * sort_data) {
		return Current::sub_key(value.first, sort_data);
	}

	using next = typename std::conditional<std::is_same<SubKey<void>, typename Current::next>::value, PairSecondSubKey<F, S, SubKey<S>>, PairFirstSubKey<F, S, typename Current::next>>::type;
};
template<typename F, typename S>
struct SubKey<std::pair<F, S>> : PairFirstSubKey<F, S, SubKey<F>> {};
template<size_t Index, typename First, typename... More>
struct TypeAt : TypeAt<Index - 1, More..., void> {};
template<typename First, typename... More>
struct TypeAt<0, First, More...> {
	typedef First type;
};

template<size_t Index, typename Current, typename First, typename... More>
struct TupleSubKey;

template<size_t Index, typename Next, typename First, typename... More>
struct NextTupleSubKey {
	using type = TupleSubKey<Index, Next, First, More...>;
};
template<size_t Index, typename First, typename Second, typename... More>
struct NextTupleSubKey<Index, SubKey<void>, First, Second, More...> {
	using type = TupleSubKey<Index + 1, SubKey<Second>, Second, More...>;
};
template<size_t Index, typename First>
struct NextTupleSubKey<Index, SubKey<void>, First> {
	using type = SubKey<void>;
};

template<size_t Index, typename Current, typename First, typename... More>
struct TupleSubKey : Current {
	template<typename Tuple>
	static decltype(auto) sub_key(const Tuple & value, void * sort_data) {
		return Current::sub_key(std::get<Index>(value), sort_data);
	}

	using next = typename NextTupleSubKey<Index, typename Current::next, First, More...>::type;
};
template<size_t Index, typename Current, typename First>
struct TupleSubKey<Index, Current, First> : Current {
	template<typename Tuple>
	static decltype(auto) sub_key(const Tuple & value, void * sort_data) {
		return Current::sub_key(std::get<Index>(value), sort_data);
	}

	using next = typename NextTupleSubKey<Index, typename Current::next, First>::type;
};
template<typename First, typename... More>
struct SubKey<std::tuple<First, More...>> : TupleSubKey<0, SubKey<First>, First, More...> {};

struct BaseListSortData {
	size_t current_index;
	size_t recursion_limit;
	void * next_sort_data;
};
template<typename It, typename ExtractKey>
struct ListSortData : BaseListSortData {
	void(*next_sort)(It, It, std::ptrdiff_t, ExtractKey &, void *);
};

template<typename CurrentSubKey, typename T>
struct ListElementSubKey : SubKey<typename std::decay<decltype(std::declval<T>()[0])>::type> {
	using base = SubKey<typename std::decay<decltype(std::declval<T>()[0])>::type>;

	using next = ListElementSubKey;

	template<typename U>
	static decltype(auto) sub_key(U && value, void * sort_data) {
		BaseListSortData * list_sort_data = static_cast<BaseListSortData *>(sort_data);
		const T & list = CurrentSubKey::sub_key(value, list_sort_data->next_sort_data);
		return base::sub_key(list[list_sort_data->current_index], list_sort_data->next_sort_data);
	}
};

template<typename T>
struct ListSubKey {
	using next = SubKey<void>;

	using sub_key_type = T;

	static const T & sub_key(const T & value, void *) {
		return value;
	}
};

template<typename T>
struct FallbackSubKey<T, typename std::enable_if<has_subscript_operator<T>::value>::type> : ListSubKey<T> {};

template<typename It, typename ExtractKey>
inline void StdSortFallback(It begin, It end, ExtractKey & extract_key) {
	std::sort(begin, end, [&](auto && l, auto && r) { return extract_key(l) < extract_key(r); });
}

template<std::ptrdiff_t StdSortThreshold, typename It, typename ExtractKey>
inline bool StdSortIfLessThanThreshold(It begin, It end, std::ptrdiff_t num_elements, ExtractKey & extract_key) {
	if (num_elements <= 1)
		return true;
	if (num_elements >= StdSortThreshold)
		return false;
	StdSortFallback(begin, end, extract_key);
	return true;
}

template<std::ptrdiff_t StdSortThreshold, std::ptrdiff_t AmericanFlagSortThreshold, typename CurrentSubKey, typename SubKeyType = typename CurrentSubKey::sub_key_type>
struct InplaceSorter;

template<std::ptrdiff_t StdSortThreshold, std::ptrdiff_t AmericanFlagSortThreshold, typename CurrentSubKey, size_t NumBytes, size_t Offset = 0>
struct UnsignedInplaceSorter {
	static constexpr size_t ShiftAmount = (((NumBytes - 1) - Offset) * 8);
	template<typename T>
	inline static uint8_t current_byte(T && elem, void * sort_data) {
		return CurrentSubKey::sub_key(elem, sort_data) >> ShiftAmount;
	}
	template<typename It, typename ExtractKey>
	static void sort(It begin, It end, std::ptrdiff_t num_elements, ExtractKey & extract_key, void(*next_sort)(It, It, std::ptrdiff_t, ExtractKey &, void *), void * sort_data) {
		if (num_elements < AmericanFlagSortThreshold)
			american_flag_sort(begin, end, extract_key, next_sort, sort_data);
		else
			ska_byte_sort(begin, end, extract_key, next_sort, sort_data);
	}

	template<typename It, typename ExtractKey>
	static void american_flag_sort(It begin, It end, ExtractKey & extract_key, void(*next_sort)(It, It, std::ptrdiff_t, ExtractKey &, void *), void * sort_data) {
		PartitionInfo partitions[256];
		for (It it = begin; it != end; ++it) {
			++partitions[current_byte(extract_key(*it), sort_data)].count;
		}
		size_t total = 0;
		uint8_t remaining_partitions[256];
		int num_partitions = 0;
		for (int i = 0; i < 256; ++i) {
			size_t count = partitions[i].count;
			if (!count)
				continue;
			partitions[i].offset = total;
			total += count;
			partitions[i].next_offset = total;
			remaining_partitions[num_partitions] = i;
			++num_partitions;
		}
		if (num_partitions > 1) {
			uint8_t * current_block_ptr = remaining_partitions;
			PartitionInfo * current_block = partitions + *current_block_ptr;
			uint8_t * last_block = remaining_partitions + num_partitions - 1;
			It it = begin;
			It block_end = begin + current_block->next_offset;
			It last_element = end - 1;
			for (;;) {
				PartitionInfo * block = partitions + current_byte(extract_key(*it), sort_data);
				if (block == current_block) {
					++it;
					if (it == last_element)
						break;
					else if (it == block_end) {
						for (;;) {
							++current_block_ptr;
							if (current_block_ptr == last_block)
								goto recurse;
							current_block = partitions + *current_block_ptr;
							if (current_block->offset != current_block->next_offset)
								break;
						}

						it = begin + current_block->offset;
						block_end = begin + current_block->next_offset;
					}
				}
				else {
					size_t offset = block->offset++;
					std::iter_swap(it, begin + offset);
				}
			}
		}
	recurse:
		if (Offset + 1 != NumBytes || next_sort) {
			size_t start_offset = 0;
			It partition_begin = begin;
			for (uint8_t * it = remaining_partitions, *end = remaining_partitions + num_partitions; it != end; ++it) {
				size_t end_offset = partitions[*it].next_offset;
				It partition_end = begin + end_offset;
				std::ptrdiff_t num_elements = end_offset - start_offset;
				if (!StdSortIfLessThanThreshold<StdSortThreshold>(partition_begin, partition_end, num_elements, extract_key)) {
					UnsignedInplaceSorter<StdSortThreshold, AmericanFlagSortThreshold, CurrentSubKey, NumBytes, Offset + 1>::sort(partition_begin, partition_end, num_elements, extract_key, next_sort, sort_data);
				}
				start_offset = end_offset;
				partition_begin = partition_end;
			}
		}
	}

	template<typename It, typename ExtractKey>
	static void ska_byte_sort(It begin, It end, ExtractKey & extract_key, void(*next_sort)(It, It, std::ptrdiff_t, ExtractKey &, void *), void * sort_data) {
		PartitionInfo partitions[256];
		for (It it = begin; it != end; ++it) {
			++partitions[current_byte(extract_key(*it), sort_data)].count;
		}
		uint8_t remaining_partitions[256];
		size_t total = 0;
		int num_partitions = 0;
		for (int i = 0; i < 256; ++i) {
			size_t count = partitions[i].count;
			if (count) {
				partitions[i].offset = total;
				total += count;
				remaining_partitions[num_partitions] = i;
				++num_partitions;
			}
			partitions[i].next_offset = total;
		}
		for (uint8_t * last_remaining = remaining_partitions + num_partitions, *end_partition = remaining_partitions + 1; last_remaining > end_partition;) {
			last_remaining = custom_std_partition(remaining_partitions, last_remaining, [&](uint8_t partition) {
				size_t & begin_offset = partitions[partition].offset;
				size_t & end_offset = partitions[partition].next_offset;
				if (begin_offset == end_offset)
					return false;

				unroll_loop_four_times(begin + begin_offset, end_offset - begin_offset, [partitions = partitions, begin, &extract_key, sort_data](It it) {
					uint8_t this_partition = current_byte(extract_key(*it), sort_data);
					size_t offset = partitions[this_partition].offset++;
					std::iter_swap(it, begin + offset);
				});
				return begin_offset != end_offset;
			});
		}
		if (Offset + 1 != NumBytes || next_sort) {
			for (uint8_t * it = remaining_partitions + num_partitions; it != remaining_partitions; --it) {
				uint8_t partition = it[-1];
				size_t start_offset = (partition == 0 ? 0 : partitions[partition - 1].next_offset);
				size_t end_offset = partitions[partition].next_offset;
				It partition_begin = begin + start_offset;
				It partition_end = begin + end_offset;
				std::ptrdiff_t num_elements = end_offset - start_offset;
				if (!StdSortIfLessThanThreshold<StdSortThreshold>(partition_begin, partition_end, num_elements, extract_key)) {
					UnsignedInplaceSorter<StdSortThreshold, AmericanFlagSortThreshold, CurrentSubKey, NumBytes, Offset + 1>::sort(partition_begin, partition_end, num_elements, extract_key, next_sort, sort_data);
				}
			}
		}
	}
};

template<std::ptrdiff_t StdSortThreshold, std::ptrdiff_t AmericanFlagSortThreshold, typename CurrentSubKey, size_t NumBytes>
struct UnsignedInplaceSorter<StdSortThreshold, AmericanFlagSortThreshold, CurrentSubKey, NumBytes, NumBytes> {
	template<typename It, typename ExtractKey>
	inline static void sort(It begin, It end, std::ptrdiff_t num_elements, ExtractKey & extract_key, void(*next_sort)(It, It, std::ptrdiff_t, ExtractKey &, void *), void * next_sort_data) {
		next_sort(begin, end, num_elements, extract_key, next_sort_data);
	}
};

template<typename It, typename ExtractKey, typename ElementKey>
size_t CommonPrefix(It begin, It end, size_t start_index, ExtractKey && extract_key, ElementKey && element_key) {
	const auto & largest_match_list = extract_key(*begin);
	size_t largest_match = largest_match_list.size();
	if (largest_match == start_index)
		return start_index;
	for (++begin; begin != end; ++begin) {
		const auto & current_list = extract_key(*begin);
		size_t current_size = current_list.size();
		if (current_size < largest_match) {
			largest_match = current_size;
			if (largest_match == start_index)
				return start_index;
		}
		if (element_key(largest_match_list[start_index]) != element_key(current_list[start_index]))
			return start_index;
		for (size_t i = start_index + 1; i < largest_match; ++i) {
			if (element_key(largest_match_list[i]) != element_key(current_list[i])) {
				largest_match = i;
				break;
			}
		}
	}
	return largest_match;
}

template<std::ptrdiff_t StdSortThreshold, std::ptrdiff_t AmericanFlagSortThreshold, typename CurrentSubKey, typename ListType>
struct ListInplaceSorter {
	using ElementSubKey = ListElementSubKey<CurrentSubKey, ListType>;
	template<typename It, typename ExtractKey>
	static void sort(It begin, It end, ExtractKey & extract_key, ListSortData<It, ExtractKey> * sort_data) {
		size_t current_index = sort_data->current_index;
		void * next_sort_data = sort_data->next_sort_data;
		auto current_key = [&](auto && elem) -> decltype(auto) {
			return CurrentSubKey::sub_key(extract_key(elem), next_sort_data);
		};
		auto element_key = [&](auto && elem) -> decltype(auto) {
			return ElementSubKey::base::sub_key(elem, sort_data);
		};
		sort_data->current_index = current_index = CommonPrefix(begin, end, current_index, current_key, element_key);
		It end_of_shorter_ones = std::partition(begin, end, [&](auto && elem) {
			return current_key(elem).size() <= current_index;
		});
		std::ptrdiff_t num_shorter_ones = end_of_shorter_ones - begin;
		if (sort_data->next_sort && !StdSortIfLessThanThreshold<StdSortThreshold>(begin, end_of_shorter_ones, num_shorter_ones, extract_key)) {
			sort_data->next_sort(begin, end_of_shorter_ones, num_shorter_ones, extract_key, next_sort_data);
		}
		std::ptrdiff_t num_elements = end - end_of_shorter_ones;
		if (!StdSortIfLessThanThreshold<StdSortThreshold>(end_of_shorter_ones, end, num_elements, extract_key)) {
			void(*sort_next_element)(It, It, std::ptrdiff_t, ExtractKey &, void *) = static_cast<void(*)(It, It, std::ptrdiff_t, ExtractKey &, void *)>(&sort_from_recursion);
			InplaceSorter<StdSortThreshold, AmericanFlagSortThreshold, ElementSubKey>::sort(end_of_shorter_ones, end, num_elements, extract_key, sort_next_element, sort_data);
		}
	}

	template<typename It, typename ExtractKey>
	static void sort_from_recursion(It begin, It end, std::ptrdiff_t, ExtractKey & extract_key, void * next_sort_data) {
		ListSortData<It, ExtractKey> offset = *static_cast<ListSortData<It, ExtractKey> *>(next_sort_data);
		++offset.current_index;
		--offset.recursion_limit;
		if (offset.recursion_limit == 0) {
			StdSortFallback(begin, end, extract_key);
		}
		else {
			sort(begin, end, extract_key, &offset);
		}
	}


	template<typename It, typename ExtractKey>
	static void sort(It begin, It end, std::ptrdiff_t, ExtractKey & extract_key, void(*next_sort)(It, It, std::ptrdiff_t, ExtractKey &, void *), void * next_sort_data) {
		ListSortData<It, ExtractKey> offset;
		offset.current_index = 0;
		offset.recursion_limit = 16;
		offset.next_sort = next_sort;
		offset.next_sort_data = next_sort_data;
		sort(begin, end, extract_key, &offset);
	}
};

template<std::ptrdiff_t StdSortThreshold, std::ptrdiff_t AmericanFlagSortThreshold, typename CurrentSubKey>
struct InplaceSorter<StdSortThreshold, AmericanFlagSortThreshold, CurrentSubKey, bool> {
	template<typename It, typename ExtractKey>
	static void sort(It begin, It end, std::ptrdiff_t, ExtractKey & extract_key, void(*next_sort)(It, It, std::ptrdiff_t, ExtractKey &, void *), void * sort_data) {
		It middle = std::partition(begin, end, [&](auto && a) { return !CurrentSubKey::sub_key(extract_key(a), sort_data); });
		if (next_sort) {
			next_sort(begin, middle, middle - begin, extract_key, sort_data);
			next_sort(middle, end, end - middle, extract_key, sort_data);
		}
	}
};

template<std::ptrdiff_t StdSortThreshold, std::ptrdiff_t AmericanFlagSortThreshold, typename CurrentSubKey>
struct InplaceSorter<StdSortThreshold, AmericanFlagSortThreshold, CurrentSubKey, uint8_t> : UnsignedInplaceSorter<StdSortThreshold, AmericanFlagSortThreshold, CurrentSubKey, 1> {};
template<std::ptrdiff_t StdSortThreshold, std::ptrdiff_t AmericanFlagSortThreshold, typename CurrentSubKey>
struct InplaceSorter<StdSortThreshold, AmericanFlagSortThreshold, CurrentSubKey, uint16_t> : UnsignedInplaceSorter<StdSortThreshold, AmericanFlagSortThreshold, CurrentSubKey, 2> {};
template<std::ptrdiff_t StdSortThreshold, std::ptrdiff_t AmericanFlagSortThreshold, typename CurrentSubKey>
struct InplaceSorter<StdSortThreshold, AmericanFlagSortThreshold, CurrentSubKey, uint32_t> : UnsignedInplaceSorter<StdSortThreshold, AmericanFlagSortThreshold, CurrentSubKey, 4> {};
template<std::ptrdiff_t StdSortThreshold, std::ptrdiff_t AmericanFlagSortThreshold, typename CurrentSubKey>
struct InplaceSorter<StdSortThreshold, AmericanFlagSortThreshold, CurrentSubKey, uint64_t> : UnsignedInplaceSorter<StdSortThreshold, AmericanFlagSortThreshold, CurrentSubKey, 8> {};
template<std::ptrdiff_t StdSortThreshold, std::ptrdiff_t AmericanFlagSortThreshold, typename CurrentSubKey, typename SubKeyType, typename Enable = void>
struct FallbackInplaceSorter;

template<std::ptrdiff_t StdSortThreshold, std::ptrdiff_t AmericanFlagSortThreshold, typename CurrentSubKey, typename SubKeyType>
struct InplaceSorter : FallbackInplaceSorter<StdSortThreshold, AmericanFlagSortThreshold, CurrentSubKey, SubKeyType> {};

template<std::ptrdiff_t StdSortThreshold, std::ptrdiff_t AmericanFlagSortThreshold, typename CurrentSubKey, typename SubKeyType>
struct FallbackInplaceSorter<StdSortThreshold, AmericanFlagSortThreshold, CurrentSubKey, SubKeyType, typename std::enable_if<has_subscript_operator<SubKeyType>::value>::type>
	: ListInplaceSorter<StdSortThreshold, AmericanFlagSortThreshold, CurrentSubKey, SubKeyType> {};

template<std::ptrdiff_t StdSortThreshold, std::ptrdiff_t AmericanFlagSortThreshold, typename CurrentSubKey>
struct SortStarter;
template<std::ptrdiff_t StdSortThreshold, std::ptrdiff_t AmericanFlagSortThreshold>
struct SortStarter<StdSortThreshold, AmericanFlagSortThreshold, SubKey<void>> {
	template<typename It, typename ExtractKey>
	static void sort(It, It, std::ptrdiff_t, ExtractKey &, void *) {}
};

template<std::ptrdiff_t StdSortThreshold, std::ptrdiff_t AmericanFlagSortThreshold, typename CurrentSubKey>
struct SortStarter {
	template<typename It, typename ExtractKey>
	static void sort(It begin, It end, std::ptrdiff_t num_elements, ExtractKey & extract_key, void * next_sort_data = nullptr) {
		if (StdSortIfLessThanThreshold<StdSortThreshold>(begin, end, num_elements, extract_key))
			return;

		void(*next_sort)(It, It, std::ptrdiff_t, ExtractKey &, void *) = static_cast<void(*)(It, It, std::ptrdiff_t, ExtractKey &, void *)>(&SortStarter<StdSortThreshold, AmericanFlagSortThreshold, typename CurrentSubKey::next>::sort);
		if (next_sort == static_cast<void(*)(It, It, std::ptrdiff_t, ExtractKey &, void *)>(&SortStarter<StdSortThreshold, AmericanFlagSortThreshold, SubKey<void>>::sort))
			next_sort = nullptr;
		InplaceSorter<StdSortThreshold, AmericanFlagSortThreshold, CurrentSubKey>::sort(begin, end, num_elements, extract_key, next_sort, next_sort_data);
	}
};

template<std::ptrdiff_t StdSortThreshold, std::ptrdiff_t AmericanFlagSortThreshold, typename It, typename ExtractKey>
void inplace_radix_sort(It begin, It end, ExtractKey & extract_key) {
	using SubKey = SubKey<decltype(extract_key(*begin))>;
	SortStarter<StdSortThreshold, AmericanFlagSortThreshold, SubKey>::sort(begin, end, end - begin, extract_key);
}

struct IdentityFunctor {
	template<typename T>
	decltype(auto) operator()(T && i) const {
		return std::forward<T>(i);
	}
};
}

template<typename It, typename ExtractKey>
static void americanflag_sort(It begin, It end, ExtractKey && extract_key) {
	::detail::inplace_radix_sort<0, INT32_MAX>(begin, end, extract_key);
}

template<typename It, typename ExtractKey>
static void ska_sort(It begin, It end, ExtractKey && extract_key) {
	::detail::inplace_radix_sort<128, 1024>(begin, end, extract_key);
}

template<typename It>
static void ska_sort(It begin, It end) {
	ska_sort(begin, end, ::detail::IdentityFunctor());
}

template<typename It, typename OutIt, typename ExtractKey>
bool ska_sort_copy(It begin, It end, OutIt buffer_begin, ExtractKey && key) {
	std::ptrdiff_t num_elements = end - begin;
	if (num_elements < 128 || ::detail::radix_sort_pass_count<typename std::result_of<ExtractKey(decltype(*begin))>::type> >= 8) {
		ska_sort(begin, end, key);
		return false;
	}
	else
		return ::detail::RadixSorter<typename std::result_of<ExtractKey(decltype(*begin))>::type>::sort(begin, end, buffer_begin, key);
}
template<typename It, typename OutIt>
bool ska_sort_copy(It begin, It end, OutIt buffer_begin) {
	return ska_sort_copy(begin, end, buffer_begin, ::detail::IdentityFunctor());
}

template<typename T, typename C>
inline void skasort(T _First, T _Last, C compare) {
	ska_sort(_First, _Last);
}

template<typename T>
inline void skasort(T _First, T _Last) {
	ska_sort(_First, _Last);
}

template<class T, class C>
static void americanflagsort(T _First, T _Last, C compare) {
	americanflag_sort(_First, _Last, ::detail::IdentityFunctor());
}

//template<class T, class C>
//inline void countingsort(T _First, T _Last, C compare) {
//	auto len = std::distance(_First, _Last);
//	std::vector<typename T::value_type> _Dest(len);
//	::detail::counting_sort_impl<typename T::value_type>(_First, _Last, _Dest.begin(), ::detail::IdentityFunctor());
//	for (auto i = 0; i < len; ++i) 
//		*(_First + i) = _Dest[i];
//}





















~-----------------------------------------------~
C:\Users\Josh\Documents\Visual Studio 2017\Projects\Sorting\Sorting\smoothsort.h
~-----------------------------------------------~
#pragma once

/**
	**  SmoothSort function template + helper functions.
	**
	**    Formal type T should have a comparison operator >= with prototype:
	**
	**      bool T::operator >= (const T &) const throw ();
	**
	**    which should compare its arguments by the given relation
	**     (possibly taking advantage of the type itself).
	**
	**
	**/



	/**  Sort an array in ascending order.  **/
template <typename T, typename C>
void smoothsort(T, unsigned, C) throw ();



namespace

	/**
	 **  Helper function's local namespace (declarations).
	 **
	 **/

{
	class LeonardoNumber

		/**
		 **  Helper class for manipulation of Leonardo numbers
		 **
		 **/

	{
	public:
		/**  Default ctor.  **/
		LeonardoNumber(void) throw () : b(1), c(1) { return; }

		/**  Copy ctor.  **/
		LeonardoNumber(const LeonardoNumber & _l) throw () : b(_l.b), c(_l.c) { return; }

		/**
		 **  Return the "gap" between the actual Leonardo number and the
		 **  preceding one.
		 **/
		unsigned gap(void) const throw () { return b - c; }


		/**  Perform an "up" operation on the actual number.  **/
		LeonardoNumber & operator ++ (void) throw () { unsigned s = b; b = b + c + 1; c = s; return *this; }

		/**  Perform a "down" operation on the actual number.  **/
		LeonardoNumber & operator -- (void) throw () { unsigned s = c; c = b - c - 1; b = s; return *this; }

		/**  Return "companion" value.  **/
		unsigned operator ~ (void) const throw () { return c; }

		/**  Return "actual" value.  **/
		operator unsigned(void) const throw () { return b; }


	private:
		unsigned b;   /**  Actual number.  **/
		unsigned c;   /**  Companion number.  **/
	};


	/**  Perform a "sift up" operation.  **/
	template <typename T, typename C>
	inline void sift(T, unsigned, LeonardoNumber, C) throw ();

	/**  Perform a "semi-trinkle" operation.  **/
	template <typename T, typename C>
	inline void semitrinkle(T, unsigned, unsigned long long, LeonardoNumber, C) throw ();

	/**  Perform a "trinkle" operation.  **/
	template <typename T, typename C>
	inline void trinkle(T, unsigned, unsigned long long, LeonardoNumber, C) throw ();
}

template <typename T, typename C>
void smoothsort(T _m, unsigned _n, C compare) throw ()

/**
 **  Sorts the given array in ascending order.
 **
 **    Usage: smoothsort (<array>, <size>)
 **
 **    Where: <array> pointer to the first element of the array in question.
 **            <size> length of the array to be sorted.
 **
 **
 **/

{
	//	if (!(_m && _n)) return;

	unsigned long long p = 1;
	LeonardoNumber b;

	for (unsigned q = 0; ++q < _n; ++p)
		if (p % 8 == 3) {
			sift<T, C>(_m, q - 1, b, compare);

			++++b; p >>= 2;
		}

		else if (p % 4 == 1) {
			if (q + ~b < _n)  sift<T, C>(_m, q - 1, b, compare);
			else  trinkle<T, C>(_m, q - 1, p, b, compare);

			for (p <<= 1; --b > 1; p <<= 1);
		}

	trinkle<T, C>(_m, _n - 1, p, b, compare);

	for (--p; _n-- > 1; --p)
		if (b == 1)
			for (; !(p % 2); p >>= 1)  ++b;

		else if (b >= 3) {
			if (p)  semitrinkle<T, C>(_m, _n - b.gap(), p, b, compare);

			--b; p <<= 1; ++p;
			semitrinkle<T, C>(_m, _n - 1, p, b, compare);
			--b; p <<= 1; ++p;
		}


	return;
}

namespace

	/**
	 **  Helper function's local namespace (definitions).
	 **
	 **/

{
	template <typename T, typename C>
	inline void sift(T _m, unsigned _r, LeonardoNumber _b, C compare) throw ()

		/**
		 **  Sifts up the root of the stretch in question.
		 **
		 **    Usage: sift (<array>, <root>, <number>)
		 **
		 **    Where:     <array> Pointer to the first element of the array in
		 **                       question.
		 **                <root> Index of the root of the array in question.
		 **              <number> Current Leonardo number.
		 **
		 **
		 **/

	{
		unsigned r2;

		while (_b >= 3) {
			if (!compare(_m[_r - _b.gap()], _m[_r - 1]))
				r2 = _r - _b.gap();
			else { r2 = _r - 1; --_b; }

			if (!compare(_m[_r], _m[r2]))  break;
			else { iter_swap((_m + _r), (_m + r2)); _r = r2; --_b; }
		}


		return;
	}


	template <typename T, typename C>
	inline void semitrinkle(T _m, unsigned _r, unsigned long long _p,
		LeonardoNumber _b, C compare) throw ()

		/**
		 **  Trinkles the roots of the stretches of a given array and root when the
		 **  adjacent stretches are trusty.
		 **
		 **    Usage: semitrinkle (<array>, <root>, <standard_concat>, <number>)
		 **
		 **    Where:           <array> Pointer to the first element of the array in
		 **                             question.
		 **                      <root> Index of the root of the array in question.
		 **           <standard_concat> Standard concatenation's codification.
		 **                    <number> Current Leonardo number.
		 **
		 **
		 **/

	{
		if (!compare(_m[_r - ~_b], _m[_r])) {
			iter_swap((_m + _r), (_m + (_r - ~_b)));
			trinkle<T, C>(_m, _r - ~_b, _p, _b, compare);
		}


		return;
	}


	template <typename T, typename C>
	inline void trinkle(T _m, unsigned _r, unsigned long long _p,
		LeonardoNumber _b, C compare) throw ()

		/**
		 **  Trinkles the roots of the stretches of a given array and root.
		 **
		 **    Usage: trinkle (<array>, <root>, <standard_concat>, <number>)
		 **
		 **    Where:           <array> Pointer to the first element of the array in
		 **                             question.
		 **                      <root> Index of the root of the array in question.
		 **           <standard_concat> Standard concatenation's codification.
		 **                    <number> Current Leonardo number.
		 **
		 **
		 **/

	{
		while (_p) {
			for (; !(_p % 2); _p >>= 1)  ++_b;

			if (!--_p || !compare(_m[_r], _m[_r - _b]))  break;
			else
				if (_b == 1) { iter_swap((_m + _r), (_m + _r - _b)); _r -= _b; }

				else if (_b >= 3) {
					unsigned r2 = _r - _b.gap(), r3 = _r - _b;

					if (!compare(_m[_r - 1], _m[r2])) { r2 = _r - 1; _p <<= 1; --_b; }

					if (!compare(_m[r3], _m[r2])) { iter_swap((_m + _r), (_m + r3)); _r = r3; }

					else { iter_swap((_m + _r), (_m + r2)); _r = r2; --_b; break; }
				}
		}

		sift<T, C>(_m, _r, _b, compare);


		return;
	}
}

template<class T, class C>
inline void smoothsort(T _First, T _Last, C compare) {
	smoothsort(_First, (unsigned)std::distance(_First, _Last), compare);
}

template<class T>
inline void smoothsort(T _First, T _Last) {
	smoothsort(_First, _Last, std::less<>());
}


























~-----------------------------------------------~
C:\Users\Josh\Documents\Visual Studio 2017\Projects\Sorting\Sorting\softheapsort.h
~-----------------------------------------------~
#pragma once

#include "insertionsort.h"

/* File: softheap.h
 * Developer: Matt Millican, May 2016
 * ----------------------------------
 * Implementation of a soft heap. Rather than the version using binomial trees
 * introduced in Chazelle's original paper, this soft heap uses binary trees
 * according to the strategy outlined in Kaplan/Zwick, 2009.
 */

#include <stdlib.h>
#include <assert.h> // for assert
#include <math.h> // For log and ceil. Remember to link math library!

 /* An item in a soft heap tree node's list. */
template<class T>
struct cell {
	T elem;
	cell<T> *next;
};

/* A node in a tree in a soft heap. The node has access to its left and right children,
 * but does not need access to its parent. It contains a ckey (its priority), its rank,
 * the number of elements in its list, and its "size": a parameter defined such that
 * its list always contains Theta(size) elements so long as the node is not a leaf.
 * Its list is stored as a doubly linked list. */
template<class T>
struct node {
	node<T> *left, *right;
	cell<T> *first, *last;
	int ckey, rank, size, nelems;
};

/* Structure representing a binary tree in a soft heap's rootlist. The tree stores
 * its rank, which is the maximum possible height of its root (although the
 * root is not guaranteed to have that height at all times). The tree
 * is wired to its predecessor and successor in the rootlist, which have
 * rank less than and greater than this tree's rank, respectively.
 * The tree also has a pointer to its own root.
 *
 * Binary trees in a soft-heap are heap-ordered according to the "ckeys" of the nodes
 * in the trees. Each node stores a list of items under one ckey; the ckey is
 * an upper bound on the original priorities of all items in the node's list.
 * The final element of a softheap tree is a pointer "sufmin" to the tree of minimum
 * root ckey in the segment of the rootlist beginning at this tree.
 */
template<class T>
struct tree {
	tree<T> *prev, *next, *sufmin;
	node<T> *root;
	int rank;
};


/* Structure representing a soft heap. The soft heap object has access
 * to the first tree in its root list, the rank of the highest-order tree
 * in its root list, its error parameter epsilon, and the parameter
 * r(epsilon) that defines the maximum node rank for which a node
 * is guaranteed to contain only uncorrupted elements. */
template<class T>
struct softheap {
	tree<T> *first;
	int rank;
	double epsilon;
	int r;
};

/***************************************** UTILITY FUNCTIONS **************************************/

/* Function: leaf
 * --------------
 * Return true if and only if this soft heap tree node
 * has no children.
 */
template<class T>
static inline bool leaf(node<T> *x) {
	return (x->left == NULL && x->right == NULL);
}

/* Function: get_r
 * ---------------
 * Return the parameter r(epsilon) for this soft heap.
 * r is the largest integer such that a node of that rank
 * contains only uncorrupted elements.
 */
static inline int get_r(double epsilon) {
	return (int)ceil(-log(epsilon) / log(2)) + 5;
}

/* Function: swapLR
 * ----------------
 * Swap the left and right children of this node.
 */
template<class T>
static inline void swapLR(node<T> *x) {
	node<T> *tmp = x->left;
	x->left = x->right;
	x->right = tmp;
}

/* Function: get_next_size
 * -----------------------
 * Get the size of a soft heap node with given rank.
 * Given a parameter r(epsilon) for a soft heap, the size
 * of a node of rank k is 1 (if k <= r) or ceil(3/2 * size(k-1))
 * otherwise.
 */
static inline int get_next_size(int rank, int prevrank_size, int r) {
	if (rank <= r) return 1;
	return (3 * prevrank_size + 1) / 2;
}

/**************************************** HEAP & ITEM CREATION *************************************/

/* Function: addcell
 * -----------------
 * Creates a list cell containing the parameter element
 * and concatenates it to the end of the linked list pointed
 * to by listend.
 */
template<class T>
static cell<T> *addcell(T elem, cell<T> *listend) {
	cell<T>* c = (cell<T>*)malloc(sizeof(cell<T>));
	c->elem = elem;
	if (listend != NULL) listend->next = c;
	c->next = NULL;
	return c;
}

/* Function: makenode
 * ------------------
 * Constructs a rank-0 soft heap binary tree node containing just the parameter
 * element. Its ckey matches the element, since that element is the only
 * object in its list.
 */
template<class T>
static node<T> *makenode(T elem) {
	node<T> *x = (node<T>*)malloc(sizeof(node<T>));
	x->first = x->last = addcell<T>(elem, NULL);
	x->ckey = elem;
	x->rank = 0;
	x->size = x->nelems = 1;
	x->left = x->right = NULL;
	return x;
}

/* Function: maketree
 * ------------------
 * Constructs a soft heap binary tree consisting of exactly one node
 * housing the parameter element.
 */
template<class T>
static tree<T> *maketree(T elem) {
	tree<T> *Tree = (tree<T>*)malloc(sizeof(tree<T>));
	Tree->root = makenode(elem);
	Tree->prev = Tree->next = NULL;
	Tree->rank = 0;
	Tree->sufmin = Tree;
	return Tree;
}

/* Function: makeheap_empty
 * ------------------------
 * Constructs an empty soft heap with the provided error parameter.
 */
template<class T>
softheap<T>* makeheap_empty(double epsilon) {
	// Ensure error parameter is valid
	if (epsilon <= 0 || epsilon >= 1) return NULL;// error(1, 0, "Soft heap error parameter must fall in (0,1)");

	softheap<T>* s = (softheap<T>*)malloc(sizeof(softheap<T>));
	s->first = NULL;
	s->rank = -1; // Ensures that any insertion will just return the SH containing the inserted elem
	s->epsilon = epsilon;
	s->r = get_r(epsilon);
	return s;
}

/* Function: makeheap
 * ------------------
 * Construct a soft heap with error parameter epsilon containing element elem.
 * This is done by constructing a tree of rank 0 containing a single rank-0
 * node. The node has one item in its item list, which is the item inserted.
 */

template<class T>
softheap<T> *makeheap(T elem, double epsilon) {
	softheap<T> *s = makeheap_empty<T>(epsilon);
	s->first = maketree(elem);
	s->rank = 0;
	return s;
}

/* Function: destroy_node
 * ----------------------
 * Deallocates all the cells in this node's item list,
 * recursively destroys its left and right children,
 * then deallocates its memory. For use in destroy_heap.
 */
template<class T>
static void destroy_node(node<T> *treenode) {
	if (treenode == NULL) return;

	cell<T> *curr = treenode->first, *next;
	while (curr != NULL) {
		next = curr->next;
		free(curr);
		curr = next;
	}

	destroy_node(treenode->left);
	destroy_node(treenode->right);
	free(treenode);
}

/* Function: destroy_heap
 * ----------------------
 * Destroys this soft heap and deallocates all its associated memory
 * by iterating over its list of trees, destroying them all, and then
 * destroying the heap struct.
 */
template<class T>
void destroy_heap(softheap<T> *P) {
	if (P == NULL) return;

	tree<T> *curr = P->first, *next;
	while (curr != NULL) {
		next = curr->next;
		destroy_node(curr->root);
		free(curr);
		curr = next;
	}

	free(P);
}


/************************************ HEAP STRUCTURE MANIPULATION *********************************/

/* Function: moveList
 * ------------------
 * Remove the item list of src and append it to the end
 * of the item list of dst.
 */
template<class T>
static void moveList(node<T> *src, node<T> *dst) {
	assert(src->first != NULL);
	if (dst->last != NULL) dst->last->next = src->first;
	else dst->first = src->first;
	dst->last = src->last;

	dst->nelems += src->nelems;
	src->nelems = 0;
	src->first = src->last = NULL;
}

/* Function: sift
 * --------------
 * The primary reorganizational strategy of the soft heap, called whenever
 * a non-leaf soft heap tree node has fewer items in its list than it should
 * according to its rank. The parameter node x steals the item list and ckey
 * of whichever child has lower ckey, which pushes the length of its list above
 * its size paremeter while maintaining the heap property with respect to ckeys.
 * Then, to repair the child (which is now deficient as x once was), we recursively
 * call sift on the child (unless it was a leaf, in which case it cannot be repaired).
 * Once x's child has been repaired or destroyed, x itself may or may not still be
 * deficient; if it is still deficient and has not become a leaf, we repeat the process
 * of stealing from children and recursively repairing children until x is repaired or a leaf.
 */
template<class T>
static void sift(node<T> *x) {
	while (x->nelems < x->size && !leaf(x)) {
		// For simplicity, switch left and right children so that left child exists & has smaller ckey
		if (x->left == NULL || (x->right != NULL && x->left->ckey > x->right->ckey)) swapLR(x);
		moveList(x->left, x); // concat left's list to x's to replenish x
		x->ckey = x->left->ckey;

		// if left was a leaf, it can't be repaired, so destroy it
		if (leaf(x->left)) {
			free(x->left);
			x->left = NULL;
		}
		else {
			sift(x->left);
		}
	} // Repeat as necessary until x is repaired or until x is a leaf and no more repairs are possible
}

/* Function: combine
 * -----------------
 * Another important restructuring operation, used whenever we merge two trees of equal rank.
 * Creates a new node z with children x and y and rank 1 + rank(x), sets its size parameter,
 * and then fills its list by sifting through its children.
 */
template<class T>
static node<T> *combine(node<T> *x, node<T> *y, int r) {
	node<T> *z = (node<T>*)malloc(sizeof(node<T>));
	z->left = x;
	z->right = y;
	z->rank = x->rank + 1;
	z->nelems = 0;
	z->first = z->last = NULL;

	z->size = get_next_size(z->rank, x->size, r);
	sift(z);
	return z;
}

/* Function: insert_tree
 * ---------------------
 * Inserts a tree from the rootlist of some external heap into the rootlist of
 * into_heap, immediately before the tree pointed to by successor.
 * Wires it into the pointer structure of the heap as necessary, including
 * making it the first tree of into_heap if the tree pointed to by successor
 * has no predecessors.
 */
template<class T>
static void insert_tree(softheap<T> *into_heap, tree<T> *inserted, tree<T> *successor) {
	inserted->next = successor;

	if (successor->prev == NULL) into_heap->first = inserted;
	else successor->prev->next = inserted;
	inserted->prev = successor->prev;
	successor->prev = inserted;
}

/* Function: remove_tree
 * ---------------------
 * Removes the soft heap tree pointed to by removed from the parameter heap.
 * This entails wiring its predecessor and successor in the heap's rootlist
 * to each other (if they exist) and setting the heap's first tree to be
 * the removed tree's successor if the removed tree was the first in the rootlist.
 */
template<class T>
static void remove_tree(softheap<T> *outof_heap, tree<T> *removed) {
	if (removed->prev == NULL) outof_heap->first = removed->next;
	else removed->prev->next = removed->next;
	if (removed->next != NULL) removed->next->prev = removed->prev;
}

/* Function: update_suffix_min
 * ---------------------------
 * Updates the sufmin pointers of T and all trees preceding T in T's rootlist.
 * This should be done whenever heap restructuring affects a segment of the
 * rootlist ending at T, i.e. if an element is extracted from T, if T is the
 * final tree created by a soft heap meld, or if T's successor is removed.
 * Whenever any of these occur, the segment of the heap ending at T may have
 * a new root of minimum ckey, meaning every sufmin pointer until T must be edited.
 * Given the recursive definition of a sufmin pointer this is easy to revise by
 * moving backwards from T.
 */
template<class T>
static void update_suffix_min(tree<T> *Tree) {
	while (Tree != NULL) {
		if (Tree->next == NULL || Tree->root->ckey <= Tree->next->sufmin->root->ckey) Tree->sufmin = Tree;
		else Tree->sufmin = Tree->next->sufmin;
		Tree = Tree->prev;
	}
}

/* Function: merge_into
 * --------------------
 * The first step of soft heap melding. Given a soft heap P whose rank is no more
 * than that of heap Q, walk through the root lists of both heaps, placing each tree
 * from P immediately before the first tree of Q with equal or greater rank.
 */
template<class T>
static void merge_into(softheap<T> *P, softheap<T> *Q) {
	tree<T> *currP = P->first, *currQ = Q->first;

	while (currP != NULL) {
		while (currQ->rank < currP->rank) currQ = currQ->next;
		// currQ is now the first tree in Q with rank >= currP. Insert currP before it.
		tree<T> *next = currP->next;
		insert_tree(Q, currP, currQ);
		currP = next;
	}
}

/* Function: repeated_combine
 * --------------------------
 * The second step of soft heap melding. Now that all trees of equal rank from the
 * original two heaps are adjacent in the larger heap, this process simulates
 * binary addition using a binomial heap-like strategy in which trees of equal rank
 * are merged and the results are "carried" until a vacancy is found for the rank
 * of the resulting combined tree. We only operate on the heap until we find
 * a tree of rank greater than the smaller (original) heap's rank that doesn't need
 * to be merged with its successor, at which point no successor trees can possibly
 * have partners and merging is no longer necessary.
 */
template<class T>
static void repeated_combine(softheap<T> *Q, int smaller_rank, int r) {
	tree<T> *curr = Q->first;

	while (curr->next != NULL) {
		bool two = (curr->rank == curr->next->rank);
		bool three = (two && curr->next->next != NULL && curr->rank == curr->next->next->rank);

		if (!two) { // only one tree of this rank
			if (curr->rank > smaller_rank) break; // no more combines to do and no carries
			else curr = curr->next;
		}
		else if (!three) { // exactly two trees of this rank
	   // combine them to make a carry, then delete curr->next. 
	   // carry may need to be merged with its next tree, so do not advance curr.
			curr->root = combine(curr->root, curr->next->root, r);
			curr->rank = curr->root->rank;
			tree<T> *tofree = curr->next;
			remove_tree(Q, curr->next); // will change what curr->next points to
			free(tofree);
		}
		else { // exactly three trees of this rank
	   // skip the first so that we can combine the second and third to form a carry
			curr = curr->next;
		}
	}

	if (curr->rank > Q->rank) Q->rank = curr->rank; // Q might have a new highest-rank tree
	update_suffix_min(curr); // this is final tree affected by merge, so update sufmin backwds from here
}

/* Function: extract_elem
 * ----------------------
 * Remove the first element from the item list of node x and return it.
 * To reflect this change, decrement x's nelems counter, change the
 * element it points to as the first item, rewire the prev pointer
 * of the new first element to NULL (if it exists), and reset the
 * last pointer of x if the new list has one or no items.
 */
template<class T>
static int extract_elem(node<T> *x) {
	assert(x->first != NULL);
	cell<T> *todelete = x->first;
	T result = todelete->elem;

	x->first = todelete->next;
	if (x->first == NULL) x->last = NULL;
	else if (x->first->next == NULL) x->last = x->first;

	free(todelete);
	x->nelems--;
	return result;
}

/*************************************** CLIENT-SIDE OPERATIONS ************************************/

/* Function: empty
 * ---------------
 * Returns true if and only if P contains no trees,
 * i.e. it contains no elements.
 */
template<class T>
bool empty(softheap<T> *P) {
	return P->first == NULL;
}

/* Function: insert
 * ----------------
 * Put a new element into soft heap P. If P is nonempty, this can be accomplished
 * by creating a new soft heap for the parameter and melding it into P. However,
 * if P is empty, this strategy will destroy P and leave the client with a freed
 * pointer, so instead we directly insert a new tree containing elem into P's rootlist
 * and set its rank to 0.
 */
template<class T>
void insert(softheap<T> *P, T elem) {
	if (empty(P)) {
		P->first = maketree(elem);
		P->rank = 0;
	}
	else meld(P, makeheap(elem, P->epsilon));
}

/* Function: meld
 * --------------
 * Combine all elements of soft heaps P and Q into a new conglomerate heap,
 * destructively modifying P and Q. Return the result. This is implemented
 * by executing a merge_into to push all elements from the lower-rank heap
 * into the higher-rank heap, then calling repeated-combine to combine
 * all trees of duplicate rank.
 */
template<class T>
softheap<T> *meld(softheap<T> *P, softheap<T> *Q) {
	// Do not allow melding if the soft heaps don't seem to have the same error parameter.
	double max_eps = std::max(P->epsilon, Q->epsilon), min_eps = std::min(P->epsilon, Q->epsilon);
	double eps_off = 1 - min_eps / max_eps;
	if (eps_off > 0.001) return NULL;//error(1, 0, "Tried to combine soft heaps with different epsilons");

	// If both softheaps empty, just destroy one and return the other
	if (empty(P) && empty(Q)) {
		free(P);
		return Q;
	}

	softheap<T> *result;
	if (P->rank >= Q->rank) { // meld Q into P
		merge_into(Q, P);
		repeated_combine(P, Q->rank, P->r);
		free(Q);
		result = P;
	}
	else { // meld P into Q
		merge_into(P, Q);
		repeated_combine(Q, P->rank, Q->r);
		free(P);
		result = Q;
	}

	return result;
}

/* Function: extract_min
 * ----------------------
 * Extract and return an element from the node of minimum ckey
 * in the soft heap.
 */
template<class T>
int extract_min(softheap<T> *P) {
	int filler; // I'm just here to prevent code duplication
	return extract_min_with_ckey(P, &filler);
}

/* Function: extract_min_with_ckey
 * -------------------------------
 * Extract and return an element from the node of minimum ckey
 * in the soft heap, and store that ckey in the space pointed to
 * by ckey_into. The node of minimum ckey is the root of some
 * tree in the heap, by the heap property invariant. This tree
 * is pointed to by the sufmin pointer of the first tree in the rootlist.
 * After removing that element from the root, we check whether it is now
 * size-deficient. If so, we sift it (if it has children), ignore it
 * (if it has no children but is not empty), or destroy the tree
 * it roots (if it has no children and is empty). Once this is done, we
 * update the sufmin pointers of T and all its predecessors
 * (or just T's predecessors if T was removed).
 */
template<class T>
T extract_min_with_ckey(softheap<T> *P, int *ckey_into) {
	if (empty(P)) return -1;//error(1, 0, "Tried to extract an element from an empty soft heap");

	tree<T> *Tree = P->first->sufmin; // tree with lowest root ckey
	node<T> *x = Tree->root;
	T e = extract_elem(x);
	*ckey_into = x->ckey;

	if (x->nelems <= x->size / 2) { // x is deficient; rescue it if possible
		if (!leaf(x)) {
			sift(x);
			update_suffix_min(Tree);
		}
		else if (x->nelems == 0) { // x is a leaf and empty; it must be destroyed
			free(x);
			remove_tree(P, Tree);

			if (Tree->next == NULL) { // we removed the highest-ranked tree; reset heap rank and clean up
				if (Tree->prev == NULL) P->rank = -1; // Heap now empty. Rank -1 is sentinel for future melds
				else P->rank = Tree->prev->rank;
			}

			if (Tree->prev != NULL) update_suffix_min(Tree->prev);
			free(Tree);
		}
	}

	return e;
}

template<class T, class C>
inline void softheapsort(T _First, T _Last, C compare) {
	auto length = _Last - _First;
	if (length == 1) return;
	double epsilon = 1.0 / (double)length;
	epsilon = .99;
	if (epsilon <= 0) epsilon = DBL_MIN;

	softheap<T::value_type> *sh = makeheap_empty<T::value_type>(epsilon);
	for (T _Pos = _First; _Pos != _Last; ++_Pos)
		insert(sh, *_Pos);
	for (T _Pos = _First; _Pos != _Last; ++_Pos) 
		*_Pos = extract_min(sh);
	destroy_heap(sh);
	//insertionsort(_First, _Last, compare);
}

template<class T>
inline void softheapsort(T _First, T _Last) {
	softheapsort(_First, _Last, std::less<>());
}


























~-----------------------------------------------~
C:\Users\Josh\Documents\Visual Studio 2017\Projects\Sorting\Sorting\sorting.h
~-----------------------------------------------~
#pragma once

#define NOMINMAX
#undef min
#undef max

#include <Windows.h>
#include <vector>
#include <string>
#include <fstream>
#include <map>

//restores old val to var when ScopedVar goes out of scope
template<class T>
class ScopedVar {
	T* var;
	T oldval;
public:
	ScopedVar(T& v, const T& newval) {
		var = &v;
		oldval = v;
		v = newval;
	}
	~ScopedVar() {
		*var = oldval;
	}
};

template<class T>
struct Range {
	T min, max;

	Range() {}
	Range(T min, T max) {
		this->min = std::min(min, max);
		this->max = std::max(min, max);
	}

	inline T MapTo(const T& value, const Range& to) const {
		return Map(value, *this, to);
	}

	inline T MapFrom(const T& value, const Range& from) const {
		return Map(value, from, *this);
	}

	static inline T Map(const T& value, const Range& from, const Range& to) {
		T val = value;
		if (value < from.min) val = from.min;
		else if (from.max < value) val = from.max;
		return (((val - from.min) * (to.max - to.min)) / (from.max - from.min)) + to.min;
	}
};

template<class A, class B, class C> 
struct trio {
	A first;
	B mid;
	C last;
	trio(A a, B b, C c) : first(a), mid(b), last(c) {}
};

template<class T, class C>
inline trio<T, T, T> Sort3(T a, T b, T c, C compare) {
	if (compare(b, a)) 
		std::swap(b, a);
	if (compare(c, b)) {
		std::swap(c, b);
		if (compare(b, a)) 
			std::swap(b, a);
	}
	return trio<T, T, T>(a, b, c);
}
template<class T>
inline trio<T, T, T> Sort3(T a, T b, T c) {
	return Sort3(a, b, c, std::less<>());
}

template<class T, class C>
bool sorted(T _First, T _Last, C compare) {
	for (T _Pos = _First + 1; _Pos != _Last; ++_Pos) {
		T _Prev = _Pos - 1;
		if (compare(*_Pos, *_Prev))
			return false;
	}
	return true;
}

inline std::vector<std::wstring> split_wstr(std::wstring str, const std::wstring& delimiter, int minlen = -1) {
	std::vector<std::wstring> ret;
	size_t pos = 0;
	std::wstring token;
	while ((pos = str.find(delimiter)) != std::wstring::npos) {
		token = str.substr(0, pos);
		if ((int)token.size() >= minlen)
			ret.push_back(token);
		str.erase(0, pos + delimiter.length());
	}
	if ((int)str.size() > 0)
		ret.push_back(str);
	return ret;
}

#define STRINGIFY_ENUM_DEC(e) extern std::map<e, std::wstring> e##Names;
#define STRINGIFY_ENUM(e, ...) std::map<e, std::wstring> e##Names; \
namespace { \
	bool e##SetEnumNames() { \
		std::vector<std::wstring> names = split_wstr(L#__VA_ARGS__, L","); \
		std::vector<e> vals = {__VA_ARGS__}; \
		for (unsigned i = 0; i < vals.size(); i++) \
			e##Names[vals[i]] = names[i]; \
		return true; \
	} \
	bool e##bbbb = e##SetEnumNames(); \
} \

//hue[0 - 360] saturation[0.0 - 1.0] value[0.0 - 1.0]
inline COLORREF HSVtoRGB(double h, double s, double v) {
	int i;
	double f, p, q, t, r, g, b;
	if (s == 0) {
		// achromatic (grey)
		r = g = b = v;
		return RGB(r * 255.0, g * 255.0, b * 255.0);
	}
	h /= 60;			// sector 0 to 5
	i = (int)floor(h);
	f = h - i;			// factorial part of h
	p = v * (1 - s);
	q = v * (1 - s * f);
	t = v * (1 - s * (1 - f));
	switch (i) {
		case 0:
			r = v;
			g = t;
			b = p;
			break;
		case 1:
			r = q;
			g = v;
			b = p;
			break;
		case 2:
			r = p;
			g = v;
			b = t;
			break;
		case 3:
			r = p;
			g = q;
			b = v;
			break;
		case 4:
			r = t;
			g = p;
			b = v;
			break;
		default:		// case 5:
			r = v;
			g = p;
			b = q;
			break;
	}
	return RGB(r * 255.0, g * 255.0, b * 255.0);
}

inline unsigned int uint_diff(unsigned a, unsigned b) {
	return a < b ? b - a : a - b;
}

inline POINT getclientcursorpos(HWND hwnd) {
	RECT temprect;
	GetClientRect(hwnd, &temprect);
	MapWindowPoints(hwnd, NULL, (LPPOINT)&temprect, 2);
	POINT temppoint;
	GetCursorPos(&temppoint);
	POINT client_cursor_pos;
	client_cursor_pos.x = temppoint.x - temprect.left;
	client_cursor_pos.y = temppoint.y - temprect.top;
	return client_cursor_pos;
}

inline std::string getexedir() {
	CHAR path[MAX_PATH];
	GetModuleFileNameA(NULL, path, MAX_PATH);
	std::string dir(path);
	return dir.substr(0, dir.rfind('\\'));
}
inline void GetFilesInDirectory(const std::string &directory, const std::string &filetype, std::vector<std::string> *out) {
	using namespace std;
	HANDLE dir;
	WIN32_FIND_DATAA file_data;

	string path = (directory + (directory.back() != '\\' ? "\\*." : "") + filetype);
	if ((dir = FindFirstFileA(path.c_str(), &file_data)) == INVALID_HANDLE_VALUE)
		return; /* No files found */

	do {
		const string file_name = file_data.cFileName;
		const string full_file_name = directory + "\\" + file_name;
		const bool is_directory = (file_data.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) != 0;

		if (file_name[0] == '.')
			continue;

		if (is_directory)
			continue;

		out->push_back(full_file_name);
	} while (FindNextFileA(dir, &file_data));

	FindClose(dir);
}
inline void SaveSourceToFile(std::string dir) {
	std::vector<std::string> files;
	GetFilesInDirectory(dir, "h", &files);
	GetFilesInDirectory(dir, "cpp", &files);
	GetFilesInDirectory(dir, "rc", &files);

	std::string text = "";
	for (unsigned i = 0; i < files.size(); i++) {
		std::ifstream file;
		file.open(files[i]);
		if (file.is_open()) {
			text += "~-----------------------------------------------~\n" + files[i] + "\n~-----------------------------------------------~\n";

			while (file.good()) {
				std::string line;
				std::getline(file, line);

				text += line + "\n";
			}

		//	text.erase(text.end() - 1);

			file.close();
		}
	}

	std::ofstream file;
	file.open("output.txt");

	if (file.is_open()) {
		file << text;
	}

	file.close();
}
inline void LoadSourceFromFile(std::string dir) {
	std::map<std::wstring, std::wstring> files;

	std::wifstream infile;
	infile.open(dir + "\\input.txt");
	if (infile.is_open()) {
		std::wstring line;
	//	std::getline(infile, line);//eat first empty line
		std::getline(infile, line);//eat line of ~----...~
		while (infile.good()) {
			std::getline(infile, line);
			std::wstring filename = line.substr(line.rfind(L"\\") + 1, line.size());
			std::getline(infile, line);//eat next line of ~----------------...~

			std::wstring filetext = L"";
			while (infile.good()) {
				std::getline(infile, line);
				if (line == L"~-----------------------------------------------~") {
					break;
				}
				filetext += line + L"\n";
			}

			files[filename] = filetext;
		}
	}
	infile.close();

	for (auto & file : files) {
		std::wofstream outfile;
		outfile.open(L"sourceout\\" + file.first);
		if (outfile.is_open()) {
			outfile << file.second;
			outfile.close();
		}
	}
}

#pragma region getmessagetext

#define X(x) { x, #x },
struct WindowsMessage {
	int msgid;
	const char* pname;
} static WindowsMessages[] =
{
	X(WM_NULL)
	X(WM_CREATE)
	X(WM_DESTROY)
	X(WM_MOVE)
	X(WM_SIZE)
	X(WM_ACTIVATE)
	X(WM_SETFOCUS)
	X(WM_KILLFOCUS)
	X(WM_ENABLE)
	X(WM_SETREDRAW)
	X(WM_SETTEXT)
	X(WM_GETTEXT)
	X(WM_GETTEXTLENGTH)
	X(WM_PAINT)
	X(WM_CLOSE)
	X(WM_QUERYENDSESSION)
	X(WM_QUERYOPEN)
	X(WM_ENDSESSION)
	X(WM_QUIT)
	X(WM_ERASEBKGND)
	X(WM_SYSCOLORCHANGE)
	X(WM_SHOWWINDOW)
	X(WM_WININICHANGE)
	X(WM_DEVMODECHANGE)
	X(WM_ACTIVATEAPP)
	X(WM_FONTCHANGE)
	X(WM_TIMECHANGE)
	X(WM_CANCELMODE)
	X(WM_SETCURSOR)
	X(WM_MOUSEACTIVATE)
	X(WM_CHILDACTIVATE)
	X(WM_QUEUESYNC)
	X(WM_GETMINMAXINFO)
	X(WM_PAINTICON)
	X(WM_ICONERASEBKGND)
	X(WM_NEXTDLGCTL)
	X(WM_SPOOLERSTATUS)
	X(WM_DRAWITEM)
	X(WM_MEASUREITEM)
	X(WM_DELETEITEM)
	X(WM_VKEYTOITEM)
	X(WM_CHARTOITEM)
	X(WM_SETFONT)
	X(WM_GETFONT)
	X(WM_SETHOTKEY)
	X(WM_GETHOTKEY)
	X(WM_QUERYDRAGICON)
	X(WM_COMPAREITEM)
	X(WM_GETOBJECT)
	X(WM_COMPACTING)
	X(WM_COMMNOTIFY)
	X(WM_WINDOWPOSCHANGING)
	X(WM_WINDOWPOSCHANGED)
	X(WM_POWER)
	X(WM_COPYDATA)
	X(WM_CANCELJOURNAL)
	X(WM_NOTIFY)
	X(WM_INPUTLANGCHANGEREQUEST)
	X(WM_INPUTLANGCHANGE)
	X(WM_TCARD)
	X(WM_HELP)
	X(WM_USERCHANGED)
	X(WM_NOTIFYFORMAT)
	X(WM_CONTEXTMENU)
	X(WM_STYLECHANGING)
	X(WM_STYLECHANGED)
	X(WM_DISPLAYCHANGE)
	X(WM_GETICON)
	X(WM_SETICON)
	X(WM_NCCREATE)
	X(WM_NCDESTROY)
	X(WM_NCCALCSIZE)
	X(WM_NCHITTEST)
	X(WM_NCPAINT)
	X(WM_NCACTIVATE)
	X(WM_GETDLGCODE)
	X(WM_SYNCPAINT)
	X(WM_NCMOUSEMOVE)
	X(WM_NCLBUTTONDOWN)
	X(WM_NCLBUTTONUP)
	X(WM_NCLBUTTONDBLCLK)
	X(WM_NCRBUTTONDOWN)
	X(WM_NCRBUTTONUP)
	X(WM_NCRBUTTONDBLCLK)
	X(WM_NCMBUTTONDOWN)
	X(WM_NCMBUTTONUP)
	X(WM_NCMBUTTONDBLCLK)
	X(WM_NCXBUTTONDOWN)
	X(WM_NCXBUTTONUP)
	X(WM_NCXBUTTONDBLCLK)
	X(WM_INPUT_DEVICE_CHANGE)
	X(WM_INPUT)
	X(WM_KEYDOWN)
	X(WM_KEYUP)
	X(WM_CHAR)
	X(WM_DEADCHAR)
	X(WM_SYSKEYDOWN)
	X(WM_SYSKEYUP)
	X(WM_SYSCHAR)
	X(WM_SYSDEADCHAR)
	X(WM_UNICHAR)
	X(WM_KEYLAST)
	X(WM_KEYLAST)
	X(WM_IME_STARTCOMPOSITION)
	X(WM_IME_ENDCOMPOSITION)
	X(WM_IME_COMPOSITION)
	X(WM_IME_KEYLAST)
	X(WM_INITDIALOG)
	X(WM_COMMAND)
	X(WM_SYSCOMMAND)
	X(WM_TIMER)
	X(WM_HSCROLL)
	X(WM_VSCROLL)
	X(WM_INITMENU)
	X(WM_INITMENUPOPUP)
	X(WM_GESTURE)
	X(WM_GESTURENOTIFY)
	X(WM_MENUSELECT)
	X(WM_MENUCHAR)
	X(WM_ENTERIDLE)
	X(WM_MENURBUTTONUP)
	X(WM_MENUDRAG)
	X(WM_MENUGETOBJECT)
	X(WM_UNINITMENUPOPUP)
	X(WM_MENUCOMMAND)
	X(WM_CHANGEUISTATE)
	X(WM_UPDATEUISTATE)
	X(WM_QUERYUISTATE)
	X(WM_CTLCOLORMSGBOX)
	X(WM_CTLCOLOREDIT)
	X(WM_CTLCOLORLISTBOX)
	X(WM_CTLCOLORBTN)
	X(WM_CTLCOLORDLG)
	X(WM_CTLCOLORSCROLLBAR)
	X(WM_CTLCOLORSTATIC)
	X(WM_MOUSEMOVE)
	X(WM_LBUTTONDOWN)
	X(WM_LBUTTONUP)
	X(WM_LBUTTONDBLCLK)
	X(WM_RBUTTONDOWN)
	X(WM_RBUTTONUP)
	X(WM_RBUTTONDBLCLK)
	X(WM_MBUTTONDOWN)
	X(WM_MBUTTONUP)
	X(WM_MBUTTONDBLCLK)
	X(WM_MOUSEWHEEL)
	X(WM_XBUTTONDOWN)
	X(WM_XBUTTONUP)
	X(WM_XBUTTONDBLCLK)
	X(WM_MOUSEHWHEEL)
	X(WM_MOUSELAST)
	X(WM_MOUSELAST)
	X(WM_MOUSELAST)
	X(WM_MOUSELAST)
	X(WM_PARENTNOTIFY)
	X(WM_ENTERMENULOOP)
	X(WM_EXITMENULOOP)
	X(WM_NEXTMENU)
	X(WM_SIZING)
	X(WM_CAPTURECHANGED)
	X(WM_MOVING)
	X(WM_POWERBROADCAST)
	X(WM_MDICREATE)
	X(WM_MDIDESTROY)
	X(WM_MDIACTIVATE)
	X(WM_MDIRESTORE)
	X(WM_MDINEXT)
	X(WM_MDIMAXIMIZE)
	X(WM_MDITILE)
	X(WM_MDICASCADE)
	X(WM_MDIICONARRANGE)
	X(WM_MDIGETACTIVE)
	X(WM_MDISETMENU)
	X(WM_ENTERSIZEMOVE)
	X(WM_EXITSIZEMOVE)
	X(WM_DROPFILES)
	X(WM_MDIREFRESHMENU)
	X(WM_POINTERDEVICECHANGE)
	X(WM_POINTERDEVICEINRANGE)
	X(WM_POINTERDEVICEOUTOFRANGE)
	X(WM_TOUCH)
	X(WM_NCPOINTERUPDATE)
	X(WM_NCPOINTERDOWN)
	X(WM_NCPOINTERUP)
	X(WM_POINTERUPDATE)
	X(WM_POINTERDOWN)
	X(WM_POINTERUP)
	X(WM_POINTERENTER)
	X(WM_POINTERLEAVE)
	X(WM_POINTERACTIVATE)
	X(WM_POINTERCAPTURECHANGED)
	X(WM_TOUCHHITTESTING)
	X(WM_POINTERWHEEL)
	X(WM_POINTERHWHEEL)
	X(WM_IME_SETCONTEXT)
	X(WM_IME_NOTIFY)
	X(WM_IME_CONTROL)
	X(WM_IME_COMPOSITIONFULL)
	X(WM_IME_SELECT)
	X(WM_IME_CHAR)
	X(WM_IME_REQUEST)
	X(WM_IME_KEYDOWN)
	X(WM_IME_KEYUP)
	X(WM_MOUSEHOVER)
	X(WM_MOUSELEAVE)
	X(WM_NCMOUSEHOVER)
	X(WM_NCMOUSELEAVE)
	X(WM_WTSSESSION_CHANGE)
	X(WM_TABLET_FIRST)
	X(WM_TABLET_LAST)
	X(WM_DPICHANGED)
	X(WM_CUT)
	X(WM_COPY)
	X(WM_PASTE)
	X(WM_CLEAR)
	X(WM_UNDO)
	X(WM_RENDERFORMAT)
	X(WM_RENDERALLFORMATS)
	X(WM_DESTROYCLIPBOARD)
	X(WM_DRAWCLIPBOARD)
	X(WM_PAINTCLIPBOARD)
	X(WM_VSCROLLCLIPBOARD)
	X(WM_SIZECLIPBOARD)
	X(WM_ASKCBFORMATNAME)
	X(WM_CHANGECBCHAIN)
	X(WM_HSCROLLCLIPBOARD)
	X(WM_QUERYNEWPALETTE)
	X(WM_PALETTEISCHANGING)
	X(WM_PALETTECHANGED)
	X(WM_HOTKEY)
	X(WM_PRINT)
	X(WM_PRINTCLIENT)
	X(WM_APPCOMMAND)
	X(WM_THEMECHANGED)
	X(WM_CLIPBOARDUPDATE)
	X(WM_DWMCOMPOSITIONCHANGED)
	X(WM_DWMNCRENDERINGCHANGED)
	X(WM_DWMCOLORIZATIONCOLORCHANGED)
	X(WM_DWMWINDOWMAXIMIZEDCHANGE)
	X(WM_DWMSENDICONICTHUMBNAIL)
	X(WM_DWMSENDICONICLIVEPREVIEWBITMAP)
	X(WM_GETTITLEBARINFOEX)
	X(WM_HANDHELDFIRST)
	X(WM_HANDHELDLAST)
	X(WM_AFXFIRST)
	X(WM_AFXLAST)
	X(WM_PENWINFIRST)
	X(WM_PENWINLAST)
	X(WM_APP)
	X(WM_USER)
};
#undef X

inline std::string getMessageText(int msgId) {
	int size = (sizeof(WindowsMessages) / sizeof(*WindowsMessages));
	for (int i = 0; i < size; i++) {
		if (msgId == WindowsMessages[i].msgid)
			return WindowsMessages[i].pname;
	}
	return "";
}

#pragma endregion


























~-----------------------------------------------~
C:\Users\Josh\Documents\Visual Studio 2017\Projects\Sorting\Sorting\sounds.h
~-----------------------------------------------~
#pragma once

#pragma comment(lib, "winmm.lib")
#include "RtMidi.h"

#include <thread>
#include <string>
#include <map>

//https://www.music.mcgill.ca/~gary/rtmidi/index.html#virtual
//http://www.music-software-development.com/midi-tutorial.html

//1 - 8		Piano
//9 - 16	Chromatic Percussion
//17 - 24	Organ
//25 - 32	Guitar
//33 - 40	Bass
//41 - 48	Strings
//49 - 56	Ensemble
//57 - 64	Brass
//65 - 72	Reed
//73 - 80	Pipe
//81 - 88	Synth Lead
//89 - 96	Synth Pad
//97 - 104	Synth Effects
//105 - 112	Ethnic
//113 - 120	Percussive
//121 - 128	Sound Effects

extern std::map<unsigned, std::wstring> InstrumentNames;

enum Drum{
	Acoustic_Bass_Drum = 35,Bass_Drum_,Side_Stick,Acoustic_Snare,Hand_Clap,Electric_Snare,Low_Floor_Tom,Closed_Hi_Hat,
	High_Floor_Tom,Pedal_HiHat,Low_Tom,Open_HiHat,LowMid_Tom,HiMid_Tom,Crash_Cymbal_1,High_Tom,
	Ride_Cymbal_1,Chinese_Cymbal,Ride_Bell,Tambourine,Splash_Cymbal,Cowbell,Crash_Cymbal_2,Vibraslap,
	Ride_Cymbal_2,Hi_Bongo,Low_Bongo,Mute_Hi_Conga,Open_Hi_Conga,Low_Conga,High_Timbale,Low_Timbale,
	High_Agogo,Low_Agogo,Cabasa,Maracas,Short_Whistle,Long_Whistle,Short_Guiro,Long_Guiro,
	Claves,Hi_Wood_Block,Low_Wood_Block,Mute_Cuica,Open_Cuica,Mute_Triangle,Open_Triangle
};

enum Instrument {
	Acoustic_Grand_Piano = 1, Bright_Acoustic_Piano, Electric_Grand_Piano, Honkytonk_Piano, Electric_Piano_1, Electric_Piano_2, Harpsichord, Clavi, 
	Celesta, 	Glockenspiel, Music_Box, Vibraphone, Marimba, Xylophone, Tubular_Bells, Dulcimer, 
	Drawbar_Organ, Percussive_Organ, Rock_Organ, Church_Organ, Reed_Organ, Accordion, Harmonica, Tango_Accordion, 
	Acoustic_Guitar_nylon, Acoustic_Guitar_steel, Electric_Guitar_jazz, Electric_Guitar_clean, Electric_Guitar_muted, Overdriven_Guitar, Distortion_Guitar, Guitar_harmonics, 
	Acoustic_Bass, Electric_Bass_finger, Electric_Bass_pick, Fretless_Bass, Slap_Bass_1, Slap_Bass_2, Synth_Bass_1, Synth_Bass_2, 
	Violin, Viola, Cello, Contrabass, Tremolo_Strings, Pizzicato_Strings, Orchestral_Harp, Timpani, 
	String_Ensemble_1, String_Ensemble_2, SynthStrings_1, SynthStrings_2, Choir_Aahs, Voice_Oohs, Synth_Voice, Orchestra_Hit, 
	Trumpet, Trombone, Tuba, Muted_Trumpet, French_Horn, Brass_Section, SynthBrass_1, SynthBrass_2, 
	Soprano_Sax, Alto_Sax, Tenor_Sax, Baritone_Sax, Oboe, English_Horn, Bassoon, Clarinet, 
	Piccolo, Flute, Recorder, Pan_Flute, Blown_Bottle, Shakuhachi, Whistle, Ocarina, 
	Lead_1_square, Lead_2_sawtooth, Lead_3_calliope, Lead_4_chiff, Lead_5_charang, Lead_6_voice, Lead_7_fifths, Lead_8_bass_and_lead, 
	Pad_1_new_age, Pad_2_warm, Pad_3_polysynth, Pad_4_choir, Pad_5_bowed, Pad_6_metallic, Pad_7_halo, Pad_8_sweep, 
	FX_1_rain, FX_2_soundtrack, FX_3_crystal, FX_4_atmosphere, FX_5_brightness, FX_6_goblins, FX_7_echoes, FX_8_sci_fi, 
	Sitar, Banjo, Shamisen, Koto, Kalimba, Bag_pipe, Fiddle, Shanai, 
	Tinkle_Bell, Agogo, Steel_Drums, Woodblock, Taiko_Drum, Melodic_Tom, Synth_Drum, Reverse_Cymbal, 
	Guitar_Fret_Noise, Breath_Noise, Seashore, Bird_Tweet, Telephone_Ring, Helicopter, Applause, Gunshot, 
};

enum {
	Piano1 = 1, Piano2, Piano3, Piano4, Piano5, Piano6, Piano7, Piano8,
	Chromatic_Percussion1, Chromatic_Percussion2, Chromatic_Percussion3, Chromatic_Percussion4, Chromatic_Percussion5, Chromatic_Percussion6, Chromatic_Percussion7, Chromatic_Percussion8,
	Organ1, Organ2, Organ3, Organ4, Organ5, Organ6, Organ7, Organ8,
	Guitar1, Guitar2, Guitar3, Guitar4, Guitar5, Guitar6, Guitar7, Guitar8,
	Bass1, Bass2, Bass3, Bass4, Bass5, Bass6, Bass7, Bass8,
	Strings1, Strings2, Strings3, Strings4, Strings5, Strings6, Strings7, Strings8,
	Ensemble1, Ensemble2, Ensemble3, Ensemble4, Ensemble5, Ensemble6, Ensemble7, Ensemble8,
	Brass1, Brass2, Brass3, Brass4, Brass5, Brass6, Brass7, Brass8,
	Reed1, Reed2, Reed3, Reed4, Reed5, Reed6, Reed7, Reed8,
	Pipe1, Pipe2, Pipe3, Pipe4, Pipe5, Pipe6, Pipe7, Pipe8,
	Synth_Lead1, Synth_Lead2, Synth_Lead3, Synth_Lead4, Synth_Lead5, Synth_Lead6, Synth_Lead7, Synth_Lead8,
	Synth_Pad1, Synth_Pad2, Synth_Pad3, Synth_Pad4, Synth_Pad5, Synth_Pad6, Synth_Pad7, Synth_Pad8,
	Synth_Effects1, Synth_Effects2, Synth_Effects3, Synth_Effects4, Synth_Effects5, Synth_Effects6, Synth_Effects7, Synth_Effects8,
	Ethnic1, Ethnic2, Ethnic3, Ethnic4, Ethnic5, Ethnic6, Ethnic7, Ethnic8,
	Percussive1, Percussive2, Percussive3, Percussive4, Percussive5, Percussive6, Percussive7, Percussive8,
	Sound_Effects1, Sound_Effects2, Sound_Effects3, Sound_Effects4, Sound_Effects5, Sound_Effects6, Sound_Effects7, Sound_Effects8,
};

class MIDISoundPlayer {
public:
	enum {
		NOTE_OFF = 128,
		NOTE_ON = 144,
		CONTROL_CHANGE = 176,
		PROGRAM_CHANGE = 192
	};

	enum {
		CONTROL_CHANGE_VOLUME = 7,
		CONTROL_CHANGE_ALL_NOTES_OFF = 123,
	};

	RtMidiOut midiout;

	MIDISoundPlayer(int instrument);

	~MIDISoundPlayer();

	void SetInstrument(unsigned char instrument);

	int GetInstrument();

	std::wstring GetInstrumentName();

	static std::wstring GetInstrumentName(int id);

	void SetVolume(char volume);

	void PlayNote(char note, char on_velocity, char off_velocity, int duration);

	void PlayNotes(const std::vector<char>& notes, char on_velocity, char off_velocity, int duration);

	void StopAllNotes();	

private:
	int selected_instrument = 0;

	int port_count = 0;

	void NoteOn(char note, char velocity);

	void NoteOff(char note, char velocity);
};


























~-----------------------------------------------~
C:\Users\Josh\Documents\Visual Studio 2017\Projects\Sorting\Sorting\sqrtsort.h
~-----------------------------------------------~
#pragma once

/********* Sqrt sorting *********************************/
/*                                                       */
/* (c) 2014 by Andrey Astrelin                           */
/*                                                       */
/*                                                       */
/* Stable sorting that works in O(N*log(N)) worst time   */
/* and uses O(sqrt(N)) extra memory                      */
/*                                                       */
/* Define SORT_TYPE and SORT_CMP                         */
/* and then call SqrtSort() function                     */
/*                                                       */
/*********************************************************/

#include<memory.h>
#include<malloc.h>

template<class SORT_TYPE, class C>
int SORT_CMP(const SORT_TYPE* a, const SORT_TYPE* b, C compare) {
	if (compare(*a, *b)) return -1;
	if (compare(*b, *a)) return 1;
	return 0;
}


template<class SORT_TYPE>
inline void sqrtsort_swap1(SORT_TYPE *a, SORT_TYPE *b) {
	/*SORT_TYPE c = *a;
	*a++ = *b;
	*b++ = c;*/
	using std::swap;
	swap(*a++, *b++);
}

inline void sqrtsort_swap1(TraceInt *a, TraceInt *b) {
	auto v = (*a).TV_->vec_;

	for (int i = 0; i < v.size(); i++) {
		if (v[i].index_ != i) {
			printf("");
			break;
		}
	}

	swap(*a, *b);

	for (int i = 0; i < v.size(); i++) {
		if (v[i].index_ != i) {
			printf("");
			break;
		}
	}

	printf("");
}

template<class SORT_TYPE>
inline void sqrtsort_swapN(SORT_TYPE *a, SORT_TYPE *b, int n) {
	while (n--) sqrtsort_swap1(a++, b++);
}

template<class SORT_TYPE, class C>
static void sqrtsort_MergeRight(SORT_TYPE *arr, int L1, int L2, int M, C compare) {
	int p0 = L1 + L2 + M - 1, p2 = L1 + L2 - 1, p1 = L1 - 1;

	while (p1 >= 0) {
		if (p2<L1 || SORT_CMP(arr + p1, arr + p2, compare)>0) {
			arr[p0--] = arr[p1--];
		}
		else {
			arr[p0--] = arr[p2--];
		}
	}
	if (p2 != p0) while (p2 >= L1) arr[p0--] = arr[p2--];
}

// arr[M..-1] - free, arr[0,L1-1]++arr[L1,L1+L2-1] -> arr[M,M+L1+L2-1]
template<class SORT_TYPE, class C>
static void sqrtsort_MergeLeftWithXBuf(SORT_TYPE *arr, int L1, int L2, int M, C compare) {
	int p0 = 0, p1 = L1;
	L2 += L1;
	while (p1<L2) {
		if (p0 == L1 || SORT_CMP(arr + p0, arr + p1, compare)>0) arr[M++] = arr[p1++];
		else arr[M++] = arr[p0++];
	}
	if (M != p0) while (p0<L1) arr[M++] = arr[p0++];
}

// arr[0,L1-1] ++ arr2[0,L2-1] -> arr[-L1,L2-1],  arr2 is "before" arr1
template<class SORT_TYPE, class C>
static void sqrtsort_MergeDown(SORT_TYPE *arr, SORT_TYPE *arr2, int L1, int L2, C compare) {
	int p0 = 0, p1 = 0, M = -L2;

	while (p1<L2) {
		if (p0 == L1 || SORT_CMP(arr + p0, arr2 + p1, compare) >= 0) arr[M++] = arr2[p1++];
		else arr[M++] = arr[p0++];
	}
	if (M != p0) while (p0<L1) arr[M++] = arr[p0++];
}

template<class SORT_TYPE, class C>
static void sqrtsort_SmartMergeWithXBuf(SORT_TYPE *arr, int *alen1, int *atype, int len2, int lkeys, C compare) {
	int p0 = -lkeys, p1 = 0, p2 = *alen1, q1 = p2, q2 = p2 + len2;
	int ftype = 1 - *atype;  // 1 if inverted
	while (p1<q1 && p2<q2) {
		if (SORT_CMP(arr + p1, arr + p2, compare) - ftype<0) arr[p0++] = arr[p1++];
		else arr[p0++] = arr[p2++];
	}
	if (p1<q1) {
		*alen1 = q1 - p1;
		while (p1<q1) arr[--q2] = arr[--q1];
	}
	else {
		*alen1 = q2 - p2;
		*atype = ftype;
	}
}

// arr - starting array. arr[-lblock..-1] - buffer (if havebuf).
// lblock - length of regular blocks. First nblocks are stable sorted by 1st elements and key-coded
// keys - arrays of keys, in same order as blocks. key<midkey means stream A
// nblock2 are regular blocks from stream A. llast is length of last (irregular) block from stream B, that should go before nblock2 blocks.
// llast=0 requires nblock2=0 (no irregular blocks). llast>0, nblock2=0 is possible.
template<class SORT_TYPE, class C>
static void sqrtsort_MergeBuffersLeftWithXBuf(int *keys, int midkey, SORT_TYPE *arr, int nblock, int lblock, int nblock2, int llast, C compare) {
	int l, prest, lrest, frest, pidx, cidx, fnext, plast;

	if (nblock == 0) {
		l = nblock2 * lblock;
		sqrtsort_MergeLeftWithXBuf(arr, l, llast, -lblock, compare);
		return;
	}

	lrest = lblock;
	frest = keys[0]<midkey ? 0 : 1;
	pidx = lblock;
	for (cidx = 1; cidx<nblock; cidx++, pidx += lblock) {
		prest = pidx - lrest;
		fnext = keys[cidx]<midkey ? 0 : 1;
		if (fnext == frest) {
			memcpy(arr + prest - lblock, arr + prest, lrest * sizeof(SORT_TYPE));
			prest = pidx;
			lrest = lblock;
		}
		else {
			sqrtsort_SmartMergeWithXBuf(arr + prest, &lrest, &frest, lblock, lblock, compare);
		}
	}
	prest = pidx - lrest;
	if (llast) {
		plast = pidx + lblock * nblock2;
		if (frest) {
			memcpy(arr + prest - lblock, arr + prest, lrest * sizeof(SORT_TYPE));
			prest = pidx;
			lrest = lblock * nblock2;
			frest = 0;
		}
		else {
			lrest += lblock * nblock2;
		}
		sqrtsort_MergeLeftWithXBuf(arr + prest, lrest, llast, -lblock, compare);
	}
	else {
		memcpy(arr + prest - lblock, arr + prest, lrest * sizeof(SORT_TYPE));
	}
}

// build blocks of length K
// input: [-K,-1] elements are buffer
// output: first K elements are buffer, blocks 2*K and last subblock sorted
template<class SORT_TYPE, class C>
static void sqrtsort_BuildBlocks(SORT_TYPE *arr, int L, int K, C compare) {
	int m, u, h, p0, p1, rest, restk, p;
	for (m = 1; m<L; m += 2) {
		u = 0;
		if (SORT_CMP(arr + (m - 1), arr + m, compare)>0) u = 1;
		arr[m - 3] = arr[m - 1 + u];
		arr[m - 2] = arr[m - u];
	}
	if (L % 2) arr[L - 3] = arr[L - 1];
	arr -= 2;
	for (h = 2; h<K; h *= 2) {
		p0 = 0;
		p1 = L - 2 * h;
		while (p0 <= p1) {
			sqrtsort_MergeLeftWithXBuf(arr + p0, h, h, -h, compare);
			p0 += 2 * h;
		}
		rest = L - p0;
		if (rest>h) {
			sqrtsort_MergeLeftWithXBuf(arr + p0, h, rest - h, -h, compare);
		}
		else {
			for (; p0<L; p0++)	arr[p0 - h] = arr[p0];
		}
		arr -= h;
	}
	restk = L % (2 * K);
	p = L - restk;
	if (restk <= K) memcpy(arr + p + K, arr + p, restk * sizeof(SORT_TYPE));
	else sqrtsort_MergeRight(arr + p, K, restk - K, K, compare);
	while (p>0) {
		p -= 2 * K;
		sqrtsort_MergeRight(arr + p, K, K, K, compare);
	}
}

template<class SORT_TYPE, class C>
static void sqrtsort_SortIns(SORT_TYPE *arr, int len, C compare) {
	int i, j;
	for (i = 1; i<len; i++) {
		for (j = i - 1; j >= 0 && SORT_CMP(arr + (j + 1), arr + j, compare)<0; j--) sqrtsort_swap1(arr + j, arr + (j + 1));
	}
}

// keys are on the left of arr. Blocks of length LL combined. We'll combine them in pairs
// LL and nkeys are powers of 2. (2*LL/lblock) keys are guarantied
template<class SORT_TYPE, class C>
static void sqrtsort_CombineBlocks(SORT_TYPE *arr, int len, int LL, int lblock, int *tags, C compare) {
	int M, nkeys, b, NBlk, midkey, lrest, u, i, p, v, kc, nbl2, llast;
	SORT_TYPE *arr1;

	M = len / (2 * LL);
	lrest = len % (2 * LL);
	nkeys = (2 * LL) / lblock;
	if (M == 0) nkeys = (M - 1) / lblock + 1;
	if (lrest <= LL) {
		len -= lrest;
		lrest = 0;
	}
	for (b = 0; b <= M; b++) {
		if (b == M && lrest == 0) break;
		arr1 = arr + b * 2 * LL;
		NBlk = (b == M ? lrest : 2 * LL) / lblock;
		u = NBlk + (b == M ? 1 : 0);
		for (i = 0; i <= u; i++) tags[i] = i;
		midkey = LL / lblock;
		for (u = 1; u<NBlk; u++) {
			p = u - 1;
			for (v = u; v<NBlk; v++) {
				kc = SORT_CMP(arr1 + p * lblock, arr1 + v * lblock, compare);
				if (kc>0 || (kc == 0 && tags[p]>tags[v])) p = v;
			}
			if (p != u - 1) {
				sqrtsort_swapN(arr1 + (u - 1)*lblock, arr1 + p * lblock, lblock);
				i = tags[u - 1]; tags[u - 1] = tags[p]; tags[p] = i;
			}
		}
		nbl2 = llast = 0;
		if (b == M) llast = lrest % lblock;
		if (llast != 0) {
			while (nbl2<NBlk && SORT_CMP(arr1 + NBlk * lblock, arr1 + (NBlk - nbl2 - 1)*lblock, compare)<0) nbl2++;
		}
		sqrtsort_MergeBuffersLeftWithXBuf(tags, midkey, arr1, NBlk - nbl2, lblock, nbl2, llast, compare);
	}
	for (p = len; --p >= 0;) arr[p] = arr[p - lblock];
}

template<class SORT_TYPE, class C>
void sqrtsort_commonSort(SORT_TYPE *arr, int Len, SORT_TYPE *extbuf, int *Tags, C compare) {
	int lblock, cbuf;

	if (Len<16) {
		sqrtsort_SortIns(arr, Len, compare);
		return;
	}

	lblock = 1;
	while (lblock*lblock<Len) lblock *= 2;
	memcpy(extbuf, arr, lblock * sizeof(SORT_TYPE));

	sqrtsort_commonSort(extbuf, lblock, arr, Tags, compare);

	sqrtsort_BuildBlocks(arr + lblock, Len - lblock, lblock, compare);
	cbuf = lblock;
	while (Len>(cbuf *= 2)) {
		sqrtsort_CombineBlocks(arr + lblock, Len - lblock, cbuf, lblock, Tags, compare);
	}
	sqrtsort_MergeDown(arr + lblock, extbuf, Len - lblock, lblock, compare);
}

template<class SORT_TYPE, class C>
void SqrtSort(SORT_TYPE *arr, int Len, C compare) {
	int L = 1;
	SORT_TYPE *ExtBuf;
	int *Tags;

	while (L*L<Len) L *= 2;
	int NK = (Len - 1) / L + 2;
	ExtBuf = (SORT_TYPE*)malloc(L * sizeof(SORT_TYPE));
	if (ExtBuf == NULL) return; // fail
	Tags = (int*)malloc(NK * sizeof(int));
	if (Tags == NULL) return;

	sqrtsort_commonSort(arr, Len, ExtBuf, Tags, compare);
	free(Tags);
	free(ExtBuf);
}

template<class T, class C>
inline void sqrtsort(T _First, T _Last, C compare) {
	SqrtSort(&_First[0], std::distance(_First, _Last), compare);
}

template<class T>
inline void sqrtsort(T _First, T _Last) {
	sqrtsort(_First, _Last, std::less<>());
}





~-----------------------------------------------~
C:\Users\Josh\Documents\Visual Studio 2017\Projects\Sorting\Sorting\table.h
~-----------------------------------------------~
#pragma once

#include <list>
#include <string>
#include <utility>
#include <functional>
#include <algorithm>
#include <iostream>

template<typename RowData>
class Table {
public:
	Table() {}

	Table(std::vector<RowData>& rows) {
		AddRows(rows);
	}

	void AddRows(std::vector<RowData>& rows) {
		for (unsigned i = 0; i < rows.size(); ++i)
			AddRow(rows[i]);
	}

	void AddRow(RowData& row) {	
		Rows.push_back(row);
		RowData::RowAddedProc(Rows.back());
	}

	unsigned GetRowCount() { return Rows.size(); }

	RowData GetRow(unsigned i) {
		return Rows[i];
	}

	std::vector<RowData> GetRows() {
		return Rows;
	}

	/*void SortBy(typename RowData::ColumnId col_id, bool is_ascending = true) {
		std::stable_sort(Rows.begin(), Rows.end(), std::bind(RowData::CompareByColumn, std::placeholders::_1, std::placeholders::_2, col_id, is_ascending));
	}*/

	void SortByColumn(typename RowData::ColumnId col_id, bool is_ascending = true) {
		RowData::SortByColumnProc(col_id, is_ascending);
	}

	void PrintRow(unsigned row_index) {
		Rows[row_index].Print();
	}

	void PrintRows() {
		for (unsigned i = 0; i < Rows.size(); ++i)
			PrintRow(i);
	}

	std::wstring GetColumnName(typename RowData::ColumnId col_id) {
		return RowData::ColumnNames[col_id];
	}

private:
	std::list<RowData> Rows;
};




~-----------------------------------------------~
C:\Users\Josh\Documents\Visual Studio 2017\Projects\Sorting\Sorting\timsort.h
~-----------------------------------------------~
/*
 * C++ implementation of timsort
 *
 * ported from Python's and OpenJDK's:
 * - http://svn.python.org/projects/python/trunk/Objects/listobject.c
 * - http://cr.openjdk.java.net/~martin/webrevs/openjdk7/timsort/raw_files/new/src/share/classes/java/util/TimSort.java
 *
 * Copyright (c) 2011 Fuji, Goro (gfx) <gfuji@cpan.org>.
 * Copyright (c) 2019 Morwenn.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to
 * deal in the Software without restriction, including without limitation the
 * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
 * sell copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
 * IN THE SOFTWARE.
 */

#ifndef GFX_TIMSORT_HPP
#define GFX_TIMSORT_HPP

#include <algorithm>
#include <functional>
#include <iterator>
#include <vector>

#ifdef GFX_TIMSORT_ENABLE_ASSERT
#   include <cassert>
#   define GFX_TIMSORT_ASSERT(expr) assert(expr)
#else
#   define GFX_TIMSORT_ASSERT(expr) ((void)0)
#endif

#ifdef GFX_TIMSORT_ENABLE_LOG
#   include <iostream>
#   define GFX_TIMSORT_LOG(expr) (std::clog << "# " << __func__ << ": " << expr << std::endl)
#else
#   define GFX_TIMSORT_LOG(expr) ((void)0)
#endif

 // If GFX_TIMSORT_USE_STD_MOVE is not defined, try to define it as follows:
 // - Check standard feature-testing macro
 // - Check non-standard feature-testing macro
 // - Check C++ standard (disable if < C++11)
 // - Check compiler-specific versions known to support move semantics

#ifndef GFX_TIMSORT_USE_STD_MOVE
#   if defined(__cpp_rvalue_references)
#       define GFX_TIMSORT_USE_STD_MOVE 1
#   elif defined(__has_feature)
#       if __has_feature(cxx_rvalue_references)
#           define GFX_TIMSORT_USE_STD_MOVE 1
#       else
#           define GFX_TIMSORT_USE_STD_MOVE 0
#       endif
#   elif !(defined(__cplusplus) && __cplusplus >= 201103L)
#       define GFX_TIMSORT_USE_STD_MOVE 0
#   elif defined(_MSC_VER) && _MSC_VER >= 1700
#       define GFX_TIMSORT_USE_STD_MOVE 1
#   elif defined(__GNUC__) && (__GNUC__ >= 5 || (__GNUC__ >= 4 && __GNUC_MINOR__ >= 6))
#       define GFX_TIMSORT_USE_STD_MOVE 1
#   else
#       define GFX_TIMSORT_USE_STD_MOVE 0
#   endif
#endif

#if GFX_TIMSORT_USE_STD_MOVE
#include <utility>
#define GFX_TIMSORT_MOVE(x) std::move(x)
#define GFX_TIMSORT_MOVE_RANGE(in1, in2, out) std::move((in1), (in2), (out));
#define GFX_TIMSORT_MOVE_BACKWARD(in1, in2, out) std::move_backward((in1), (in2), (out));
#else
#define GFX_TIMSORT_MOVE(x) (x)
#define GFX_TIMSORT_MOVE_RANGE(in1, in2, out) std::copy((in1), (in2), (out));
#define GFX_TIMSORT_MOVE_BACKWARD(in1, in2, out) std::copy_backward((in1), (in2), (out));
#endif


// ---------------------------------------
// Declaration
// ---------------------------------------

/**
 * Same as std::stable_sort(first, last).
 */
template <typename RandomAccessIterator>
void timsort(RandomAccessIterator const first, RandomAccessIterator const last);

/**
 * Same as std::stable_sort(first, last, compare).
 */
template <typename RandomAccessIterator, typename Compare>
void timsort(RandomAccessIterator const first, RandomAccessIterator const last, Compare compare);

// ---------------------------------------
// Implementation
// ---------------------------------------

template <typename RandomAccessIterator, typename Compare> class TimSort {
	typedef RandomAccessIterator iter_t;
	typedef typename std::iterator_traits<iter_t>::value_type value_t;
	typedef typename std::iterator_traits<iter_t>::reference ref_t;
	typedef typename std::iterator_traits<iter_t>::difference_type diff_t;

	static const int MIN_MERGE = 32;
	static const int MIN_GALLOP = 7;

	int minGallop_; // default to MIN_GALLOP

	std::vector<value_t> tmp_; // temp storage for merges
	typedef typename std::vector<value_t>::iterator tmp_iter_t;

	struct run {
		iter_t base;
		diff_t len;

		run(iter_t const b, diff_t const l) : base(b), len(l) {}
	};
	std::vector<run> pending_;

	static void sort(iter_t const lo, iter_t const hi, Compare compare) {
		GFX_TIMSORT_ASSERT(lo <= hi);

		diff_t nRemaining = (hi - lo);
		if (nRemaining < 2) {
			return; // nothing to do
		}

		if (nRemaining < MIN_MERGE) {
			diff_t const initRunLen = countRunAndMakeAscending(lo, hi, compare);
			GFX_TIMSORT_LOG("initRunLen: " << initRunLen);
			binarySort(lo, hi, lo + initRunLen, compare);
			return;
		}

		TimSort ts;
		diff_t const minRun = minRunLength(nRemaining);
		iter_t cur = lo;
		do {
			diff_t runLen = countRunAndMakeAscending(cur, hi, compare);

			if (runLen < minRun) {
				diff_t const force = (std::min)(nRemaining, minRun);
				binarySort(cur, cur + force, cur + runLen, compare);
				runLen = force;
			}

			ts.pushRun(cur, runLen);
			ts.mergeCollapse(compare);

			cur += runLen;
			nRemaining -= runLen;
		} while (nRemaining != 0);

		GFX_TIMSORT_ASSERT(cur == hi);
		ts.mergeForceCollapse(compare);
		GFX_TIMSORT_ASSERT(ts.pending_.size() == 1);

		GFX_TIMSORT_LOG("size: " << (hi - lo) << " tmp_.size(): " << ts.tmp_.size()
			<< " pending_.size(): " << ts.pending_.size());
	}

	static void binarySort(iter_t const lo, iter_t const hi, iter_t start, Compare compare) {
		GFX_TIMSORT_ASSERT(lo <= start && start <= hi);
		if (start == lo) {
			++start;
		}
		for (; start < hi; ++start) {
			GFX_TIMSORT_ASSERT(lo <= start);
			value_t pivot = GFX_TIMSORT_MOVE(*start);

			iter_t const pos = std::upper_bound(lo, start, pivot, compare);
			for (iter_t p = start; p > pos; --p) {
				*p = GFX_TIMSORT_MOVE(*(p - 1));
			}
			*pos = GFX_TIMSORT_MOVE(pivot);
		}
	}

	static diff_t countRunAndMakeAscending(iter_t const lo, iter_t const hi, Compare compare) {
		GFX_TIMSORT_ASSERT(lo < hi);

		iter_t runHi = lo + 1;
		if (runHi == hi) {
			return 1;
		}

		if (compare(*(runHi++), *lo)) { // decreasing
			while (runHi < hi && compare(*runHi, *(runHi - 1))) {
				++runHi;
			}
			std::reverse(lo, runHi);
		}
		else { // non-decreasing
			while (runHi < hi && !compare(*runHi, *(runHi - 1))) {
				++runHi;
			}
		}

		return runHi - lo;
	}

	static diff_t minRunLength(diff_t n) {
		GFX_TIMSORT_ASSERT(n >= 0);

		diff_t r = 0;
		while (n >= MIN_MERGE) {
			r |= (n & 1);
			n >>= 1;
		}
		return n + r;
	}

	TimSort() : minGallop_(MIN_GALLOP) {}

	// Silence GCC -Winline warning
	~TimSort() {}

	void pushRun(iter_t const runBase, diff_t const runLen) {
		pending_.push_back(run(runBase, runLen));
	}

	void mergeCollapse(Compare compare) {
		while (pending_.size() > 1) {
			diff_t n = pending_.size() - 2;

			if ((n > 0 && pending_[n - 1].len <= pending_[n].len + pending_[n + 1].len) ||
				(n > 1 && pending_[n - 2].len <= pending_[n - 1].len + pending_[n].len)) {
				if (pending_[n - 1].len < pending_[n + 1].len) {
					--n;
				}
				mergeAt(n, compare);
			}
			else if (pending_[n].len <= pending_[n + 1].len) {
				mergeAt(n, compare);
			}
			else {
				break;
			}
		}
	}

	void mergeForceCollapse(Compare compare) {
		while (pending_.size() > 1) {
			diff_t n = pending_.size() - 2;

			if (n > 0 && pending_[n - 1].len < pending_[n + 1].len) {
				--n;
			}
			mergeAt(n, compare);
		}
	}

	void mergeAt(diff_t const i, Compare compare) {
		diff_t const stackSize = pending_.size();
		GFX_TIMSORT_ASSERT(stackSize >= 2);
		GFX_TIMSORT_ASSERT(i >= 0);
		GFX_TIMSORT_ASSERT(i == stackSize - 2 || i == stackSize - 3);

		iter_t base1 = pending_[i].base;
		diff_t len1 = pending_[i].len;
		iter_t base2 = pending_[i + 1].base;
		diff_t len2 = pending_[i + 1].len;

		GFX_TIMSORT_ASSERT(len1 > 0 && len2 > 0);
		GFX_TIMSORT_ASSERT(base1 + len1 == base2);

		pending_[i].len = len1 + len2;

		if (i == stackSize - 3) {
			pending_[i + 1] = pending_[i + 2];
		}

		pending_.pop_back();

		diff_t const k = gallopRight(*base2, base1, len1, 0, compare);
		GFX_TIMSORT_ASSERT(k >= 0);

		base1 += k;
		len1 -= k;

		if (len1 == 0) {
			return;
		}

		len2 = gallopLeft(*(base1 + (len1 - 1)), base2, len2, len2 - 1, compare);
		GFX_TIMSORT_ASSERT(len2 >= 0);
		if (len2 == 0) {
			return;
		}

		if (len1 <= len2) {
			mergeLo(base1, len1, base2, len2, compare);
		}
		else {
			mergeHi(base1, len1, base2, len2, compare);
		}
	}

	template <typename Iter>
	diff_t gallopLeft(ref_t key, Iter const base, diff_t const len, diff_t const hint, Compare compare) {
		GFX_TIMSORT_ASSERT(len > 0 && hint >= 0 && hint < len);

		diff_t lastOfs = 0;
		diff_t ofs = 1;

		if (compare(*(base + hint), key)) {
			diff_t const maxOfs = len - hint;
			while (ofs < maxOfs && compare(*(base + (hint + ofs)), key)) {
				lastOfs = ofs;
				ofs = (ofs << 1) + 1;

				if (ofs <= 0) { // int overflow
					ofs = maxOfs;
				}
			}
			if (ofs > maxOfs) {
				ofs = maxOfs;
			}

			lastOfs += hint;
			ofs += hint;
		}
		else {
			diff_t const maxOfs = hint + 1;
			while (ofs < maxOfs && !compare(*(base + (hint - ofs)), key)) {
				lastOfs = ofs;
				ofs = (ofs << 1) + 1;

				if (ofs <= 0) {
					ofs = maxOfs;
				}
			}
			if (ofs > maxOfs) {
				ofs = maxOfs;
			}

			diff_t const tmp = lastOfs;
			lastOfs = hint - ofs;
			ofs = hint - tmp;
		}
		GFX_TIMSORT_ASSERT(-1 <= lastOfs && lastOfs < ofs && ofs <= len);

		return std::lower_bound(base + (lastOfs + 1), base + ofs, key, compare) - base;
	}

	template <typename Iter>
	diff_t gallopRight(ref_t key, Iter const base, diff_t const len, diff_t const hint, Compare compare) {
		GFX_TIMSORT_ASSERT(len > 0 && hint >= 0 && hint < len);

		diff_t ofs = 1;
		diff_t lastOfs = 0;

		if (compare(key, *(base + hint))) {
			diff_t const maxOfs = hint + 1;
			while (ofs < maxOfs && compare(key, *(base + (hint - ofs)))) {
				lastOfs = ofs;
				ofs = (ofs << 1) + 1;

				if (ofs <= 0) {
					ofs = maxOfs;
				}
			}
			if (ofs > maxOfs) {
				ofs = maxOfs;
			}

			diff_t const tmp = lastOfs;
			lastOfs = hint - ofs;
			ofs = hint - tmp;
		}
		else {
			diff_t const maxOfs = len - hint;
			while (ofs < maxOfs && !compare(key, *(base + (hint + ofs)))) {
				lastOfs = ofs;
				ofs = (ofs << 1) + 1;

				if (ofs <= 0) { // int overflow
					ofs = maxOfs;
				}
			}
			if (ofs > maxOfs) {
				ofs = maxOfs;
			}

			lastOfs += hint;
			ofs += hint;
		}
		GFX_TIMSORT_ASSERT(-1 <= lastOfs && lastOfs < ofs && ofs <= len);

		return std::upper_bound(base + (lastOfs + 1), base + ofs, key, compare) - base;
	}

	static void rotateLeft(iter_t first, iter_t last) {
		value_t tmp = GFX_TIMSORT_MOVE(*first);
		iter_t last_1 = GFX_TIMSORT_MOVE_RANGE(first + 1, last, first);
		*last_1 = GFX_TIMSORT_MOVE(tmp);
	}

	static void rotateRight(iter_t first, iter_t last) {
		iter_t last_1 = last - 1;
		value_t tmp = GFX_TIMSORT_MOVE(*last_1);
		GFX_TIMSORT_MOVE_BACKWARD(first, last_1, last);
		*first = GFX_TIMSORT_MOVE(tmp);
	}


	void mergeLo(iter_t const base1, diff_t len1, iter_t const base2, diff_t len2, Compare compare) {
		GFX_TIMSORT_ASSERT(len1 > 0 && len2 > 0 && base1 + len1 == base2);

		if (len1 == 1) {
			return rotateLeft(base1, base2 + len2);
		}
		if (len2 == 1) {
			return rotateRight(base1, base2 + len2);
		}

		copy_to_tmp(base1, len1);

		tmp_iter_t cursor1 = tmp_.begin();
		iter_t cursor2 = base2;
		iter_t dest = base1;

		*(dest++) = GFX_TIMSORT_MOVE(*(cursor2++));
		--len2;

		int minGallop(minGallop_);

		// outer:
		while (true) {
			diff_t count1 = 0;
			diff_t count2 = 0;

			do {
				GFX_TIMSORT_ASSERT(len1 > 1 && len2 > 0);

				if (compare(*cursor2, *cursor1)) {
					*(dest++) = GFX_TIMSORT_MOVE(*(cursor2++));
					++count2;
					count1 = 0;
					if (--len2 == 0) {
						goto epilogue;
					}
				}
				else {
					*(dest++) = GFX_TIMSORT_MOVE(*(cursor1++));
					++count1;
					count2 = 0;
					if (--len1 == 1) {
						goto epilogue;
					}
				}
			} while ((count1 | count2) < minGallop);

			do {
				GFX_TIMSORT_ASSERT(len1 > 1 && len2 > 0);

				count1 = gallopRight(*cursor2, cursor1, len1, 0, compare);
				if (count1 != 0) {
					GFX_TIMSORT_MOVE_BACKWARD(cursor1, cursor1 + count1, dest + count1);
					dest += count1;
					cursor1 += count1;
					len1 -= count1;

					if (len1 <= 1) {
						goto epilogue;
					}
				}
				*(dest++) = GFX_TIMSORT_MOVE(*(cursor2++));
				if (--len2 == 0) {
					goto epilogue;
				}

				count2 = gallopLeft(*cursor1, cursor2, len2, 0, compare);
				if (count2 != 0) {
					GFX_TIMSORT_MOVE_RANGE(cursor2, cursor2 + count2, dest);
					dest += count2;
					cursor2 += count2;
					len2 -= count2;
					if (len2 == 0) {
						goto epilogue;
					}
				}
				*(dest++) = GFX_TIMSORT_MOVE(*(cursor1++));
				if (--len1 == 1) {
					goto epilogue;
				}

				--minGallop;
			} while ((count1 >= MIN_GALLOP) | (count2 >= MIN_GALLOP));

			if (minGallop < 0) {
				minGallop = 0;
			}
			minGallop += 2;
		} // end of "outer" loop

	epilogue: // merge what is left from either cursor1 or cursor2

		minGallop_ = (std::min)(minGallop, 1);

		if (len1 == 1) {
			GFX_TIMSORT_ASSERT(len2 > 0);
			GFX_TIMSORT_MOVE_RANGE(cursor2, cursor2 + len2, dest);
			*(dest + len2) = GFX_TIMSORT_MOVE(*cursor1);
		}
		else {
			GFX_TIMSORT_ASSERT(len1 != 0 && "Comparison function violates its general contract");
			GFX_TIMSORT_ASSERT(len2 == 0);
			GFX_TIMSORT_ASSERT(len1 > 1);
			GFX_TIMSORT_MOVE_RANGE(cursor1, cursor1 + len1, dest);
		}
	}

	void mergeHi(iter_t const base1, diff_t len1, iter_t const base2, diff_t len2, Compare compare) {
		GFX_TIMSORT_ASSERT(len1 > 0 && len2 > 0 && base1 + len1 == base2);

		if (len1 == 1) {
			return rotateLeft(base1, base2 + len2);
		}
		if (len2 == 1) {
			return rotateRight(base1, base2 + len2);
		}

		copy_to_tmp(base2, len2);

		iter_t cursor1 = base1 + len1;
		tmp_iter_t cursor2 = tmp_.begin() + (len2 - 1);
		iter_t dest = base2 + (len2 - 1);

		*(dest--) = GFX_TIMSORT_MOVE(*(--cursor1));
		--len1;

		int minGallop(minGallop_);

		// outer:
		while (true) {
			diff_t count1 = 0;
			diff_t count2 = 0;

			// The next loop is a hot path of the algorithm, so we decrement
			// eagerly the cursor so that it always points directly to the value
			// to compare, but we have to implement some trickier logic to make
			// sure that it points to the next value again by the end of said loop
			--cursor1;

			do {
				GFX_TIMSORT_ASSERT(len1 > 0 && len2 > 1);

				if (compare(*cursor2, *cursor1)) {
					*(dest--) = GFX_TIMSORT_MOVE(*cursor1);
					++count1;
					count2 = 0;
					if (--len1 == 0) {
						goto epilogue;
					}
					--cursor1;
				}
				else {
					*(dest--) = GFX_TIMSORT_MOVE(*(cursor2--));
					++count2;
					count1 = 0;
					if (--len2 == 1) {
						++cursor1; // See comment before the loop
						goto epilogue;
					}
				}
			} while ((count1 | count2) < minGallop);
			++cursor1; // See comment before the loop

			do {
				GFX_TIMSORT_ASSERT(len1 > 0 && len2 > 1);

				count1 = len1 - gallopRight(*cursor2, base1, len1, len1 - 1, compare);
				if (count1 != 0) {
					dest -= count1;
					cursor1 -= count1;
					len1 -= count1;
					GFX_TIMSORT_MOVE_BACKWARD(cursor1, cursor1 + count1, dest + (1 + count1));

					if (len1 == 0) {
						goto epilogue;
					}
				}
				*(dest--) = GFX_TIMSORT_MOVE(*(cursor2--));
				if (--len2 == 1) {
					goto epilogue;
				}

				count2 = len2 - gallopLeft(*(cursor1 - 1), tmp_.begin(), len2, len2 - 1, compare);
				if (count2 != 0) {
					dest -= count2;
					cursor2 -= count2;
					len2 -= count2;
					GFX_TIMSORT_MOVE_RANGE(cursor2 + 1, cursor2 + (1 + count2), dest + 1);
					if (len2 <= 1) {
						goto epilogue;
					}
				}
				*(dest--) = GFX_TIMSORT_MOVE(*(--cursor1));
				if (--len1 == 0) {
					goto epilogue;
				}

				minGallop--;
			} while ((count1 >= MIN_GALLOP) | (count2 >= MIN_GALLOP));

			if (minGallop < 0) {
				minGallop = 0;
			}
			minGallop += 2;
		} // end of "outer" loop

	epilogue: // merge what is left from either cursor1 or cursor2

		minGallop_ = (std::min)(minGallop, 1);

		if (len2 == 1) {
			GFX_TIMSORT_ASSERT(len1 > 0);
			dest -= len1;
			GFX_TIMSORT_MOVE_BACKWARD(cursor1 - len1, cursor1, dest + (1 + len1));
			*dest = GFX_TIMSORT_MOVE(*cursor2);
		}
		else {
			GFX_TIMSORT_ASSERT(len2 != 0 && "Comparison function violates its general contract");
			GFX_TIMSORT_ASSERT(len1 == 0);
			GFX_TIMSORT_ASSERT(len2 > 1);
			GFX_TIMSORT_MOVE_RANGE(tmp_.begin(), tmp_.begin() + len2, dest - (len2 - 1));
		}
	}

	void copy_to_tmp(iter_t const begin, diff_t len) {
#if GFX_TIMSORT_USE_STD_MOVE
		tmp_.assign(std::make_move_iterator(begin),
			std::make_move_iterator(begin + len));
#else
		tmp_.assign(begin, begin + len);
#endif
	}

	template <typename IterT, typename LessT>
	friend void timsort(IterT first, IterT last, LessT c);
};

template <typename RandomAccessIterator>
void timsort(RandomAccessIterator const first, RandomAccessIterator const last) {
	typedef typename std::iterator_traits<RandomAccessIterator>::value_type value_type;
	timsort(first, last, std::less<value_type>());
}

template <typename RandomAccessIterator, typename Compare>
void timsort(RandomAccessIterator const first, RandomAccessIterator const last, Compare compare) {
	TimSort<RandomAccessIterator, Compare>::sort(first, last, compare);
}


#undef GFX_TIMSORT_ENABLE_ASSERT
#undef GFX_TIMSORT_ASSERT
#undef GFX_TIMSORT_ENABLE_LOG
#undef GFX_TIMSORT_LOG
#undef GFX_TIMSORT_MOVE
#undef GFX_TIMSORT_MOVE_RANGE
#undef GFX_TIMSORT_MOVE_BACKWARD
#undef GFX_TIMSORT_USE_STD_MOVE

#endif // GFX_TIMSORT_HPP


























~-----------------------------------------------~
C:\Users\Josh\Documents\Visual Studio 2017\Projects\Sorting\Sorting\trace.h
~-----------------------------------------------~
#pragma once

#include <vector>
#include <iostream>
#include <string>

#include "sorting.h"

class Visualizer;

template <class T, class A = std::allocator<T>>
class TraceVector {
public:
	typedef T value_type;
	typedef T& reference;

	class iterator {
	public:
		typedef T value_type;
		typedef std::ptrdiff_t difference_type;	
		typedef T* pointer;
		typedef T& reference;		
		typedef std::random_access_iterator_tag iterator_category;

		iterator() : vec_{ NULL }, pointer_{ 0 }, vis_{ NULL } {}
		iterator(std::vector<value_type>* vec, Visualizer* vis) : vec_{ vec }, pointer_{ 0 }, vis_{ vis } {}
		iterator(std::vector<value_type>* vec, int size, Visualizer* vis) : vec_{ vec }, pointer_{ size }, vis_{ vis } {}

		iterator& operator=(const iterator& other) { 
			this->vec_ = other.vec_; 
			this->pointer_ = other.pointer_;
			return *this;
		}
		iterator& operator++() { ++pointer_; return *this; }
		iterator operator++(int) { iterator old(*this); ++*this; return old; }
		iterator& operator--() { --pointer_; return *this; }
		iterator operator--(int) { iterator old(*this); --*this; return old; }
		iterator& operator+=(const difference_type& diff) { pointer_ += diff; return *this; }
		iterator& operator-=(const difference_type& diff) { pointer_ -= diff; return *this; }
		iterator operator+(const difference_type& rhs) const { return iterator(vec_, pointer_ + rhs, vis_); }
		iterator operator-(const difference_type& rhs) const { return iterator(vec_, pointer_ - rhs, vis_); }
		difference_type operator-(iterator rhs) const { return pointer_ - rhs.pointer_; }
		difference_type operator+(iterator rhs) const { return pointer_ + rhs.pointer_; }
		reference operator[](size_t _Off) { iterator _It(vec_, pointer_, vis_); _It.pointer_ += _Off; return (*_It); }

		bool operator<(const iterator& rhs) const { return pointer_ < rhs.pointer_; }
		bool operator<=(const iterator& rhs) const { return pointer_ <= rhs.pointer_; }
		bool operator>(const iterator& rhs) const { return pointer_ > rhs.pointer_; }
		bool operator>=(const iterator& rhs) const { return pointer_ >= rhs.pointer_; }
		bool operator==(const iterator& rhs) const { return pointer_ == rhs.pointer_; }
		bool operator!=(const iterator& rhs) const { return !(*this == rhs); }

		//ACCESS
		reference operator*() const {
			if (vis_) {
				if (vis_->options.draw_options & DrawOption::Accesses)
					vis_->Draw(pointer_, Visualizer::DrawEventType::Access);
				++vis_->tv.access_count;
			}
			return vec_->at(pointer_);
		}

		void setVisualizer(Visualizer* vis) { 
			this->vis_ = vis;
		}

		int pointer_;
		std::vector<value_type>* vec_;
		Visualizer* vis_ = NULL;
	};

	TraceVector() {}
	TraceVector(size_t size) {
		vec_.resize(size);
	}

	//ACCESS
	reference operator[](size_t index) {
		if (vis_ && vis_->options.draw_options & DrawOption::Accesses)
			vis_->Draw(index, Visualizer::DrawEventType::Access);
		++access_count;
		return vec_[index];
	}

	TraceVector& operator=(const TraceVector<value_type>& tv) {
		vec_ = tv.vec_;
		return *this;
	}

	TraceVector& operator=(const std::vector<value_type>& vec) { 
		clear();
		for (unsigned i = 0; i < vec.size(); i++)
			push_back(vec[i]);
		return *this; 
	}

	void push_back(value_type value) {
		vec_.push_back(value);
		vec_.back().index_ = vec_.size() - 1;
		vec_.back().sorted_index_ = vec_.size() - 1;
		vec_.back().TV_ = this;
	}
	void resize(size_t new_size) { vec_.resize(new_size); }
	void resize(size_t new_size, value_type val) { vec_.resize(new_size, val); }
	void reserve(size_t new_capacity) { vec_.reserve(new_capacity); }
	void clear() { vec_.clear(); }
	size_t size() { return vec_.size(); }
	iterator begin() { return iterator(&vec_, vis_); }
	iterator end() { return iterator(&vec_, vec_.size(), vis_); }
	reference at(size_t pos) { return vec_.at(pos); }
	reference front() { return vec_.front(); }
	reference back() { return vec_.back(); }
//	const_reference at(size_type pos) const { return vec_.at(pos); }

	void setVisualizer(Visualizer* vis) {
		this->vis_ = vis;
		/*for (auto & it : vec_)
			it.setVisualizer(vis);*/
	//	vec_.front().setVisualizer(vis);
	}

	void reset_counts() {
		access_count = 0;
		swap_count = 0;
		compare_count = 0;
		assignment_count = 0;
	}

	std::vector<value_type> vec_;
	Visualizer* vis_ = NULL;

	unsigned long long access_count = 0;
	unsigned long long swap_count = 0;
	unsigned long long compare_count = 0;
	unsigned long long assignment_count = 0;
};

class TraceInt {
public:
	unsigned value = 0;

	unsigned index_ = 0;
	unsigned sorted_index_ = 0;
	TraceVector<TraceInt>* TV_ = NULL;

	constexpr TraceInt() noexcept : value() {}
	constexpr TraceInt(const unsigned & v) noexcept : value(v) {}
	TraceInt(const TraceInt& other) {
		this->value = other.value;
		this->index_ = other.index_;
		this->sorted_index_ = other.sorted_index_;
		this->TV_ = other.TV_;
	}

	constexpr const unsigned& get() const noexcept { return value; }

	TraceInt& operator=(const TraceInt& rhs);
	bool operator<(const TraceInt& rhs) const;
	bool operator>(const TraceInt& rhs) const;

	TraceInt& operator++() { ++value; return *this; }
	TraceInt operator++(int) { TraceInt tmp(*this); operator++(); return tmp; }
	TraceInt& operator--() { --value; return *this; }
	TraceInt operator--(int) { TraceInt tmp(*this); operator--(); return tmp; }
	TraceInt& operator+=(const TraceInt& rhs) { value += rhs.value; return *this; }
	TraceInt& operator-=(const TraceInt& rhs) { value -= rhs.value; return *this; }
	TraceInt& operator/=(const TraceInt& rhs) { value /= rhs.value; return *this; }
	operator unsigned() const { return value; }
	operator unsigned() { return value; }

	friend constexpr TraceInt operator+(const TraceInt& lhs, const unsigned& rhs) noexcept { return TraceInt(lhs.get() + rhs); }
	friend constexpr TraceInt operator+(const unsigned& lhs, const TraceInt& rhs) noexcept { return TraceInt(lhs + rhs.get()); }
	friend constexpr TraceInt operator+(const TraceInt& lhs, const TraceInt& rhs) noexcept { return TraceInt(lhs.get() + rhs.get()); }
	friend constexpr TraceInt operator-(const TraceInt& lhs, const unsigned& rhs) noexcept { return TraceInt(lhs.get() - rhs); }
	friend constexpr TraceInt operator-(const unsigned& lhs, const TraceInt& rhs) noexcept { return TraceInt(lhs - rhs.get()); }
	friend constexpr TraceInt operator-(const TraceInt& lhs, const TraceInt& rhs) noexcept { return TraceInt(lhs.get() - rhs.get()); }

	friend constexpr TraceInt operator+(const TraceInt& lhs, const int& rhs) noexcept { return TraceInt(lhs.get() + rhs); }
	friend constexpr TraceInt operator+(const int& lhs, const TraceInt& rhs) noexcept { return TraceInt(lhs + rhs.get()); }	
	friend constexpr TraceInt operator-(const TraceInt& lhs, const int& rhs) noexcept { return TraceInt(lhs.get() - rhs); }
	friend constexpr TraceInt operator-(const int& lhs, const TraceInt& rhs) noexcept { return TraceInt(lhs - rhs.get()); }

	friend std::ostream& operator<<(std::ostream& os, const TraceInt& ti) { os << ti.value;	return os; }
};

void swap(TraceInt& lhs, TraceInt& rhs);

void iter_swap(const TraceVector<TraceInt>::iterator& _Left, const TraceVector<TraceInt>::iterator& _Right);

//This can be removed, it doesn't do anything anymore
//template<class _Ty = void>
//struct TraceLess {
//	constexpr bool operator()(const _Ty& _Left, const _Ty& _Right) {
//		//	printf("%d < %d\n", _Left, _Right);
//		/*if (_Left.TV_->vis_ && _Left.TV_->vis_->draw_options & DrawOption::Comparisons)
//			_Left.TV_->vis_->Draw(_Left.pointer_, _Right.pointer_, Visualizer::DrawEventType::Comparison);*/
//		//++_Left.TV_->compare_count;
//		//		++g_compare_count;
//		return (_Left < _Right);
//	}
//};

//template<>
//struct TraceLess<void> {	// transparent functor for operator<
//	typedef int is_transparent;
//
//	template<class _Ty1,
//		class _Ty2>
//		constexpr auto operator()(_Ty1&& _Left, _Ty2&& _Right) const
//		-> decltype(static_cast<_Ty1&&>(_Left)
//					< static_cast<_Ty2&&>(_Right)) {	// transparently apply operator< to operands
//		return (static_cast<_Ty1&&>(_Left)
//				< static_cast<_Ty2&&>(_Right));
//	}
//};


























~-----------------------------------------------~
C:\Users\Josh\Documents\Visual Studio 2017\Projects\Sorting\Sorting\vergesort.h
~-----------------------------------------------~
/*
* vergesort.h - General-purpose hybrid sort
*
* The MIT License (MIT)
*
* Copyright (c) 2015-2017 Morwenn <morwenn29@hotmail.fr>
*
* Permission is hereby granted, free of charge, to any person obtaining a copy
* of this software and associated documentation files (the "Software"), to deal
* in the Software without restriction, including without limitation the rights
* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
* copies of the Software, and to permit persons to whom the Software is
* furnished to do so, subject to the following conditions:
*
* The above copyright notice and this permission notice shall be included in
* all copies or substantial portions of the Software.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
* THE SOFTWARE.
*/

/*
pdqsort.h - Pattern-defeating quicksort.
Copyright (c) 2015 Orson Peters
Modified by Morwenn in 2015-2017 to use in vergesort
This software is provided 'as-is', without any express or implied warranty. In no event will the
authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose, including commercial
applications, and to alter it and redistribute it freely, subject to the following restrictions:
1. The origin of this software must not be misrepresented; you must not claim that you wrote the
original software. If you use this software in a product, an acknowledgment in the product
documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as
being the original software.
3. This notice may not be removed or altered from any source distribution.
*/
#ifndef VERGESORT_VERGESORT_H_
#define VERGESORT_VERGESORT_H_

#include <algorithm>
#include <cstddef>
#include <functional>
#include <iterator>
#include <list>
#include <utility>

#include "skasort.h"

#if __cplusplus >= 201103L
#include <cstdint>
#include <type_traits>
#define VERGESORT_PREFER_MOVE(x) std::move(x)
#else
#define VERGESORT_PREFER_MOVE(x) (x)
#endif

namespace  {
namespace detail {
#if __cplusplus >= 201103L
template<typename T>
struct is_default_compare :
	std::false_type {};

template<typename T>
struct is_default_compare<std::less<T>> :
	std::true_type {};

template<typename T>
struct is_default_compare<std::greater<T>> :
	std::true_type {};
#endif

// Returns floor(log2(n)), assumes n > 0
template<typename Integer>
Integer log2(Integer n) {
	Integer log = 0;
	while (n >>= 1) {
		++log;
	}
	return log;
}

template<typename BidirectionalIterator>
BidirectionalIterator
prev(BidirectionalIterator it) {
	return --it;
}

template<typename BidirectionalIterator>
BidirectionalIterator
prev(BidirectionalIterator it,
	 typename std::iterator_traits<BidirectionalIterator>::difference_type n) {
	std::advance(it, -n);
	return it;
}

template<typename ForwardIterator>
ForwardIterator
next(ForwardIterator it) {
	return ++it;
}

template<typename ForwardIterator>
ForwardIterator
next(ForwardIterator it,
	 typename std::iterator_traits<ForwardIterator>::difference_type n) {
	std::advance(it, n);
	return it;
}

template<typename Iterator, typename Compare>
void iter_sort3(Iterator a, Iterator b, Iterator c,
				Compare compare) {
	if (compare(*b, *a)) { iter_swap(a, b); }
	if (compare(*c, *b)) { iter_swap(b, c); }
	if (compare(*b, *a)) { iter_swap(a, b); }
}

// C++03 implementation of std::is_sorted_until
template<typename ForwardIterator, typename Compare>
ForwardIterator is_sorted_until(ForwardIterator first, ForwardIterator last,
								Compare compare) {
	if (first != last) {
		ForwardIterator next = first;
		while (++next != last) {
			if (compare(*next, *first)) {
				return next;
			}
			first = next;
		}
	}
	return last;
}

// Sorts [begin, end) using insertion sort with the given comparison function.
template<typename BidirectionalIterator, typename Compare>
void insertion_sort(BidirectionalIterator begin, BidirectionalIterator end, Compare comp) {
	typedef typename std::iterator_traits<BidirectionalIterator>::value_type T;
	if (begin == end) return;

	for (BidirectionalIterator cur = detail::next(begin); cur != end; ++cur) {
		BidirectionalIterator sift = cur;
		BidirectionalIterator sift_1 = detail::prev(cur);

		// Compare first so we can avoid 2 moves for an element already positioned correctly.
		if (comp(*sift, *sift_1)) {
			T tmp = VERGESORT_PREFER_MOVE(*sift);

			do {
				*sift-- = VERGESORT_PREFER_MOVE(*sift_1);
			} while (sift != begin && comp(tmp, *--sift_1));

			*sift = VERGESORT_PREFER_MOVE(tmp);
		}
	}
}

enum {
	// Partitions below this size are sorted using insertion sort.
	insertion_sort_threshold = 24,

	// Partitions above this size use Tukey's ninther to select the pivot.
	ninther_threshold = 80,

	// When we detect an already sorted partition, attempt an insertion sort that allows this
	// amount of element moves before giving up.
	partial_insertion_sort_limit = 8,

	// Must be multiple of 8 due to loop unrolling, and < 256 to fit in unsigned char.
	block_size = 64,

	// Cacheline size, assumes power of two.
	cacheline_size = 64
};

// Sorts [begin, end) using insertion sort with the given comparison function. Assumes
// *(begin - 1) is an element smaller than or equal to any element in [begin, end).
template<typename Iter, typename Compare>
void unguarded_insertion_sort(Iter begin, Iter end, Compare comp) {
	typedef typename std::iterator_traits<Iter>::value_type T;
	if (begin == end) return;

	for (Iter cur = begin + 1; cur != end; ++cur) {
		Iter sift = cur;
		Iter sift_1 = cur - 1;

		// Compare first so we can avoid 2 moves for an element already positioned correctly.
		if (comp(*sift, *sift_1)) {
			T tmp = VERGESORT_PREFER_MOVE(*sift);

			do { *sift-- = VERGESORT_PREFER_MOVE(*sift_1); } while (comp(tmp, *--sift_1));

			*sift = VERGESORT_PREFER_MOVE(tmp);
		}
	}
}

// Attempts to use insertion sort on [begin, end). Will return false if more than
// partial_insertion_sort_limit elements were moved, and abort sorting. Otherwise it will
// successfully sort and return true.
template<typename Iter, typename Compare>
inline bool partial_insertion_sort(Iter begin, Iter end, Compare comp) {
	typedef typename std::iterator_traits<Iter>::value_type T;
	if (begin == end) return true;

	int limit = 0;
	for (Iter cur = begin + 1; cur != end; ++cur) {
		if (limit > partial_insertion_sort_limit) return false;

		Iter sift = cur;
		Iter sift_1 = cur - 1;

		// Compare first so we can avoid 2 moves for an element already positioned correctly.
		if (comp(*sift, *sift_1)) {
			T tmp = VERGESORT_PREFER_MOVE(*sift);

			do { *sift-- = VERGESORT_PREFER_MOVE(*sift_1); } while (sift != begin && comp(tmp, *--sift_1));

			*sift = VERGESORT_PREFER_MOVE(tmp);
			limit += cur - sift;
		}
	}

	return true;
}

template<typename T>
T* align_cacheline(T* p) {
#ifdef UINTPTR_MAX
	std::uintptr_t ip = reinterpret_cast<std::uintptr_t>(p);
#else
	std::size_t ip = reinterpret_cast<std::size_t>(p);
#endif
	ip = (ip + cacheline_size - 1) & -cacheline_size;
	return reinterpret_cast<T*>(ip);
}

template<typename RandomAccessIterator>
void swap_offsets(RandomAccessIterator first, RandomAccessIterator last,
				  unsigned char* offsets_l, unsigned char* offsets_r,
				  int num, bool use_swaps) {
	typedef typename std::iterator_traits<RandomAccessIterator>::value_type T;
	if (use_swaps) {
		// This case is needed for the descending distribution, where we need
		// to have proper swapping for pdqsort to remain O(n).
		for (int i = 0; i < num; ++i) {
			iter_swap(first + offsets_l[i], last - offsets_r[i]);
		}
	}
	else if (num > 0) {
		RandomAccessIterator l = first + offsets_l[0];
		RandomAccessIterator r = last - offsets_r[0];
		T tmp(VERGESORT_PREFER_MOVE(*l)); *l = VERGESORT_PREFER_MOVE(*r);
		for (int i = 1; i < num; ++i) {
			l = first + offsets_l[i]; *r = VERGESORT_PREFER_MOVE(*l);
			r = last - offsets_r[i]; *l = VERGESORT_PREFER_MOVE(*r);
		}
		*r = VERGESORT_PREFER_MOVE(tmp);
	}
}

// Partitions [begin, end) around pivot *begin using comparison function comp. Elements equal
// to the pivot are put in the right-hand partition. Returns the position of the pivot after
// partitioning and whether the passed sequence already was correctly partitioned. Assumes the
// pivot is a median of at least 3 elements and that [begin, end) is at least
// insertion_sort_threshold long. Uses branchless partitioning.
template<typename RandomAccessIterator, typename Compare>
std::pair<RandomAccessIterator, bool>
partition_right_branchless(RandomAccessIterator begin, RandomAccessIterator end,
						   Compare comp) {
	typedef typename std::iterator_traits<RandomAccessIterator>::value_type T;

	// Move pivot into local for speed.
	T pivot(VERGESORT_PREFER_MOVE(*begin));
	RandomAccessIterator first = begin;
	RandomAccessIterator last = end;

	// Find the first element greater than or equal than the pivot (the median of 3 guarantees
	// this exists).
	while (comp(*++first, pivot));

	// Find the first element strictly smaller than the pivot. We have to guard this search if
	// there was no element before *first.
	if (first - 1 == begin) while (first < last && !comp(*--last, pivot));
	else                    while (!comp(*--last, pivot));

	// If the first pair of elements that should be swapped to partition are the same element,
	// the passed in sequence already was correctly partitioned.
	bool already_partitioned = first >= last;
	if (!already_partitioned) {
		iter_swap(first, last);
		++first;
	}

	// The following branchless partitioning is derived from "BlockQuicksort: How Branch
	// Mispredictions dont affect Quicksort" by Stefan Edelkamp and Armin Weiss.
	unsigned char offsets_l_storage[block_size + cacheline_size];
	unsigned char offsets_r_storage[block_size + cacheline_size];
	unsigned char* offsets_l = align_cacheline(offsets_l_storage);
	unsigned char* offsets_r = align_cacheline(offsets_r_storage);
	int num_l, num_r, start_l, start_r;
	num_l = num_r = start_l = start_r = 0;

	while (last - first > 2 * block_size) {
		// Fill up offset blocks with elements that are on the wrong side.
		if (num_l == 0) {
			start_l = 0;
			RandomAccessIterator it = first;
			for (unsigned char i = 0; i < block_size;) {
				offsets_l[num_l] = i++; num_l += !comp(*it, pivot); ++it;
				offsets_l[num_l] = i++; num_l += !comp(*it, pivot); ++it;
				offsets_l[num_l] = i++; num_l += !comp(*it, pivot); ++it;
				offsets_l[num_l] = i++; num_l += !comp(*it, pivot); ++it;
				offsets_l[num_l] = i++; num_l += !comp(*it, pivot); ++it;
				offsets_l[num_l] = i++; num_l += !comp(*it, pivot); ++it;
				offsets_l[num_l] = i++; num_l += !comp(*it, pivot); ++it;
				offsets_l[num_l] = i++; num_l += !comp(*it, pivot); ++it;
			}
		}
		if (num_r == 0) {
			start_r = 0;
			RandomAccessIterator it = last;
			for (unsigned char i = 0; i < block_size;) {
				offsets_r[num_r] = ++i; num_r += comp(*--it, pivot);
				offsets_r[num_r] = ++i; num_r += comp(*--it, pivot);
				offsets_r[num_r] = ++i; num_r += comp(*--it, pivot);
				offsets_r[num_r] = ++i; num_r += comp(*--it, pivot);
				offsets_r[num_r] = ++i; num_r += comp(*--it, pivot);
				offsets_r[num_r] = ++i; num_r += comp(*--it, pivot);
				offsets_r[num_r] = ++i; num_r += comp(*--it, pivot);
				offsets_r[num_r] = ++i; num_r += comp(*--it, pivot);
			}
		}

		// Swap elements and update block sizes and first/last boundaries.
		int num = std::min(num_l, num_r);
		swap_offsets(first, last, offsets_l + start_l, offsets_r + start_r,
					 num, num_l == num_r);
		num_l -= num; num_r -= num;
		start_l += num; start_r += num;
		if (num_l == 0) first += block_size;
		if (num_r == 0) last -= block_size;
	}

	int l_size = 0, r_size = 0;
	int unknown_left = (last - first) - ((num_r || num_l) ? block_size : 0);
	if (num_r) {
		// Handle leftover block by assigning the unknown elements to the other block.
		l_size = unknown_left;
		r_size = block_size;
	}
	else if (num_l) {
		l_size = block_size;
		r_size = unknown_left;
	}
	else {
		// No leftover block, split the unknown elements in two blocks.
		l_size = unknown_left / 2;
		r_size = unknown_left - l_size;
	}

	// Fill offset buffers if needed.
	if (unknown_left && !num_l) {
		start_l = 0;
		RandomAccessIterator it = first;
		for (unsigned char i = 0; i < l_size;) {
			offsets_l[num_l] = i++; num_l += !comp(*it, pivot); ++it;
		}
	}
	if (unknown_left && !num_r) {
		start_r = 0;
		RandomAccessIterator it = last;
		for (unsigned char i = 0; i < r_size;) {
			offsets_r[num_r] = ++i; num_r += comp(*--it, pivot);
		}
	}

	int num = std::min(num_l, num_r);
	swap_offsets(first, last, offsets_l + start_l, offsets_r + start_r, num, num_l == num_r);
	num_l -= num; num_r -= num;
	start_l += num; start_r += num;
	if (num_l == 0) first += l_size;
	if (num_r == 0) last -= r_size;

	// We have now fully identified [first, last)'s proper position. Swap the last elements.
	if (num_l) {
		offsets_l += start_l;
		while (num_l--) iter_swap(first + offsets_l[num_l], --last);
		first = last;
	}
	if (num_r) {
		offsets_r += start_r;
		while (num_r--) iter_swap(last - offsets_r[num_r], first), ++first;
		last = first;
	}

	// Put the pivot in the right place.
	RandomAccessIterator pivot_pos = first - 1;
	*begin = VERGESORT_PREFER_MOVE(*pivot_pos);
	*pivot_pos = VERGESORT_PREFER_MOVE(pivot);

	return std::make_pair(pivot_pos, already_partitioned);
}

// Partitions [begin, end) around pivot *begin using comparison function comp. Elements equal
// to the pivot are put in the right-hand partition. Returns the position of the pivot after
// partitioning and whether the passed sequence already was correctly partitioned. Assumes the
// pivot is a median of at least 3 elements and that [begin, end) is at least
// insertion_sort_threshold long.
template<class RandomAccessIterator, class Compare>
std::pair<RandomAccessIterator, bool>
partition_right(RandomAccessIterator begin, RandomAccessIterator end, Compare comp) {
	typedef typename std::iterator_traits<RandomAccessIterator>::value_type T;

	// Move pivot into local for speed.
	T pivot(VERGESORT_PREFER_MOVE(*begin));

	RandomAccessIterator first = begin;
	RandomAccessIterator last = end;

	// Find the first element greater than or equal than the pivot (the median of 3 guarantees
	// this exists).
	while (comp(*++first, pivot));

	// Find the first element strictly smaller than the pivot. We have to guard this search if
	// there was no element before *first.
	if (first - 1 == begin) while (first < last && !comp(*--last, pivot));
	else                    while (!comp(*--last, pivot));

	// If the first pair of elements that should be swapped to partition are the same element,
	// the passed in sequence already was correctly partitioned.
	bool already_partitioned = first >= last;

	// Keep swapping pairs of elements that are on the wrong side of the pivot. Previously
	// swapped pairs guard the searches, which is why the first iteration is special-cased
	// above.
	while (first < last) {
		iter_swap(first, last);
		while (comp(*++first, pivot));
		while (!comp(*--last, pivot));
	}

	// Put the pivot in the right place.
	RandomAccessIterator pivot_pos = first - 1;
	*begin = VERGESORT_PREFER_MOVE(*pivot_pos);
	*pivot_pos = VERGESORT_PREFER_MOVE(pivot);

	return std::make_pair(pivot_pos, already_partitioned);
}

// Similar function to the one above, except elements equal to the pivot are put to the left of
// the pivot and it doesn't check or return if the passed sequence already was partitioned.
// Since this is rarely used (the many equal case), and in that case pdqsort already has O(n)
// performance, no block quicksort is applied here for simplicity.
template<typename RandomAccessIterator, typename Compare>
RandomAccessIterator
partition_left(RandomAccessIterator begin, RandomAccessIterator end,
			   Compare comp) {
	typedef typename std::iterator_traits<RandomAccessIterator>::value_type T;

	T pivot(VERGESORT_PREFER_MOVE(*begin));
	RandomAccessIterator first = begin;
	RandomAccessIterator last = end;

	while (comp(pivot, *--last));

	if (last + 1 == end) while (first < last && !comp(pivot, *++first));
	else                 while (!comp(pivot, *++first));

	while (first < last) {
		iter_swap(first, last);
		while (comp(pivot, *--last));
		while (!comp(pivot, *++first));
	}

	RandomAccessIterator pivot_pos = last;
	*begin = VERGESORT_PREFER_MOVE(*pivot_pos);
	*pivot_pos = VERGESORT_PREFER_MOVE(pivot);

	return pivot_pos;
}

template<typename RandomAccessIterator, typename Compare, bool Branchless>
void pdqsort_loop(RandomAccessIterator begin, RandomAccessIterator end,
				  Compare comp, int bad_allowed, bool leftmost = true) {
	typedef typename std::iterator_traits<RandomAccessIterator>::difference_type diff_t;

	// Use a while loop for tail recursion elimination.
	while (true) {
		diff_t size = end - begin;

		// Insertion sort is faster for small arrays.
		if (size < insertion_sort_threshold) {
			if (leftmost) ::insertion_sort(begin, end, comp);
			else unguarded_insertion_sort(begin, end, comp);
			return;
		}

		// Choose pivot as median of 3 or pseudomedian of 9.
		diff_t s2 = size / 2;
		if (size > ninther_threshold) {
			iter_sort3(begin, begin + s2, end - 1, comp);
			iter_sort3(begin + 1, begin + (s2 - 1), end - 2, comp);
			iter_sort3(begin + 2, begin + (s2 + 1), end - 3, comp);
			iter_sort3(begin + (s2 - 1), begin + s2, begin + (s2 + 1), comp);
			iter_swap(begin, begin + s2);
		}
		else {
			iter_sort3(begin + s2, begin, end - 1, comp);
		}

		// If *(begin - 1) is the end of the right partition of a previous partition operation
		// there is no element in [begin, end) that is smaller than *(begin - 1). Then if our
		// pivot compares equal to *(begin - 1) we change strategy, putting equal elements in
		// the left partition, greater elements in the right partition. We do not have to
		// recurse on the left partition, since it's sorted (all equal).
		if (!leftmost && !comp(*(begin - 1), *begin)) {
			begin = partition_left(begin, end, comp) + 1;
			continue;
		}

		// Partition and get results.
		std::pair<RandomAccessIterator, bool> part_result;
		if (Branchless) part_result = partition_right_branchless(begin, end, comp);
		else            part_result = partition_right(begin, end, comp);
		RandomAccessIterator pivot_pos = part_result.first;
		bool already_partitioned = part_result.second;

		// Check for a highly unbalanced partition.
		diff_t l_size = pivot_pos - begin;
		diff_t r_size = end - (pivot_pos + 1);
		bool highly_unbalanced = l_size < size / 8 || r_size < size / 8;

		// If we got a highly unbalanced partition we shuffle elements to break many patterns.
		if (highly_unbalanced) {
			// If we had too many bad partitions, switch to heapsort to guarantee O(n log n).
			if (--bad_allowed == 0) {
				std::make_heap(begin, end, comp);
				std::sort_heap(begin, end, comp);
				return;
			}

			if (l_size >= insertion_sort_threshold) {
				iter_swap(begin, begin + l_size / 4);
				iter_swap(pivot_pos - 1, pivot_pos - l_size / 4);

				if (l_size > ninther_threshold) {
					iter_swap(begin + 1, begin + (l_size / 4 + 1));
					iter_swap(begin + 2, begin + (l_size / 4 + 2));
					iter_swap(pivot_pos - 2, pivot_pos - (l_size / 4 + 1));
					iter_swap(pivot_pos - 3, pivot_pos - (l_size / 4 + 2));
				}
			}

			if (r_size >= insertion_sort_threshold) {
				iter_swap(pivot_pos + 1, pivot_pos + (1 + r_size / 4));
				iter_swap(end - 1, end - r_size / 4);

				if (r_size > ninther_threshold) {
					iter_swap(pivot_pos + 2, pivot_pos + (2 + r_size / 4));
					iter_swap(pivot_pos + 3, pivot_pos + (3 + r_size / 4));
					iter_swap(end - 2, end - (1 + r_size / 4));
					iter_swap(end - 3, end - (2 + r_size / 4));
				}
			}
		}
		else {
			// If we were decently balanced and we tried to sort an already partitioned
			// sequence try to use insertion sort.
			if (already_partitioned && partial_insertion_sort(begin, pivot_pos, comp)
				&& partial_insertion_sort(pivot_pos + 1, end, comp)) return;
		}

		// Sort the left partition first using recursion and do tail recursion elimination for
		// the right-hand partition.
		pdqsort_loop<RandomAccessIterator, Compare, Branchless>(
			begin, pivot_pos, comp, bad_allowed, leftmost);
		begin = pivot_pos + 1;
		leftmost = false;
	}
}

template<typename RandomAccessIterator, typename Compare>
void pdqsort(RandomAccessIterator begin, RandomAccessIterator end, Compare comp) {
	if (begin == end) return;

#if __cplusplus >= 201103L
	pdqsort_loop<RandomAccessIterator, Compare,
		is_default_compare<typename std::decay<Compare>::type>::value &&
		std::is_arithmetic<typename std::iterator_traits<RandomAccessIterator>::value_type>::value>(
			begin, end, comp, log2(end - begin));
#else
	pdqsort_loop<RandomAccessIterator, Compare, false>(
		begin, end, comp, log2(end - begin));
#endif
}

// partial application structs for partition
template<typename T, typename Compare>
struct partition_pivot_left {
	const T& pivot;
	Compare compare;

	partition_pivot_left(const T& pivot, const Compare& compare) :
		pivot(pivot),
		compare(compare) {}

	bool operator()(const T& elem) const {
		return compare(elem, pivot);
	}
};

template<typename T, typename Compare>
struct partition_pivot_right {
	const T& pivot;
	Compare compare;

	partition_pivot_right(const T& pivot, const Compare& compare) :
		pivot(pivot),
		compare(compare) {}

	bool operator()(const T& elem) const {
		return not compare(pivot, elem);
	}
};

template<typename ForwardIterator, typename Compare>
void quicksort(ForwardIterator first, ForwardIterator last,
			   typename std::iterator_traits<ForwardIterator>::difference_type size,
			   Compare compare) {
	typedef typename std::iterator_traits<ForwardIterator>::value_type value_type;
	typedef typename std::iterator_traits<ForwardIterator>::difference_type difference_type;
	using std::swap;

	// If the collection is small, fall back to insertion sort
	if (size < 32) {
		::insertion_sort(first, last, compare);
		return;
	}

	// Choose pivot as median of 9
	ForwardIterator it1 = detail::next(first, size / 8);
	ForwardIterator it2 = detail::next(it1, size / 8);
	ForwardIterator it3 = detail::next(it2, size / 8);
	ForwardIterator middle = detail::next(it3, size / 2 - 3 * (size / 8));
	ForwardIterator it4 = detail::next(middle, size / 8);
	ForwardIterator it5 = detail::next(it4, size / 8);
	ForwardIterator it6 = detail::next(it5, size / 8);
	ForwardIterator last_1 = detail::next(it6, size - size / 2 - 3 * (size / 8) - 1);

	iter_sort3(first, it1, it2, compare);
	iter_sort3(it3, middle, it4, compare);
	iter_sort3(it5, it6, last_1, compare);
	iter_sort3(it1, middle, it4, compare);

	// Put the pivot at position prev(last) and partition
	iter_swap(middle, last_1);
	ForwardIterator middle1 = std::partition(
		first, last_1,
		partition_pivot_left<value_type, Compare>(*last_1, compare)
	);

	// Put the pivot in its final position and partition
	iter_swap(middle1, last_1);
	ForwardIterator middle2 = std::partition(
		detail::next(middle1), last,
		partition_pivot_right<value_type, Compare>(*middle1, compare)
	);

	// Recursive call: heuristic trick here: in real world cases,
	// the middle partition is more likely to be smaller than the
	// right one, so computing its size should generally be cheaper
	difference_type size_left = std::distance(first, middle1);
	difference_type size_middle = std::distance(middle1, middle2);
	difference_type size_right = size - size_left - size_middle;

	// Recurse in the smallest partition first to limit the call
	// stack overhead
	if (size_left > size_right) {
		swap(first, middle2);
		swap(middle1, last);
		swap(size_left, size_right);
	}
	quicksort(first, middle1, size_left, compare);
	quicksort(middle2, last, size_right,
			  VERGESORT_PREFER_MOVE(compare));
}

// In-place merge where [first, middle1), [middle1, middle2)
// and [middle2, last) are sorted. The two in-place merges are
// done in the order that should result in the smallest number
// of comparisons
template<typename BidirectionalIterator, typename Compare>
void inplace_merge3(BidirectionalIterator first, BidirectionalIterator middle1,
					BidirectionalIterator middle2, BidirectionalIterator last,
					Compare compare) {
	if (std::distance(first, middle1) < std::distance(middle2, last)) {
		std::inplace_merge(first, middle1, middle2, compare);
		std::inplace_merge(first, middle2, last, compare);
	}
	else {
		std::inplace_merge(middle1, middle2, last, compare);
		std::inplace_merge(first, middle1, last, compare);
	}
}

// vergesort for bidirectional iterators
template<typename BidirectionalIterator, typename Compare>
void vergesort(BidirectionalIterator first, BidirectionalIterator last,
			   Compare compare, std::bidirectional_iterator_tag) {
	typedef typename std::iterator_traits<BidirectionalIterator>::difference_type difference_type;

	difference_type dist = std::distance(first, last);
	if (dist < 80) {
		// vergesort is inefficient for small collections
		quicksort(first, last, dist, compare);
		return;
	}

	// Limit under which quicksort is used
	int unstable_limit = dist / log2(dist);

	// Beginning of an unstable partition, last if the
	// previous partition is stable
	BidirectionalIterator begin_unstable = last;

	// Size of the unstable partition
	std::size_t size_unstable = 0;

	// Pair of iterators to iterate through the collection
	BidirectionalIterator next = detail::is_sorted_until(first, last, compare);
	BidirectionalIterator current = next;
	--current;

	while (true) {
		BidirectionalIterator begin_rng = current;

		// Decreasing range
		while (next != last) {
			if (compare(*current, *next)) break;
			++current;
			++next;
		}

		// Reverse and merge
		dist = std::distance(begin_rng, next);
		if (dist > unstable_limit) {
			if (begin_unstable != last) {
				quicksort(begin_unstable, begin_rng, size_unstable, compare);
				std::reverse(begin_rng, next);
				std::inplace_merge(begin_unstable, begin_rng, next, compare);
				std::inplace_merge(first, begin_unstable, next, compare);
				begin_unstable = last;
				size_unstable = 0;
			}
			else {
				std::reverse(begin_rng, next);
				std::inplace_merge(first, begin_rng, next, compare);
			}
		}
		else {
			size_unstable += dist;
			if (begin_unstable == last) begin_unstable = begin_rng;
		}

		if (next == last) break;

		++current;
		++next;

		begin_rng = current;

		// Increasing range
		while (next != last) {
			if (compare(*next, *current)) break;
			++current;
			++next;
		}

		// Merge
		dist = std::distance(begin_rng, next);
		if (dist > unstable_limit) {
			if (begin_unstable != last) {
				quicksort(begin_unstable, begin_rng, size_unstable, compare);
				std::inplace_merge(begin_unstable, begin_rng, next, compare);
				std::inplace_merge(first, begin_unstable, next, compare);
				begin_unstable = last;
				size_unstable = 0;
			}
			else {
				std::inplace_merge(first, begin_rng, next, compare);
			}
		}
		else {
			size_unstable += dist;
			if (begin_unstable == last) begin_unstable = begin_rng;
		}

		if (next == last) break;

		++current;
		++next;
	}

	if (begin_unstable != last) {
		quicksort(begin_unstable, last, size_unstable, compare);
		std::inplace_merge(first, begin_unstable, last, compare);
	}
}

template<typename RandomAccessIterator, typename Compare, typename Fallback>
void vergesort(RandomAccessIterator first, RandomAccessIterator last,
			   Compare compare, Fallback fallback, std::random_access_iterator_tag) {
	typedef typename std::iterator_traits<RandomAccessIterator>::difference_type difference_type;
	difference_type dist = std::distance(first, last);

	if (dist < 80) {
		// Vergesort is inefficient for small collections
		fallback(first, last, compare);
		return;
	}

	// Limit under which pdqsort is used to sort a sub-sequence
	const difference_type unstable_limit = dist / detail::log2(dist);

	// Vergesort detects big runs in ascending or descending order,
	// and remember where each run ends by storing the end iterator
	// of each run in this list, then it merges everything in the end
	std::list<RandomAccessIterator> runs;

	// Beginning of an unstable partition, or last if the previous
	// partition is stable
	RandomAccessIterator begin_unstable = last;

	// Pair of iterators to iterate through the collection
	RandomAccessIterator current = first;
	RandomAccessIterator next = detail::next(first);

	while (true) {
		// Beginning of the current sequence
		RandomAccessIterator begin_range = current;

		// If the last part of the collection to sort isn't
		// big enough, consider that it is an unstable sequence
		if (std::distance(next, last) <= unstable_limit) {
			if (begin_unstable == last) {
				begin_unstable = begin_range;
			}
			break;
		}

		// Set backward iterators
		std::advance(current, unstable_limit);
		std::advance(next, unstable_limit);

		// Set forward iterators
		RandomAccessIterator current2 = current;
		RandomAccessIterator next2 = next;

		if (compare(*next, *current)) {
			// Found a decreasing sequence, move iterators
			// to the limits of the sequence
			while (current != begin_range) {
				--current;
				--next;
				if (compare(*current, *next)) break;
			}
			if (compare(*current, *next)) ++current;

			++current2;
			++next2;
			while (next2 != last) {
				if (compare(*current2, *next2)) break;
				++current2;
				++next2;
			}

			// Check whether we found a big enough sorted sequence
			if (std::distance(current, next2) >= unstable_limit) {
				std::reverse(current, next2);
				if (std::distance(begin_range, current) && begin_unstable == last) {
					begin_unstable = begin_range;
				}
				if (begin_unstable != last) {
					fallback(begin_unstable, current, compare);
					runs.push_back(current);
					begin_unstable = last;
				}
				runs.push_back(next2);
			}
			else {
				// Remember the beginning of the unsorted sequence
				if (begin_unstable == last) {
					begin_unstable = begin_range;
				}
			}
		}
		else {
			// Found an increasing sequence, move iterators
			// to the limits of the sequence
			while (current != begin_range) {
				--current;
				--next;
				if (compare(*next, *current)) break;
			}
			if (compare(*next, *current)) ++current;

			++current2;
			++next2;
			while (next2 != last) {
				if (compare(*next2, *current2)) break;
				++current2;
				++next2;
			}

			// Check whether we found a big enough sorted sequence
			if (std::distance(current, next2) >= unstable_limit) {
				if (std::distance(begin_range, current) && begin_unstable == last) {
					begin_unstable = begin_range;
				}
				if (begin_unstable != last) {
					fallback(begin_unstable, current, compare);
					runs.push_back(current);
					begin_unstable = last;
				}
				runs.push_back(next2);
			}
			else {
				// Remember the beginning of the unsorted sequence
				if (begin_unstable == last) {
					begin_unstable = begin_range;
				}
			}
		}

		if (next2 == last) break;

		current = detail::next(current2);
		next = detail::next(next2);
	}

	if (begin_unstable != last) {
		// If there are unsorted elements left, sort them
		runs.push_back(last);
		fallback(begin_unstable, last, compare);
	}

	if (runs.size() < 2) return;

	// Merge runs pairwise until there aren't runs left
	do {
		RandomAccessIterator begin = first;
		for (typename std::list<RandomAccessIterator>::iterator it = runs.begin();
			 it != runs.end() && it != detail::prev(runs.end());
			 ++it) {
			std::inplace_merge(begin, *it, *detail::next(it), compare);

			// Remove the middle iterator and advance
			it = runs.erase(it);
			begin = *it;
		}
	} while (runs.size() > 1);
}

}//namespace detail

template<typename BidirectionalIterator, typename Compare, typename Fallback>
auto vergesort(BidirectionalIterator first, BidirectionalIterator last, Compare compare, Fallback fallback) -> void {
	detail::vergesort(std::move(first), std::move(last), std::move(compare), std::move(fallback), std::random_access_iterator_tag{});
}

template<typename RandomAccessIterator, typename Compare>
auto vergesort(RandomAccessIterator first, RandomAccessIterator last, Compare compare) -> void {
	::vergesort(first, last, compare, detail::pdqsort<RandomAccessIterator, Compare>);
}

template<typename T, typename C>
void vergeskasort(T first, T last, C compare) {
	vergesort(std::move(first), std::move(last), std::move(compare), skasort<T, C>);
}

//template<typename BidirectionalIterator, typename Compare>
//auto vergesort(BidirectionalIterator first, BidirectionalIterator last, Compare compare) -> void {
//	using category = typename std::iterator_traits<BidirectionalIterator>::iterator_category;
//	detail::vergesort(std::move(first), std::move(last), std::move(compare), category{});
//}

}//namespace

#undef VERGESORT_PREFER_MOVE

#endif // VERGESORT_VERGESORT_H_




















~-----------------------------------------------~
C:\Users\Josh\Documents\Visual Studio 2017\Projects\Sorting\Sorting\visualizer.h
~-----------------------------------------------~
#pragma once

#define NOMINMAX

#include <Windows.h>
#include <functional>
#include <string>
#include <vector>
#include <map>
#include <set>

#include "initializer.h"
#include "chart.h"
#include "table.h"
#include "sorting.h"
#include "trace.h"
#include "benchmark.h"
#pragma comment(lib, "winmm.lib")
#include "sounds.h"
#include "customtrackbar.h"

#define VISUALIZERCLASSNAME L"VisualizerControlClassName"

ATOM register_visualizer_control();

typedef TraceVector<TraceInt>::iterator tvit;
typedef std::less<TraceInt>/*TraceLess<TraceInt>*/ tvcmp;

typedef std::vector<unsigned>::iterator vit;
typedef std::less<unsigned> vcmp;

template<typename T, typename C>
struct SortAlg { typedef std::function<void(T, T, C)> Alg; };

typedef void(*TVSortAlgPtr)(tvit, tvit, tvcmp);
typedef void(*VSortAlgPtr)(vit, vit, vcmp);

class SortingAlgorithm {
public:
	SortAlg<tvit, tvcmp>::Alg sort;
	SortAlg<vit, vcmp>::Alg vsort;
	std::wstring name;
	std::wstring best_case, average_case, worst_case, space;	
	bool is_stable;
	std::wstring desc;
	void operator()(tvit _First, tvit _Last, tvcmp compare) {
		sort(_First, _Last, compare);
	}
	void operator()(vit _First, vit _Last, vcmp compare) {
		vsort(_First, _Last, compare);
	}

	SortingAlgorithm() {}

	SortingAlgorithm(SortAlg<tvit, tvcmp>::Alg sort, SortAlg<vit, vcmp>::Alg vsort, std::wstring name,
					 std::wstring best_case, std::wstring average_case, std::wstring worst_case, std::wstring space, bool is_stable,
					 std::wstring desc)
		: sort(sort), vsort(vsort), name(name), 
		best_case(best_case), average_case(average_case), worst_case(worst_case), space(space), is_stable(is_stable),
		desc(desc) { }

	SortingAlgorithm(SortAlg<vit, vcmp>::Alg vsort, std::wstring name) {
		this->vsort = vsort;
		this->name = name;
	}
};

extern std::map<std::wstring, SortingAlgorithm> SortingAlgorithms;

enum class SortState {
	Unknown, Unsorted, Sorted, Inorder, Sorting
};

enum VisualizationType {
	BarGraph,
	FullBarGraph,
	ScatterPlot,
	HorizontalPyramid,
	ColorWheel,
	DisparityDots,
	Squares,
};
STRINGIFY_ENUM_DEC(VisualizationType)

enum ColorMode {
	Rainbow,
	RainbowHSV,
	BlackAndWhite,
	RedWhiteBlue, 
	Gradient,
	HeatMap,
	Exploding,
	Heap
};
STRINGIFY_ENUM_DEC(ColorMode)

enum DrawOption {
	None = 0, 
	Accesses = 1 << 0,
	Comparisons = 1 << 1,
	Assignments = 1 << 2,
	PreSwaps = 1 << 3,
	PostSwaps = 1 << 4
}; 
STRINGIFY_ENUM_DEC(DrawOption)

STRINGIFY_ENUM_DEC(InitTypeValue)
STRINGIFY_ENUM_DEC(InitTypeOrder)

template<class T>
struct Range;

class Visualizer {
public:
	enum class DrawEventType {
		NoDraw, Redraw, DrawSkipped, Access, Comparison, Assignment, Swap
	};

	enum class ScreenMode {
		SortVisualizer, Chart
	};
	
	bool isDrawEventOn(DrawEventType det) {
		switch (det) {
			case DrawEventType::Assignment: return options.draw_options & DrawOption::Assignments;
			case DrawEventType::Access: return options.draw_options & DrawOption::Accesses;
			case DrawEventType::Comparison: return options.draw_options & DrawOption::Comparisons;
			case DrawEventType::Swap: return options.draw_options & DrawOption::PostSwaps || options.draw_options & DrawOption::PreSwaps;
			default: return false;
		}
	}
	static bool isDrawEventSingle(DrawEventType det) { return (det == DrawEventType::Assignment || det == DrawEventType::Access || det == DrawEventType::Swap || det == DrawEventType::Comparison); }
	static bool isDrawEventChange(DrawEventType det) { return (det == DrawEventType::Assignment || det == DrawEventType::Swap); }
	static bool isDrawEventDouble(DrawEventType det) { return (det == DrawEventType::Swap || det == DrawEventType::Comparison); }

	struct DrawEventInfo {
		unsigned ptr1, ptr2;
		DrawEventType draw_event_type;

		/*bool operator==(const DrawEventInfo& rhs) {
			if (rhs.draw_event_type == DrawEventType::Redraw || draw_event_type == DrawEventType::Redraw) return true;
			return ptr1 == rhs.ptr1 && ptr2 == rhs.ptr2;
		}*/
	};

	static MIDISoundPlayer midi_sound_player;

	Visualizer(HWND parent, HINSTANCE hinst, HMENU id, unsigned size, VisualizationType visualization_type, ColorMode color_mode, InitTypeValue init_type_value, InitTypeOrder init_type_order, DrawOption draw_options, const SortingAlgorithm& sort);

	HWND GetHWND() { return hwnd; }

	static Visualizer* getVisualizer(HWND hwnd);

	void SetSort(const SortingAlgorithm& sort);

	std::wstring GetSortName() { return sort.name; }

	static std::wstring GetSortNameKey(std::wstring sort_name) { for (auto a : SortingAlgorithms) if (a.second.name == sort_name) return a.first; return L"NOT FOUND"; }

	std::wstring GetSortNameKey() { return GetSortNameKey(sort.name); }

	unsigned GetSize() { return options.size; }

	void SetSize(unsigned size) { options.size = size; Resize(); }

	VisualizationType GetVisualizationType() { return options.visualization_type; }

	ColorMode GetColorMode() { return options.color_mode; }

	InitTypeValue GetInitTypeValue() { return options.init_type_value; }

	InitTypeOrder GetInitTypeOrder() { return options.init_type_order; }

	DrawOption GetDrawOptions() { return options.draw_options; }

	double GetRuntime() { return timer.getElapsedMS(); }

	void RunSort();

	void DrawScreen();

	double GetDrawSpeed();

	void SetDrawSpeed(double new_speed);

	std::vector<unsigned>* GetInitializedList();

	static void AddSelectionHWND(HWND hwnd) { Options::hwnds_MultiSelected.insert(hwnd); getVisualizer(hwnd)->DrawScreen(); }

	class Options {
	public:
		Options();

		std::wstring GetInitTypeValueName();
		std::wstring GetInitTypeOrderName();
		void SetInitType(InitTypeValue init_type_value, InitTypeOrder init_type_order);
		void SetInitType(InitTypeValue init_type_value) { SetInitType(init_type_value, (InitTypeOrder)this->init_type_order); }
		void SetInitType(InitTypeOrder init_type_order) { SetInitType((InitTypeValue)this->init_type_value, init_type_order); }

		void SetDrawOptions(DrawOption draw_option);

		double GetDefaultDrawSpeed() { return default_draw_speed; }
		double GetClickedDrawSpeed() { return clicked_draw_speed; }

		void SetSleepTime(int time) { sleep_time = time; }

		static void InitOptions(Visualizer* vis);

		static HWND GetHWND() { return hwnd; }
		static void ClearHWND() { DestroyWindow(hwnd); hwnd = NULL; }

	private:
		static bool is_initializing;
		static HWND hwnd;
		static std::set<HWND> hwnds_MultiSelected;
		static HWND hwnd_SortingAlgorithm;
		static HWND hwnd_VisualizationType;
		static HWND hwnd_ColorMode;
		static HWND hwnd_Instrument;
		static std::map<UINT, HWND> hwnd_DrawOptions;//map control id to control hwnd
		static std::map<UINT, DrawOption> id_DrawOptions;//map control id to drawoption enum val
		static HWND hwnd_InitTypeValues;//map control id to control hwnd
		static std::map<UINT, InitTypeValue>id_InitTypeValue;//map control id to InitTypeValue enum val
		static HWND hwnd_InitTypeOrdering;//map control id to control hwnd
		static std::map<UINT, InitTypeOrder>id_InitTypeOrder;//map control id to InitTypeOrder enum val
		static HWND hwnd_Size;
		static HWND hwnd_FastDraw;
		static HWND hwnd_DrawSpeed;
		static HWND hwnd_SleepTime;
		static HWND hwnd_Complexity;
		static HWND hwnd_Counts;
		static HWND hwnd_Runtime;
		static HWND hwnd_Sound;
		static HWND hwnd_NoteMinFrequency;
		static HWND hwnd_NoteMaxFrequency;
		static HWND hwnd_NoteOnVelocity;
		static HWND hwnd_NoteOffVelocity;
		static HWND hwnd_NoteDuration;
		static CustomTrackbar ctb_Volume;

		static BOOL CALLBACK Proc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam);
		
		unsigned size;
		VisualizationType visualization_type;
		ColorMode color_mode;
		InitTypeValue init_type_value;
		InitTypeOrder init_type_order;
		DrawOption draw_options;
		int sleep_time = 0;
		BYTE show_complexity = BST_INDETERMINATE;
		BYTE show_counts = BST_INDETERMINATE;
		BYTE show_runtime = BST_INDETERMINATE;
		bool bBenchmark = true;
		bool bdraw_initialization = true;

		std::vector<size_t> access_ages;

		bool bfast_draw = true;
		double draw_speed_factor = 10.0;
		double default_draw_speed = draw_speed_factor;
		double clicked_draw_speed = 100.0;

		static bool sound_on;
		static unsigned char note_min_frequency;
		static unsigned char note_max_frequency;
		static unsigned char note_on_velocity;
		static unsigned char note_off_velocity;
		static int note_duration;

		friend class Visualizer;
		friend class TraceInt;
		template <class T, class A = std::allocator<T>> friend class TraceVector;
		friend void swap(TraceInt& lhs, TraceInt& rhs);
		friend void iter_swap(const TraceVector<TraceInt>::iterator& _Left, const TraceVector<TraceInt>::iterator& _Right);
	};

	Options options;

	class SortRunData {
	public:
		enum class ColumnId {
			name, num_elements, runtime, compares, assigns, swaps, accesses, values, ordering
		};

		SortRunData() {}

		SortRunData(std::wstring name, unsigned num_elements, double runtime, 
					unsigned compares, unsigned assigns, unsigned swaps, unsigned accesses, 
					std::wstring init_values, std::wstring init_ordering) :
			name(name), num_elements(num_elements), runtime(runtime),
			compares(compares), assigns(assigns), swaps(swaps), accesses(accesses),
			init_values(init_values), init_ordering(init_ordering) {}

		SortRunData(std::wstring name, unsigned num_elements, double runtime) :
			name(name), num_elements(num_elements), runtime(runtime),
			compares(0), assigns(0), swaps(0), accesses(0),
			init_values(L"NULL"), init_ordering(L"NULL") {}

		void SetData(Visualizer* vis) {
			SetData(vis->GetSortName(), vis->options.size, vis->GetRuntime(),
				vis->tv.compare_count, vis->tv.assignment_count, vis->tv.swap_count, vis->tv.access_count,
				vis->options.GetInitTypeValueName(), vis->options.GetInitTypeOrderName());
		}

		void SetData(std::wstring name, unsigned num_elements, double runtime,
					 unsigned compares, unsigned assigns, unsigned swaps, unsigned accesses,
					 std::wstring init_values, std::wstring init_ordering) {
			this->name = name;	this->num_elements = num_elements; this->runtime = runtime;
			this->compares = compares; this->assigns = assigns;	this->swaps = swaps; this->accesses = accesses;
			this->init_values = init_values; this->init_ordering = init_ordering;
		}

		static std::wstring GetColumnName(ColumnId col_id) {
			return ColumnNames[col_id];
		}

		static int GetColumnCount() { return ColumnNames.size(); }

		static bool CompareByColumn(const SortRunData& a, const SortRunData& b, ColumnId col_id, bool is_ascending) {
			switch (col_id) {
				case ColumnId::name: { return is_ascending ? a.name < b.name : b.name < a.name; }
				case ColumnId::num_elements: { return is_ascending ? a.num_elements < b.num_elements : b.num_elements < a.num_elements; }
				case ColumnId::runtime: { return is_ascending ? a.runtime < b.runtime : b.runtime < a.runtime; }
				case ColumnId::compares: { return is_ascending ? a.compares < b.compares : b.compares < a.compares; }
				case ColumnId::assigns: { return is_ascending ? a.assigns < b.assigns : b.assigns < a.assigns; }
				case ColumnId::swaps: { return is_ascending ? a.swaps < b.swaps : b.swaps < a.swaps; }
				case ColumnId::accesses: { return is_ascending ? a.accesses < b.accesses : b.accesses < a.accesses; }
				case ColumnId::values: { return is_ascending ? a.init_values < b.init_values : b.init_values < a.init_values; }
				case ColumnId::ordering: { return is_ascending ? a.init_ordering < b.init_ordering : b.init_ordering < a.init_ordering; }
				default: throw(std::exception("Invalid column id"));
			}
		}

		static void PrintColumnNames() {
			for (int i = 0; i < ColumnNames.size(); i++) {
				std::wcout << ColumnNames[ColumnId(i)] << '\t';
			}
		}

		static void Print(const SortRunData& row) {
			std::wcout << row.name << '\t' << row.num_elements << '\t' << row.runtime << '\t' 
				<< row.compares << '\t' << row.assigns << '\t' << row.swaps << '\t' << row.accesses << '\t' 
				<< row.init_values << '\t' << row.init_ordering << '\n';
		}

		static std::wstring GetColumnDataAsString(const SortRunData& row, ColumnId col_id) {
			switch (col_id) {
				case ColumnId::name: { return row.name; }
				case ColumnId::num_elements: { return std::to_wstring(row.num_elements); }
				case ColumnId::runtime: { return std::to_wstring(row.runtime); }
				case ColumnId::compares: { return std::to_wstring(row.compares); }
				case ColumnId::assigns: { return std::to_wstring(row.assigns); }
				case ColumnId::swaps: { return std::to_wstring(row.swaps); }
				case ColumnId::accesses: { return std::to_wstring(row.accesses); }
				case ColumnId::values: { return row.init_values; }
				case ColumnId::ordering: { return row.init_ordering; }
			}
			return L"";
		}

		std::wstring GetColumnDataAsString(ColumnId col_id) {
			return GetColumnDataAsString(*this, col_id);
		}

		void Print() {
			Print(*this);
		}

		static BOOL CALLBACK Proc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam);

	private:
		std::wstring name;
		unsigned num_elements;
		double runtime;
		unsigned compares, assigns, swaps, accesses;
		std::wstring init_values, init_ordering;

		static std::map<ColumnId, std::wstring> ColumnNames;

		friend class Table<SortRunData>;

		static void RowAddedProc(const SortRunData& row);

		static void SortByColumnProc(ColumnId col_id, bool is_ascending = true);
	};
	static Table<SortRunData> SortTable;

private:	
	HWND hwnd;
	HMENU id;
	HINSTANCE hinst;
	RECT rcclient;

	static HWND hwnd_Table;
	static HWND hwnd_LVSortTable;

	bool is_initializing = false;
	Benchmark timer;

	SortState tv_state = SortState::Unknown;

	TraceVector<TraceInt> tv;
	std::vector<unsigned> v;

	SortingAlgorithm sort;

	void init();

	void test_sort();

	ScreenMode active_screen_mode;

	class Screen {
	public:
		template <class T>
		class ReadOnly {
			friend class Screen;
		private:
			T data;
			T operator=(const T& arg) { data = arg; return data; }
		public:
			operator const T&() const { return data; }
			/*operator T() const { return data; }
			operator T() { return data; }*/
		};

		ReadOnly<unsigned> w;
		ReadOnly<unsigned> h;
		ReadOnly<unsigned> stride;
		ReadOnly<COLORREF> back_color;
		ReadOnly<unsigned> bmp_size;

		~Screen() {
			FreeData();
		}

		void Resize(unsigned w, unsigned h) {
			ScopedVar<bool> scoped_is_resizing(is_resizing, true);
			FreeData();
			this->w = w, this->h = h;
			stride = w * 4;
			bmp_size = (h + 3) * (stride + 8);
			data = new BYTE[bmp_size];
		}

		void SetData(unsigned index, BYTE value) {
			if (is_resizing) return;
			data[index] = value;
		}

		BYTE* GetData() const { return data; }

		void FreeData() {
			if (data) {
				delete[] data;
				data = 0;
			}
		}

		bool IsResizing() { return is_resizing; }

	private:
		BYTE* data = NULL;
		bool is_resizing = false;
	};
	Screen screen;

	bool mouse_in_client = false;

	unsigned num_draw_skips;
	unsigned num_skipped = 0;
	std::vector<DrawEventInfo> skipped_draws;
	DrawEventInfo last_draw = {0, 0, DrawEventType::NoDraw};
	DrawEventInfo last_draw_value = {0, 0, DrawEventType::NoDraw};
	void reset_last_draw();

	static LRESULT CALLBACK Proc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);

	void Draw(const DrawEventInfo& draw_event_info);

	void Draw(unsigned ptr1, DrawEventType draw_event_type) { Draw({ ptr1, 0, draw_event_type }); }

	void Draw(unsigned ptr1, unsigned ptr2, DrawEventType draw_event_type) { Draw({ ptr1, ptr2, draw_event_type }); }

	COLORREF GetColor(const std::vector<TraceInt>* arr, unsigned i, const DrawEventInfo* draw_event_info, void* param = nullptr);

	void FillBackground();

	bool isCursorInClient();

	void Resize();

	static void Play(unsigned v, const Range<unsigned>& range);
	static void Play(std::vector<unsigned>& values, const Range<unsigned>& range);

	static void DrawScreenText(Visualizer* vis, HWND hwnd, HDC hDCmem);
	static void DrawScreen(Visualizer* vis, DrawEventInfo* draw_event_info);

	static void DrawBarGraph(Visualizer* vis, HWND hwnd, HDC hdc, DrawEventInfo* draw_event_info);
	static void DrawScatterPlot(Visualizer* vis, HWND hwnd, HDC hdc, DrawEventInfo* draw_event_info);
	static void DrawColorWheel(Visualizer* vis, HWND hwnd, HDC hdc, DrawEventInfo* draw_event_info);
	static void DrawDisparityDots(Visualizer* vis, HWND hwnd, HDC hdc, DrawEventInfo* draw_event_info);
	static void DrawSquares(Visualizer* vis, HWND hwnd, HDC hdc, DrawEventInfo* draw_event_info);

	friend class TraceInt;
	template <class T, class A = std::allocator<T>> friend class TraceVector;
	friend void swap(TraceInt& lhs, TraceInt& rhs);
	friend void iter_swap(const TraceVector<TraceInt>::iterator& _Left, const TraceVector<TraceInt>::iterator& _Right);
	friend ATOM register_visualizer_control();
};

struct SortRunLVCompareProcInfo {
	Visualizer::SortRunData::ColumnId col_id;
	bool is_ascending;
};

int CALLBACK SortRunLVCompareProc(LPARAM lParam1, LPARAM lParam2, LPARAM lParamSort);

//template<typename T>
//class ConsoleVisualizer {
//	public:
//
//	static int sleep_time;
//	static short line_pos;
//
//	static int Write(std::wstring screen) {
//		DWORD dwBytesWritten = 0;
//		WriteConsoleOutputCharacter(ConH, screen.c_str(), screen.length(), {0, line_pos}, &dwBytesWritten);
//		if (sleep_time)
//			this_thread::sleep_for(chrono::milliseconds(sleep_time));
//		return dwBytesWritten;
//	}
//
//	static int WriteVec(const std::vector<T>& arr, int ptr = -1) {
//		std::vector<std::wstring> screenbuffer(25, std::wstring(120, ' '));
//		for (int i = 0; i < arr.size(); i++) {
//			for (int j = 0; j < arr[i]; j++) {
//				screenbuffer[j][i] = i == ptr ? '@' : '#';
//			}
//		}
//
//		std::wstring screen = L"";
//		for (int i = 0; i < screenbuffer.size(); i++) {
//			screen += screenbuffer[i];
//		}
//
//		return Write(screen);
//	}
//	private:
//	static HANDLE ConH;
//};
//
//template<typename T> HANDLE ConsoleVisualizer<T>::ConH = GetStdHandle(STD_OUTPUT_HANDLE);
//template<typename T> int ConsoleVisualizer<T>::sleep_time = 0;
//template<typename T> short ConsoleVisualizer<T>::line_pos = 0;
//
//template <typename T>
//std::wostream& operator<<(std::wostream& os, const std::vector<T>& ti) {
//	static std::vector<std::wstring> screen(25, std::wstring(120, ' '));
//
//	for (int i = 0; i < ti.size(); i++) {
//		for (int j = 0; j < ti[i].value; j++) {
//			screen[j][i] = '#';
//		}
//	}
//	for (int i = 0; i < screen.size(); i++) {
//		os << screen[i] << '\n';
//	}
//
//	return os;
//}


























~-----------------------------------------------~
C:\Users\Josh\Documents\Visual Studio 2017\Projects\Sorting\Sorting\weakheapsort.h
~-----------------------------------------------~
#pragma once

#include <vector>

#define GETFLAG(r, x) ((r[(x) >> 3] >> ((x) & 7)) & 1)
#define TOGGLEFLAG(r, x) (r[(x) >> 3] ^= 1 << ((x) & 7))

template<class T, class C>
inline void weakheapmerge(T _First, unsigned char *r, int i, int j, C compare) {
	if (compare(*(_First + i), *(_First + j))) {
		TOGGLEFLAG(r, j);
		iter_swap((_First + i), (_First + j));
	}
}

template<class T, class C>
void weakheapsort_(T _First, unsigned n, C compare) {
	using std::swap;
	if (n > 1) {
		unsigned i;
		int j, x, y, Gparent;
		int s = (n + 7) / 8;
		unsigned char * r = new unsigned char[s];
		for (i = 0; i < n / 8; ++i)
			r[i] = 0;
		for (i = n - 1; i > 0; --i) {
			j = i;
			while ((j & 1) == GETFLAG(r, j >> 1))
				j >>= 1;
			Gparent = j >> 1;
			weakheapmerge(_First, r, Gparent, i, compare);
		}
		for (i = n - 1; i >= 2; --i) {
			iter_swap(_First, (_First + i));
			x = 1;
			while ((unsigned)(y = 2 * x + GETFLAG(r, x)) < i)
				x = y;
			while (x > 0) {
				weakheapmerge(_First, r, 0, x, compare);
				x >>= 1;
			}
		}
		iter_swap(_First, (_First + 1));
		delete[] r;
	}
}

#undef GETFLAG
#undef TOGGLEFLAG

template<class T, class C>
inline void weakheapsort(T _First, T _Last, C compare) {
	weakheapsort_(_First, std::distance(_First, _Last), compare);
}

template<class T>
inline void weakheapsort(T _First, T _Last) {
	weakheapsort_(_First, std::distance(_First, _Last), std::less<>());
}


























~-----------------------------------------------~
C:\Users\Josh\Documents\Visual Studio 2017\Projects\Sorting\Sorting\wikisort.h
~-----------------------------------------------~
#pragma once

#define NOMINMAX
#undef min
#undef max

/***********************************************************
 WikiSort: a public domain implementation of "Block Sort"
 https://github.com/BonzaiThePenguin/WikiSort

 to run:
 clang++ -o WikiSort.x WikiSort.cpp -O3
 (or replace 'clang++' with 'g++')
 ./WikiSort.x
***********************************************************/

#include <algorithm>
#include <cassert>
#include <cmath>
#include <ctime>
#include <iostream>
#include <iterator>
#include <limits>
#include <vector>

namespace {
	// structure to represent ranges within the array
	template <typename Iterator>
	struct Range {
		Iterator start;
		Iterator end;

		Range() {}

		Range(Iterator start, Iterator end) :
			start(start),
			end(end)
		{}

		std::size_t length() const {
			return std::distance(start, end);
		}
	};

	// toolbox functions used by the sorter

	// 63 -> 32, 64 -> 64, etc.
	// this comes from Hacker's Delight
	template <typename Unsigned>
	Unsigned Hyperfloor(Unsigned value) {
		for (std::size_t i = 1; i <= std::numeric_limits<Unsigned>::digits / 2; i <<= 1) {
			value |= (value >> i);
		}
		return value - (value >> 1);
	}

	// combine a linear search with a binary search to reduce the number of comparisons in situations
	// where have some idea as to how many unique values there are and where the next value might be
	template <typename RandomAccessIterator, typename T, typename Comparison>
	RandomAccessIterator FindFirstForward(RandomAccessIterator first, RandomAccessIterator last,
		const T & value, Comparison compare, std::size_t unique) {
		std::size_t size = std::distance(first, last);
		if (size == 0) return first;

		std::size_t skip = std::max(size / unique, (std::size_t)1);

		RandomAccessIterator index;
		for (index = first + skip; compare(*(index - 1), value); index += skip) {
			if (index >= last - skip) {
				return std::lower_bound(index, last, value, compare);
			}
		}
		return std::lower_bound(index - skip, index, value, compare);
	}

	template <typename RandomAccessIterator, typename T, typename Comparison>
	RandomAccessIterator FindLastForward(RandomAccessIterator first, RandomAccessIterator last,
		const T & value, Comparison compare, std::size_t unique) {
		std::size_t size = std::distance(first, last);
		if (size == 0) return first;

		std::size_t skip = std::max(size / unique, (std::size_t)1);

		RandomAccessIterator index;
		for (index = first + skip; !compare(value, *(index - 1)); index += skip) {
			if (index >= last - skip) {
				return std::upper_bound(index, last, value, compare);
			}
		}
		return std::upper_bound(index - skip, index, value, compare);
	}

	template <typename RandomAccessIterator, typename T, typename Comparison>
	RandomAccessIterator FindFirstBackward(RandomAccessIterator first, RandomAccessIterator last,
		const T & value, Comparison compare, std::size_t unique) {
		std::size_t size = std::distance(first, last);
		if (size == 0) return first;

		std::size_t skip = std::max(size / unique, (std::size_t)1);

		RandomAccessIterator index;
		for (index = last - skip; index > first && !compare(*(index - 1), value); index -= skip) {
			if (index < first + skip) {
				return std::lower_bound(first, index, value, compare);
			}
		}
		return std::lower_bound(index, index + skip, value, compare);
	}

	template <typename RandomAccessIterator, typename T, typename Comparison>
	RandomAccessIterator FindLastBackward(RandomAccessIterator first, RandomAccessIterator last,
		const T & value, Comparison compare, std::size_t unique) {
		std::size_t size = std::distance(first, last);
		if (size == 0) return first;

		std::size_t skip = std::max(size / unique, (std::size_t)1);

		RandomAccessIterator index;
		for (index = last - skip; index > first && compare(value, *(index - 1)); index -= skip) {
			if (index < first + skip) {
				return std::upper_bound(first, index, value, compare);
			}
		}
		return std::upper_bound(index, index + skip, value, compare);
	}

	template <typename BidirectionalIterator, typename Comparison>
	void InsertionSort(BidirectionalIterator first, BidirectionalIterator last, Comparison compare) {
		typedef typename std::iterator_traits<BidirectionalIterator>::value_type T;
		if (first == last) return;

		for (BidirectionalIterator cur = first + 1; cur != last; ++cur) {
			BidirectionalIterator sift = cur;
			BidirectionalIterator sift_1 = cur - 1;

			// Compare first so we can avoid 2 moves for
			// an element already positioned correctly.
			if (compare(*sift, *sift_1)) {
				T tmp = *sift;
				do {
					*sift-- = *sift_1;
				} while (sift != first && compare(tmp, *--sift_1));
				*sift = tmp;
			}
		}
	}



	// merge operation using an external buffer
	template <typename RandomAccessIterator1, typename RandomAccessIterator2, typename Comparison>
	void MergeExternal(RandomAccessIterator1 first1, RandomAccessIterator1 last1,
		RandomAccessIterator1 first2, RandomAccessIterator1 last2,
		RandomAccessIterator2 cache, Comparison compare) {
		// A fits into the cache, so use that instead of the internal buffer
		RandomAccessIterator2 A_index = cache;
		RandomAccessIterator2 A_last = cache + std::distance(first1, last1);
		RandomAccessIterator1 B_index = first2;
		RandomAccessIterator1 B_last = last2;
		RandomAccessIterator1 insert_index = first1;

		if (last2 - first2 > 0 && last1 - first1 > 0) {
			while (true) {
				if (!compare(*B_index, *A_index)) {
					*insert_index = *A_index;
					++A_index;
					++insert_index;
					if (A_index == A_last) break;
				}
				else {
					*insert_index = *B_index;
					++B_index;
					++insert_index;
					if (B_index == B_last) break;
				}
			}
		}

		// copy the remainder of A into the final array
		std::copy(A_index, A_last, insert_index);
	}

	// merge operation using an internal buffer
	template<typename RandomAccessIterator, typename Comparison>
	void MergeInternal(RandomAccessIterator first1, RandomAccessIterator last1,
		RandomAccessIterator first2, RandomAccessIterator last2,
		RandomAccessIterator buffer, Comparison compare) {
		// whenever we find a value to add to the final array, swap it with the value that's already in that spot
		// when this algorithm is finished, 'buffer' will contain its original contents, but in a different order
		RandomAccessIterator A_index = buffer;
		RandomAccessIterator B_index = first2;
		RandomAccessIterator A_last = buffer + std::distance(first1, last1);
		RandomAccessIterator B_last = last2;
		RandomAccessIterator insert_index = first1;

		if (last2 - first2 > 0 && last1 - first1 > 0) {
			while (true) {
				if (!compare(*B_index, *A_index)) {
					iter_swap(insert_index, A_index);
					++A_index;
					++insert_index;
					if (A_index == A_last) break;
				}
				else {
					iter_swap(insert_index, B_index);
					++B_index;
					++insert_index;
					if (B_index == B_last) break;
				}
			}
		}

		// BlockSwap
		std::swap_ranges(A_index, A_last, insert_index);
	}

	// merge operation without a buffer
	template <typename RandomAccessIterator, typename Comparison>
	void MergeInPlace(RandomAccessIterator first1, RandomAccessIterator last1,
		RandomAccessIterator first2, RandomAccessIterator last2,
		Comparison compare) {
		if (last1 - first1 == 0 || last2 - first2 == 0) return;

		/*
		 this just repeatedly binary searches into B and rotates A into position.
		 the paper suggests using the 'rotation-based Hwang and Lin algorithm' here,
		 but I decided to stick with this because it had better situational performance

		 (Hwang and Lin is designed for merging subarrays of very different sizes,
		 but WikiSort almost always uses subarrays that are roughly the same size)

		 normally this is incredibly suboptimal, but this function is only called
		 when none of the A or B blocks in any subarray contained 2vA unique values,
		 which places a hard limit on the number of times this will ACTUALLY need
		 to binary search and rotate.

		 according to my analysis the worst case is vA rotations performed on vA items
		 once the constant factors are removed, which ends up being O(n)

		 again, this is NOT a general-purpose solution  it only works well in this case!
		 kind of like how the O(n^2) insertion sort is used in some places
		 */

		while (true) {
			// find the first place in B where the first item in A needs to be inserted
			RandomAccessIterator mid = std::lower_bound(first2, last2, *first1, compare);

			// rotate A into place
			std::size_t amount = mid - last1;
			std::rotate(first1, last1, mid);
			if (last2 == mid) break;

			// calculate the new A and B ranges
			first2 = mid;
			first1 += amount;
			last1 = first2;
			first1 = std::upper_bound(first1, last1, *first1, compare);
			if (std::distance(first1, last1) == 0) break;
		}
	}

	// calculate how to scale the index value to the range within the array
	// the bottom-up merge sort only operates on values that are powers of two,
	// so scale down to that power of two, then use a fraction to scale back again
	class Iterator {
		std::size_t size, power_of_two;
		std::size_t decimal, numerator, denominator;
		std::size_t decimal_step, numerator_step;

	public:

		Iterator(std::size_t size, std::size_t min_level) :
			size(size),
			power_of_two(Hyperfloor(size)),
			decimal(0),
			numerator(0),
			denominator(power_of_two / min_level),
			decimal_step(size / denominator),
			numerator_step(size % denominator)
		{}

		void begin() {
			numerator = decimal = 0;
		}

		template <typename Iterator>
		Range<Iterator> nextRange(Iterator it) {
			std::size_t start = decimal;

			decimal += decimal_step;
			numerator += numerator_step;
			if (numerator >= denominator) {
				numerator -= denominator;
				++decimal;
			}

			return Range<Iterator>(it + start, it + decimal);
		}

		bool finished() const {
			return decimal >= size;
		}

		bool nextLevel() {
			decimal_step += decimal_step;
			numerator_step += numerator_step;
			if (numerator_step >= denominator) {
				numerator_step -= denominator;
				++decimal_step;
			}

			return decimal_step < size;
		}

		std::size_t length() const {
			return decimal_step;
		}
	};

	// use a class so the memory for the cache is freed when the object goes out of scope,
	// regardless of whether exceptions were thrown (only needed in the C++ version)
	template <typename T>
	class Cache {
	public:
		T *cache;
		std::size_t cache_size;

		~Cache() {
			if (cache) delete[] cache;
		}

		Cache(std::size_t size) {
			cache_size = size;
			if (size) 			
				cache = new (std::nothrow) T[cache_size];			
		}
	};

	// bottom-up merge sort combined with an in-place merge algorithm for O(1) memory use
	template <typename RandomAccessIterator, typename Comparison>
	void wikisort(RandomAccessIterator first, RandomAccessIterator last, typename std::iterator_traits<RandomAccessIterator>::value_type* cache, const std::size_t cache_size, Comparison compare) {
		// map first and last to a C-style array, so we don't have to change the rest of the code
		// (bit of a nasty hack, but it's good enough for now...)
		typedef typename std::iterator_traits<RandomAccessIterator>::value_type T;
		const std::size_t size = std::distance(first, last);

		// if the array is of size 0, 1, 2, or 3, just sort them like so:
		if (size < 4) {
			if (size == 3) {
				// hard-coded insertion sort
				if (compare(first[1], first[0])) {
					iter_swap(first + 0, first + 1);
				}
				if (compare(first[2], first[1])) {
					iter_swap(first + 1, first + 2);
					if (compare(first[1], first[0])) {
						iter_swap(first + 0, first + 1);
					}
				}
			}
			else if (size == 2) {
				// swap the items if they're out of order
				if (compare(first[1], first[0])) {
					iter_swap(first + 0, first + 1);
				}
			}

			return;
		}

		// sort groups of 4-8 items at a time using an unstable sorting network,
		// but keep track of the original item orders to force it to be stable
		// http://pages.ripco.net/~jgamble/nw.html
		Iterator iterator(size, 4);
		while (!iterator.finished()) {
			int order[] = { 0, 1, 2, 3, 4, 5, 6, 7 };
			Range<RandomAccessIterator> range = iterator.nextRange(first);

#define SWAP(x, y) \
                if (compare(range.start[y], range.start[x]) || \
                    (order[x] > order[y] && !compare(range.start[x], range.start[y]))) { \
                    iter_swap(range.start + x, range.start + y); \
                    std::iter_swap(order + x, order + y); }

			if (range.length() == 8) {
				SWAP(0, 1); SWAP(2, 3); SWAP(4, 5); SWAP(6, 7);
				SWAP(0, 2); SWAP(1, 3); SWAP(4, 6); SWAP(5, 7);
				SWAP(1, 2); SWAP(5, 6); SWAP(0, 4); SWAP(3, 7);
				SWAP(1, 5); SWAP(2, 6);
				SWAP(1, 4); SWAP(3, 6);
				SWAP(2, 4); SWAP(3, 5);
				SWAP(3, 4);

			}
			else if (range.length() == 7) {
				SWAP(1, 2); SWAP(3, 4); SWAP(5, 6);
				SWAP(0, 2); SWAP(3, 5); SWAP(4, 6);
				SWAP(0, 1); SWAP(4, 5); SWAP(2, 6);
				SWAP(0, 4); SWAP(1, 5);
				SWAP(0, 3); SWAP(2, 5);
				SWAP(1, 3); SWAP(2, 4);
				SWAP(2, 3);

			}
			else if (range.length() == 6) {
				SWAP(1, 2); SWAP(4, 5);
				SWAP(0, 2); SWAP(3, 5);
				SWAP(0, 1); SWAP(3, 4); SWAP(2, 5);
				SWAP(0, 3); SWAP(1, 4);
				SWAP(2, 4); SWAP(1, 3);
				SWAP(2, 3);

			}
			else if (range.length() == 5) {
				SWAP(0, 1); SWAP(3, 4);
				SWAP(2, 4);
				SWAP(2, 3); SWAP(1, 4);
				SWAP(0, 3);
				SWAP(0, 2); SWAP(1, 3);
				SWAP(1, 2);

			}
			else if (range.length() == 4) {
				SWAP(0, 1); SWAP(2, 3);
				SWAP(0, 2); SWAP(1, 3);
				SWAP(1, 2);
			}

#undef SWAP
		}
		if (size < 8) return;
		
		// then merge sort the higher levels, which can be 8-15, 16-31, 32-63, 64-127, etc.
		while (true) {
			// if every A and B block will fit into the cache, use a special branch specifically for merging with the cache
			// (we use < rather than <= since the block size might be one more than iterator.length())
			if (iterator.length() < cache_size) {

				// if four subarrays fit into the cache, it's faster to merge both pairs of subarrays into the cache,
				// then merge the two merged subarrays from the cache back into the original array
				if ((iterator.length() + 1) * 4 <= cache_size && iterator.length() * 4 <= size) {
					iterator.begin();
					while (!iterator.finished()) {
						// merge A1 and B1 into the cache
						Range<RandomAccessIterator> A1 = iterator.nextRange(first);
						Range<RandomAccessIterator> B1 = iterator.nextRange(first);
						Range<RandomAccessIterator> A2 = iterator.nextRange(first);
						Range<RandomAccessIterator> B2 = iterator.nextRange(first);

						if (compare(*(B1.end - 1), *A1.start)) {
							// the two ranges are in reverse order, so copy them in reverse order into the cache
							std::copy(A1.start, A1.end, cache + B1.length());
							std::copy(B1.start, B1.end, cache);
						}
						else if (compare(*B1.start, *(A1.end - 1))) {
							// these two ranges weren't already in order, so merge them into the cache
							std::merge(A1.start, A1.end, B1.start, B1.end, cache, compare);
						}
						else {
							// if A1, B1, A2, and B2 are all in order, skip doing anything else
							if (!compare(*B2.start, *(A2.end - 1)) &&
								!compare(*A2.start, *(B1.end - 1))) continue;

							// copy A1 and B1 into the cache in the same order
							std::copy(A1.start, A1.end, cache);
							std::copy(B1.start, B1.end, cache + A1.length());
						}
						A1 = Range<RandomAccessIterator>(A1.start, B1.end);

						// merge A2 and B2 into the cache
						if (compare(*(B2.end - 1), *A2.start)) {
							// the two ranges are in reverse order, so copy them in reverse order into the cache
							std::copy(A2.start, A2.end, cache + A1.length() + B2.length());
							std::copy(B2.start, B2.end, cache + A1.length());
						}
						else if (compare(*B2.start, *(A2.end - 1))) {
							// these two ranges weren't already in order, so merge them into the cache
							std::merge(A2.start, A2.end, B2.start, B2.end, cache + A1.length(), compare);
						}
						else {
							// copy A2 and B2 into the cache in the same order
							std::copy(A2.start, A2.end, cache + A1.length());
							std::copy(B2.start, B2.end, cache + A1.length() + A2.length());
						}
						A2 = Range<RandomAccessIterator>(A2.start, B2.end);

						// merge A1 and A2 from the cache into the array
						Range<T*> A3(cache, cache + A1.length());
						Range<T*> B3(cache + A1.length(), cache + A1.length() + A2.length());

						if (compare(*(B3.end - 1), *A3.start)) {
							// the two ranges are in reverse order, so copy them in reverse order into the array
							std::copy(A3.start, A3.end, A1.start + A2.length());
							std::copy(B3.start, B3.end, A1.start);
						}
						else if (compare(*B3.start, *(A3.end - 1))) {
							// these two ranges weren't already in order, so merge them back into the array
							std::merge(A3.start, A3.end, B3.start, B3.end, A1.start, compare);
						}
						else {
							// copy A3 and B3 into the array in the same order
							std::copy(A3.start, A3.end, A1.start);
							std::copy(B3.start, B3.end, A1.start + A1.length());
						}
					}

					// we merged two levels at the same time, so we're done with this level already
					// (iterator.nextLevel() is called again at the bottom of this outer merge loop)
					iterator.nextLevel();

				}
				else {
					iterator.begin();
					while (!iterator.finished()) {
						Range<RandomAccessIterator> A = iterator.nextRange(first);
						Range<RandomAccessIterator> B = iterator.nextRange(first);

						if (compare(*(B.end - 1), *A.start)) {
							// the two ranges are in reverse order, so a simple rotation should fix it
							std::rotate(A.start, A.end, B.end);
						}
						else if (compare(*B.start, *(A.end - 1))) {
							// these two ranges weren't already in order, so we'll need to merge them!
							std::copy(A.start, A.end, cache);
							MergeExternal(A.start, A.end, B.start, B.end, cache, compare);
						}
					}
				}
			}
			else {
				// this is where the in-place merge logic starts!
				// 1. pull out two internal buffers each containing vA unique values
				//     1a. adjust block_size and buffer_size if we couldn't find enough unique values
				// 2. loop over the A and B subarrays within this level of the merge sort
				//     3. break A and B into blocks of size 'block_size'
				//     4. "tag" each of the A blocks with values from the first internal buffer
				//     5. roll the A blocks through the B blocks and drop/rotate them where they belong
				//     6. merge each A block with any B values that follow, using the cache or the second internal buffer
				// 7. sort the second internal buffer if it exists
				// 8. redistribute the two internal buffers back into the array

				std::size_t block_size = (std::size_t)std::sqrt(iterator.length());
				std::size_t buffer_size = iterator.length() / block_size + 1;

				// as an optimization, we really only need to pull out the internal buffers once for each level of merges
				// after that we can reuse the same buffers over and over, then redistribute it when we're finished with this level
				Range<RandomAccessIterator> buffer1(first, first);
				Range<RandomAccessIterator> buffer2(first, first);
			//	RandomAccessIterator index, last; original code
				RandomAccessIterator index, last;
				std::size_t count, pull_index = 0;
				struct 
				{
					RandomAccessIterator from, to;
					std::size_t count;
					Range<RandomAccessIterator> range;
				} pull[2];
				pull[0].count = 0; pull[0].range = Range<RandomAccessIterator>(first, first);
				pull[1].count = 0; pull[1].range = Range<RandomAccessIterator>(first, first);

				// find two internal buffers of size 'buffer_size' each
				// let's try finding both buffers at the same time from a single A or B subarray
				std::size_t find = buffer_size + buffer_size;
				bool find_separately = false;

				if (block_size <= cache_size) {
					// if every A block fits into the cache then we won't need the second internal buffer,
					// so we really only need to find 'buffer_size' unique values
					find = buffer_size;
				}
				else if (find > iterator.length()) {
					// we can't fit both buffers into the same A or B subarray, so find two buffers separately
					find = buffer_size;
					find_separately = true;
				}

				// we need to find either a single contiguous space containing 2vA unique values (which will be split up into two buffers of size vA each),
				// or we need to find one buffer of < 2vA unique values, and a second buffer of vA unique values,
				// OR if we couldn't find that many unique values, we need the largest possible buffer we can get

				// in the case where it couldn't find a single buffer of at least vA unique values,
				// all of the Merge steps must be replaced by a different merge algorithm (MergeInPlace)

				iterator.begin();
				while (!iterator.finished()) {
					Range<RandomAccessIterator> A = iterator.nextRange(first);
					Range<RandomAccessIterator> B = iterator.nextRange(first);

					// just store information about where the values will be pulled from and to,
					// as well as how many values there are, to create the two internal buffers
#define PULL(_to) \
                        pull[pull_index].range = Range<RandomAccessIterator>(A.start, B.end); \
                        pull[pull_index].count = count; \
                        pull[pull_index].from = index; \
                        pull[pull_index].to = _to

					// check A for the number of unique values we need to fill an internal buffer
					// these values will be pulled out to the start of A
					for (last = A.start, count = 1; count < find; last = index, ++count) {
						index = FindLastForward(last + 1, A.end, *last, compare, find - count);
						if (index == A.end) break;
						assert(index < A.end);
					}
					index = last;

					if (count >= buffer_size) {
						// keep track of the range within the array where we'll need to "pull out" these values to create the internal buffer
						PULL(A.start);
						pull_index = 1;

						if (count == buffer_size + buffer_size) {
							// we were able to find a single contiguous section containing 2vA unique values,
							// so this section can be used to contain both of the internal buffers we'll need
							buffer1 = Range<RandomAccessIterator>(A.start, A.start + buffer_size);
							buffer2 = Range<RandomAccessIterator>(A.start + buffer_size, A.start + count);
							break;
						}
						else if (find == buffer_size + buffer_size) {
							// we found a buffer that contains at least vA unique values, but did not contain the full 2vA unique values,
							// so we still need to find a second separate buffer of at least vA unique values
							buffer1 = Range<RandomAccessIterator>(A.start, A.start + count);
							find = buffer_size;
						}
						else if (block_size <= cache_size) {
							// we found the first and only internal buffer that we need, so we're done!
							buffer1 = Range<RandomAccessIterator>(A.start, A.start + count);
							break;
						}
						else if (find_separately) {
							// found one buffer, but now find the other one
							buffer1 = Range<RandomAccessIterator>(A.start, A.start + count);
							find_separately = false;
						}
						else {
							// we found a second buffer in an 'A' subarray containing vA unique values, so we're done!
							buffer2 = Range<RandomAccessIterator>(A.start, A.start + count);
							break;
						}
					}
					else if (pull_index == 0 && count > buffer1.length()) {
						// keep track of the largest buffer we were able to find
						buffer1 = Range<RandomAccessIterator>(A.start, A.start + count);
						PULL(A.start);
					}

					// check B for the number of unique values we need to fill an internal buffer
					// these values will be pulled out to the end of B
					for (last = B.end - 1, count = 1; count < find; last = index - 1, ++count) {
						index = FindFirstBackward(B.start, last, *last, compare, find - count);
						if (index == B.start) break;
						assert(index > B.start);
					}
					index = last;

					if (count >= buffer_size) {
						// keep track of the range within the array where we'll need to "pull out" these values to create the internal buffer
						PULL(B.end);
						pull_index = 1;

						if (count == buffer_size + buffer_size) {
							// we were able to find a single contiguous section containing 2vA unique values,
							// so this section can be used to contain both of the internal buffers we'll need
							buffer1 = Range<RandomAccessIterator>(B.end - count, B.end - buffer_size);
							buffer2 = Range<RandomAccessIterator>(B.end - buffer_size, B.end);
							break;
						}
						else if (find == buffer_size + buffer_size) {
							// we found a buffer that contains at least vA unique values, but did not contain the full 2vA unique values,
							// so we still need to find a second separate buffer of at least vA unique values
							buffer1 = Range<RandomAccessIterator>(B.end - count, B.end);
							find = buffer_size;
						}
						else if (block_size <= cache_size) {
							// we found the first and only internal buffer that we need, so we're done!
							buffer1 = Range<RandomAccessIterator>(B.end - count, B.end);
							break;
						}
						else if (find_separately) {
							// found one buffer, but now find the other one
							buffer1 = Range<RandomAccessIterator>(B.end - count, B.end);
							find_separately = false;
						}
						else {
							// buffer2 will be pulled out from a 'B' subarray, so if the first buffer was pulled out from the corresponding 'A' subarray,
							// we need to adjust the end point for that A subarray so it knows to stop redistributing its values before reaching buffer2
							if (pull[0].range.start == A.start) {
								pull[0].range.end -= pull[1].count;
							}

							// we found a second buffer in a 'B' subarray containing vA unique values, so we're done!
							buffer2 = Range<RandomAccessIterator>(B.end - count, B.end);
							break;
						}
					}
					else if (pull_index == 0 && count > buffer1.length()) {
						// keep track of the largest buffer we were able to find
						buffer1 = Range<RandomAccessIterator>(B.end - count, B.end);
						PULL(B.end);
					}

#undef PULL
				}

				// pull out the two ranges so we can use them as internal buffers
				for (pull_index = 0; pull_index < 2; ++pull_index) {
					std::size_t length = pull[pull_index].count;

					if (pull[pull_index].to < pull[pull_index].from) {
						// we're pulling the values out to the left, which means the start of an A subarray
						index = pull[pull_index].from;
						for (count = 1; count < length; ++count) {
							index = FindFirstBackward(pull[pull_index].to, pull[pull_index].from - (count - 1),
								*(index - 1), compare, length - count);
							Range<RandomAccessIterator> range(index + 1, pull[pull_index].from + 1);
							std::rotate(range.start, range.end - count, range.end);
							pull[pull_index].from = index + count;
						}
					}
					else if (pull[pull_index].to > pull[pull_index].from) {
						// we're pulling values out to the right, which means the end of a B subarray
						index = pull[pull_index].from + 1;
						for (count = 1; count < length; ++count) {
							index = FindLastForward(index, pull[pull_index].to, *index,
								compare, length - count);
							Range<RandomAccessIterator> range(pull[pull_index].from, index - 1);
							std::rotate(range.start, range.start + count, range.end);
							pull[pull_index].from = index - count - 1;
						}
					}
				}

				// adjust block_size and buffer_size based on the values we were able to pull out
				buffer_size = buffer1.length();
				block_size = iterator.length() / buffer_size + 1;

				// the first buffer NEEDS to be large enough to tag each of the evenly sized A blocks,
				// so this was originally here to test the math for adjusting block_size above
				//assert((iterator.length() + 1)/block_size <= buffer_size);

				// now that the two internal buffers have been created, it's time to merge each A+B combination at this level of the merge sort!
				iterator.begin();
				while (!iterator.finished()) {
					Range<RandomAccessIterator> A = iterator.nextRange(first);
					Range<RandomAccessIterator> B = iterator.nextRange(first);

					// remove any parts of A or B that are being used by the internal buffers
					RandomAccessIterator start = A.start;
					if (start == pull[0].range.start) {
						if (pull[0].from > pull[0].to) {
							A.start += pull[0].count;

							// if the internal buffer takes up the entire A or B subarray, then there's nothing to merge
							// this only happens for very small subarrays, like v4 = 2, 2 * (2 internal buffers) = 4,
							// which also only happens when cache_size is small or 0 since it'd otherwise use MergeExternal
							if (A.length() == 0) continue;
						}
						else if (pull[0].from < pull[0].to) {
							B.end -= pull[0].count;
							if (B.length() == 0) continue;
						}
					}
					if (start == pull[1].range.start) {
						if (pull[1].from > pull[1].to) {
							A.start += pull[1].count;
							if (A.length() == 0) continue;
						}
						else if (pull[1].from < pull[1].to) {
							B.end -= pull[1].count;
							if (B.length() == 0) continue;
						}
					}

					if (compare(*(B.end - 1), *A.start)) {
						// the two ranges are in reverse order, so a simple rotation should fix it
						std::rotate(A.start, A.end, B.end);
					}
					else if (compare(*A.end, *(A.end - 1))) {
						// these two ranges weren't already in order, so we'll need to merge them!

						// break the remainder of A into blocks. firstA is the uneven-sized first A block
						Range<RandomAccessIterator> blockA(A);
						Range<RandomAccessIterator> firstA(A.start, A.start + blockA.length() % block_size);

						// swap the first value of each A block with the values in buffer1
						for (RandomAccessIterator indexA = buffer1.start, index = firstA.end;
							index < blockA.end;
							++indexA, index += block_size) {
							iter_swap(indexA, index);
						}

						// start rolling the A blocks through the B blocks!
						// when we leave an A block behind we'll need to merge the previous A block with any B blocks that follow it, so track that information as well
						Range<RandomAccessIterator> lastA(firstA);
						Range<RandomAccessIterator> lastB(first, first);
						Range<RandomAccessIterator> blockB(B.start, B.start + std::min(block_size, B.length()));
						blockA.start += firstA.length();
						RandomAccessIterator indexA = buffer1.start;

						// if the first unevenly sized A block fits into the cache, copy it there for when we go to Merge it
						// otherwise, if the second buffer is available, block swap the contents into that
						if (lastA.length() <= cache_size) {
							std::copy(lastA.start, lastA.end, cache);
						}
						else if (buffer2.length() > 0) {
							std::swap_ranges(lastA.start, lastA.end, buffer2.start);
						}

						if (blockA.length() > 0) {
							while (true) {
								// if there's a previous B block and the first value of the minimum A block is <= the last value of the previous B block,
								// then drop that minimum A block behind. or if there are no B blocks left then keep dropping the remaining A blocks.
								if ((lastB.length() > 0 && !compare(*(lastB.end - 1), *indexA)) ||
									blockB.length() == 0) {
									// figure out where to split the previous B block, and rotate it at the split
									RandomAccessIterator B_split = std::lower_bound(lastB.start, lastB.end, *indexA, compare);
									std::size_t B_remaining = std::distance(B_split, lastB.end);

									// swap the minimum A block to the beginning of the rolling A blocks
									RandomAccessIterator minA = blockA.start;
									for (RandomAccessIterator findA = minA + block_size; findA < blockA.end; findA += block_size) {
										if (compare(*findA, *minA)) {
											minA = findA;
										}
									}
									std::swap_ranges(blockA.start, blockA.start + block_size, minA);

									// swap the first item of the previous A block back with its original value, which is stored in buffer1
									iter_swap(blockA.start, indexA);
									++indexA;

									// locally merge the previous A block with the B values that follow it
									// if lastA fits into the external cache we'll use that (with MergeExternal),
									// or if the second internal buffer exists we'll use that (with MergeInternal),
									// or failing that we'll use a strictly in-place merge algorithm (MergeInPlace)
									if (lastA.length() <= cache_size) {
										MergeExternal(lastA.start, lastA.end, lastA.end, B_split, cache, compare);
									}
									else if (buffer2.length() > 0) {
										MergeInternal(lastA.start, lastA.end, lastA.end, B_split, buffer2.start, compare);
									}
									else {
										MergeInPlace(lastA.start, lastA.end, lastA.end, B_split, compare);
									}

									if (buffer2.length() > 0 || block_size <= cache_size) {
										// copy the previous A block into the cache or buffer2, since that's where we need it to be when we go to merge it anyway
										if (block_size <= cache_size) {
											std::copy(blockA.start, blockA.start + block_size, cache);
										}
										else {
											std::swap_ranges(blockA.start, blockA.start + block_size, buffer2.start);
										}

										// this is equivalent to rotating, but faster
										// the area normally taken up by the A block is either the contents of buffer2, or data we don't need anymore since we memcopied it
										// either way we don't need to retain the order of those items, so instead of rotating we can just block swap B to where it belongs
										std::swap_ranges(B_split, B_split + B_remaining, blockA.start + block_size - B_remaining);
									}
									else {
										// we are unable to use the 'buffer2' trick to speed up the rotation operation since buffer2 doesn't exist, so perform a normal rotation
										std::rotate(B_split, blockA.start, blockA.start + block_size);
									}

									// update the range for the remaining A blocks, and the range remaining from the B block after it was split
									lastA = Range<RandomAccessIterator>(blockA.start - B_remaining, blockA.start - B_remaining + block_size);
									lastB = Range<RandomAccessIterator>(lastA.end, lastA.end + B_remaining);

									// if there are no more A blocks remaining, this step is finished!
									blockA.start += block_size;
									if (blockA.length() == 0) break;

								}
								else if (blockB.length() < block_size) {
									// move the last B block, which is unevenly sized, to before the remaining A blocks, by using a rotation
									std::rotate(blockA.start, blockB.start, blockB.end);

									lastB = Range<RandomAccessIterator>(blockA.start, blockA.start + blockB.length());
									blockA.start += blockB.length();
									blockA.end += blockB.length();
									blockB.end = blockB.start;
								}
								else {
									// roll the leftmost A block to the end by swapping it with the next B block
									std::swap_ranges(blockA.start, blockA.start + block_size, blockB.start);
									lastB = Range<RandomAccessIterator>(blockA.start, blockA.start + block_size);

									blockA.start += block_size;
									blockA.end += block_size;
									blockB.start += block_size;

									if (blockB.end > B.end - block_size) {
										blockB.end = B.end;
									}
									else {
										blockB.end += block_size;
									}
								}
							}
						}

						// merge the last A block with the remaining B values
						if (lastA.length() <= cache_size) {
							MergeExternal(lastA.start, lastA.end, lastA.end, B.end, cache, compare);
						}
						else if (buffer2.length() > 0) {
							MergeInternal(lastA.start, lastA.end, lastA.end, B.end, buffer2.start, compare);
						}
						else {
							MergeInPlace(lastA.start, lastA.end, lastA.end, B.end, compare);
						}
					}
				}

				// when we're finished with this merge step we should have the one or two internal buffers left over, where the second buffer is all jumbled up
				// insertion sort the second buffer, then redistribute the buffers back into the array using the opposite process used for creating the buffer

				// while an unstable sort like std::sort could be applied here, in benchmarks it was consistently slightly slower than a simple insertion sort,
				// even for tens of millions of items. this may be because insertion sort is quite fast when the data is already somewhat sorted, like it is here
				InsertionSort(buffer2.start, buffer2.end, compare);

				for (pull_index = 0; pull_index < 2; ++pull_index) {
					std::size_t unique = pull[pull_index].count * 2;
					if (pull[pull_index].from > pull[pull_index].to) {
						// the values were pulled out to the left, so redistribute them back to the right
						Range<RandomAccessIterator> buffer(
							pull[pull_index].range.start,
							pull[pull_index].range.start + pull[pull_index].count
						);
						while (buffer.length() > 0) {
							index = FindFirstForward(buffer.end, pull[pull_index].range.end,
								*buffer.start, compare, unique);
							std::size_t amount = index - buffer.end;
							std::rotate(buffer.start, buffer.end, index);
							buffer.start += (amount + 1);
							buffer.end += amount;
							unique -= 2;
						}
					}
					else if (pull[pull_index].from < pull[pull_index].to) {
						// the values were pulled out to the right, so redistribute them back to the left
						Range<RandomAccessIterator> buffer(
							pull[pull_index].range.end - pull[pull_index].count,
							pull[pull_index].range.end
						);
						while (buffer.length() > 0) {
							index = FindLastBackward(pull[pull_index].range.start, buffer.start,
								*(buffer.end - 1), compare, unique);
							std::size_t amount = buffer.start - index;
							std::rotate(index, index + amount, buffer.end);
							buffer.start -= amount;
							buffer.end -= (amount + 1);
							unique -= 2;
						}
					}
				}
			}

			// double the size of each A and B subarray that will be merged in the next level
			if (!iterator.nextLevel()) break;
		}
	}
}

template<class T, class C>
inline void wikisort_nobuffer(T _First, T _Last, C compare) {
	size_t size = std::distance(_First, _Last);
	Cache<typename T::value_type> cache_obj(0);
	wikisort(_First, _Last, cache_obj.cache, cache_obj.cache_size, compare);
}

template<class T, class C>
inline void wikisort_fixedbuffer(T _First, T _Last, C compare) {
	size_t size = std::distance(_First, _Last);
	Cache<typename T::value_type> cache_obj(512);
	wikisort(_First, _Last, cache_obj.cache, cache_obj.cache_size, compare);
}

template<class T, class C>
inline void wikisort_sqrtbuffer(T _First, T _Last, C compare) {
	size_t size = std::distance(_First, _Last);
	Cache<typename T::value_type> cache_obj((size_t)sqrt((size + 1) / 2) + 1);
	wikisort(_First, _Last, cache_obj.cache, cache_obj.cache_size, compare);
}

template<class T, class C>
inline void wikisort_fullbuffer(T _First, T _Last, C compare) {
	size_t size = std::distance(_First, _Last);
	Cache<typename T::value_type> cache_obj((size + 1) / 2);
	wikisort(_First, _Last, cache_obj.cache, cache_obj.cache_size, compare);
}


















~-----------------------------------------------~
C:\Users\Josh\Documents\Visual Studio 2017\Projects\Sorting\Sorting\customtrackbar.cpp
~-----------------------------------------------~
#include "customtrackbar.h"

using namespace std;


//TrackbarColorScheme c_scheme {
//	RGB(10, 10, 10), RGB(50, 50, 50), RGB(255, 0, 0), RGB(0, 0, 0),									// background/border/window text idle/highlight
//	RGB(127, 127, 127), RGB(127, 127, 127), RGB(0, 118, 255), RGB(0, 118, 255), 					// left/right channel left/right highlight
//	RGB(10, 10, 10), RGB(10, 10, 10), RGB(0, 118, 255),												// thumb background: idle/hover/selected
//	RGB(127, 127, 127), RGB(0, 118, 255), RGB(0, 118, 255),											// thumb border: idle/hover/selected
//	RGB(127, 127, 127), RGB(0, 118, 255), RGB(10, 10, 10)											// thumb text: idle/hover/selected
//};

inline std::string wstr_to_str(std::wstring wstr) {
	return std::string(wstr.begin(), wstr.end());
}

inline std::wstring str_to_wstr(std::string str) {
	return std::wstring(str.begin(), str.end());
}

inline RECT getclientrect(HWND hwnd) {
	RECT ret;
	GetClientRect(hwnd, &ret);
	return ret;
}

inline POINT getclientcursorpos(HWND hwnd_parent) {
	RECT temprect;
	GetClientRect(hwnd_parent, &temprect);
	MapWindowPoints(hwnd_parent, NULL, (LPPOINT)&temprect, 2);
	POINT temppoint;
	GetCursorPos(&temppoint);
	POINT client_cursor_pos;
	client_cursor_pos.x = temppoint.x - temprect.left;
	client_cursor_pos.y = temppoint.y - temprect.top;
	return client_cursor_pos;
}

inline bool is_cursor_in_region(RECT region, POINT cursor_pos) {
	return (cursor_pos.x > region.left && cursor_pos.x < region.right && cursor_pos.y < region.bottom && cursor_pos.y > region.top);
}

inline std::string int_to_str(int i) {
	return std::to_string(i);
}

BasicControl_colorscheme::BasicControl_colorscheme() {};

	//statics
BasicControl_colorscheme::BasicControl_colorscheme(
	COLORREF background_idle_on, COLORREF border_idle_on, COLORREF text_idle_on) {
	this->background_idle_on = background_idle_on; this->border_idle_on = border_idle_on; this->text_idle_on = text_idle_on;
	this->background_hover_on = background_idle_on; this->border_hover_on = border_idle_on; this->text_hover_on = text_idle_on;
	//this->background_selected_on = background_idle_on; this->border_selected_on = border_idle_on; this->text_selected_on = text_idle_on;
	this->background_idle_off = background_idle_on; this->border_idle_off = border_idle_on; this->text_idle_off = text_idle_on;
	this->background_hover_off = background_idle_on; this->border_hover_off = border_idle_on; this->text_hover_off = text_idle_on;
	//this->background_selected_off = background_idle_on; this->border_selected_off = border_idle_on; this->text_selected_off = text_idle_on;
}

//buttons etc
BasicControl_colorscheme::BasicControl_colorscheme(
	COLORREF background_idle_on, COLORREF border_idle_on, COLORREF text_idle_on,
	COLORREF background_hover_on, COLORREF border_hover_on, COLORREF text_hover_on)
	//,COLORREF background_selected_on, COLORREF border_selected_on, COLORREF text_selected_on);
{

	this->background_idle_on = background_idle_on; this->border_idle_on = border_idle_on; this->text_idle_on = text_idle_on;
	this->background_hover_on = background_hover_on; this->border_hover_on = border_hover_on; this->text_hover_on = text_hover_on;
	//this->background_selected_on = background_selected_on; this->border_selected_on = border_selected_on; this->text_selected_on = text_selected_on;
	this->background_idle_off = background_idle_on; this->border_idle_off = border_idle_on; this->text_idle_off = text_idle_on;
	this->background_hover_off = background_hover_on; this->border_hover_off = border_hover_on; this->text_hover_off = text_hover_on;
	//this->background_selected_off = background_selected_on; this->border_selected_off = border_selected_on; this->text_selected_off = text_selected_on;
}

//buttons with toggle state
BasicControl_colorscheme::BasicControl_colorscheme(
	COLORREF background_idle_on, COLORREF border_idle_on, COLORREF text_idle_on,
	COLORREF background_hover_on, COLORREF border_hover_on, COLORREF text_hover_on,
	//COLORREF background_selected_on, COLORREF border_selected_on, COLORREF text_selected_on,
	COLORREF background_idle_off, COLORREF border_idle_off, COLORREF text_idle_off,
	COLORREF background_hover_off, COLORREF border_hover_off, COLORREF text_hover_off)
	//COLORREF background_selected_off, COLORREF border_selected_off, COLORREF text_selected_off);
{

	this->background_idle_on = background_idle_on; this->border_idle_on = border_idle_on; this->text_idle_on = text_idle_on;
	this->background_hover_on = background_hover_on; this->border_hover_on = border_hover_on; this->text_hover_on = text_hover_on;
	//this->background_selected_on = background_selected_on; this->border_selected_on = border_selected_on; this->text_selected_on = text_selected_on;
	this->background_idle_off = background_idle_off; this->border_idle_off = border_idle_off; this->text_idle_off = text_idle_off;
	this->background_hover_off = background_hover_off; this->border_hover_off = border_hover_off; this->text_hover_off = text_hover_off;
	//this->background_selected_off = background_selected_off; this->border_selected_off = border_selected_off; this->text_selected_off = text_selected_off;
}


BasicControl* getBasicControl(HWND wnd) {
	LONG_PTR ptr = GetWindowLongPtr(wnd, GWLP_USERDATA);
	return reinterpret_cast<BasicControl*>(ptr);
}

BasicControl::BasicControl() {}

HWND BasicControl::Create(HWND parent) {
	hwnd = CreateWindowEx(window_exstyles, str_to_wstr(className).c_str(), str_to_wstr(window_text).c_str(),
							window_styles, xpos, ypos, width, height,
							parent, (HMENU)id, NULL, this);	
	return hwnd;
}

void BasicControl::Show() {
	SetWindowLong(hwnd, GWL_STYLE, GetWindowLongPtr(hwnd, GWL_STYLE) | WS_VISIBLE);
	ShowWindow(hwnd, SW_SHOW);
	EnableWindow(hwnd, 1);
}

void BasicControl::Hide() {
	if (GetWindowLongPtr(hwnd, GWL_STYLE) & WS_VISIBLE)
		SetWindowLong(hwnd, GWL_STYLE, GetWindowLongPtr(hwnd, GWL_STYLE) ^ WS_VISIBLE);
	ShowWindow(hwnd, SW_HIDE);
	EnableWindow(hwnd, 0);
}



CustomTrackbar::CustomTrackbar(string window_name, UINT window_styles, int xpos, int ypos, UINT width, UINT height, int id,
							   int min_val, int max_val, int start_val, int small_step, int large_step, UINT thumb_size, UINT channel_size, UINT flags,
							   TrackbarColorScheme color_scheme, HCURSOR client_cursor, HCURSOR thumb_cursor) {

	className = wstr_to_str(CustomTrackbar_classname); hwnd = NULL; thumb_region = {0, 0, 0, 0}; pos = NULL; start = true; focus = false;

	this->window_name = window_name; this->window_styles = window_styles; this->xpos = xpos; this->ypos = ypos; this->width = width; this->height = height; this->id = id;
	this->min_val = min_val; this->max_val = max_val; this->start_val = start_val; this->current_val = start_val;
	this->small_step = small_step; this->large_step = large_step; this->thumb_size = thumb_size; this->channel_size = channel_size; this->flags = flags;
	this->tcolor_scheme = color_scheme; this->client_cursor = client_cursor; this->thumb_cursor = thumb_cursor;

	if (this->client_cursor == NULL)
		this->client_cursor = LoadCursor(NULL, IDC_HAND);
	if (this->thumb_cursor == NULL)
		this->thumb_cursor = LoadCursor(NULL, IDC_HAND);
}

int CustomTrackbar::setPos(int pos) {
	int x = flags & CTB_VERT ? height : width;
	return this->pos = pos <= 0 ? 0 : (int)(x - thumb_size) <= pos ? (x - thumb_size) : pos;
}

int CustomTrackbar::setVal(int pos) {
	RECT tr = getclientrect(hwnd);
	width = tr.right - tr.left;
	height = tr.bottom - tr.top;
	int x = flags & CTB_VERT ? height : width;
	return current_val = ((pos * (max_val - min_val)) / (x - thumb_size == 0 ? 1 : (x - thumb_size))) + min_val;
}

int CustomTrackbar::setPosWithVal(int val) {
	RECT tr = getclientrect(hwnd);
	width = tr.right - tr.left;
	height = tr.bottom - tr.top;
	int x = flags & CTB_VERT ? height : width;
	current_val = val <= min_val ? min_val : val >= max_val ? max_val : val;
	return pos = ((current_val - min_val) * (x - thumb_size)) / (max_val - min_val);
}

int CustomTrackbar::moveThumb(int pos) {
	return setVal(setPos(pos));
}

void CustomTrackbar::moveThumbReal(int pos) {
	setPosWithVal(moveThumb(pos));
}

void CustomTrackbar::thumbHitText() {
	if (is_cursor_in_region(thumb_region, getclientcursorpos(hwnd))) {
		if (!thumb_hover) {
			thumb_hover = true;
			InvalidateRect(hwnd, &thumb_region, true);
		}
		SendMessage(hwnd, WM_SETCURSOR, (WPARAM)hwnd, (LPARAM)MAKELONG(HTTHUMB, NULL));
	}
	else if (thumb_hover) {
		thumb_hover = false;
		InvalidateRect(hwnd, &thumb_region, true);
		SendMessage(hwnd, WM_SETCURSOR, (WPARAM)hwnd, (LPARAM)MAKELONG(HTCLIENT, NULL));
	}
}

void CustomTrackbar::setFocus(bool focus, HWND hwnd_focus) {
	this->focus = focus;
	if (focus) {
		//SetFocus(hwnd);
		if (dragging)
			SetCapture(hwnd);
	}
	else {
		ReleaseCapture();
	//	SetFocus(hwnd_focus);
		//setfocus to new window here		
	}

	RedrawWindow(hwnd, NULL, NULL, RDW_INVALIDATE);
}

bool CustomTrackbar::setRange(int min, int max) {
	if (min > max)
		return false;
	min_val = min;
	max_val = max;
	setVal(pos);

	RedrawWindow(hwnd, NULL, NULL, RDW_INVALIDATE);
	return true;
}

void CustomTrackbar::redrawNewVal(int val) {
	RECT tr = getclientrect(hwnd);
	width = tr.right - tr.left;
	height = tr.bottom - tr.top;
	int x = flags & CTB_VERT ? height : width;
	current_val = val <= min_val ? min_val : val >= max_val ? max_val : val;
	pos = ((current_val - min_val) * (x - thumb_size)) / (max_val - min_val == 0 ? 1 : (max_val - min_val));

	if (scrollbar_owner_handle)
		PostMessage(scrollbar_owner_handle, WM_COMMAND, MAKEWPARAM(this->id, CTB_CHANGE), (LPARAM)this->hwnd);
	PostMessage(GetParent(hwnd), WM_COMMAND, MAKEWPARAM(this->id, CTB_CHANGE), (LPARAM)this->hwnd);
	RedrawWindow(hwnd, &tr, NULL, RDW_INVALIDATE);
}

LRESULT CALLBACK CustomTrackbar::customtrackbarProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam) {
	CustomTrackbar* a = (CustomTrackbar*)GetWindowLongPtr(hwnd, GWLP_USERDATA);

	switch (message) {
		case WM_NCCREATE: {
			a = (CustomTrackbar*)((CREATESTRUCT*)lParam)->lpCreateParams;
			a->hwnd = hwnd;
			SetWindowLongPtr(hwnd, GWLP_USERDATA, (LONG_PTR)a);

			break;
		}
		case WM_PAINT:{
			TrackbarColorScheme cs = a->tcolor_scheme;

			PAINTSTRUCT ps;
			HDC temphDC = BeginPaint(a->hwnd, &ps);

			HDC hDC = CreateCompatibleDC(temphDC);
			RECT rcclient = getclientrect(a->hwnd);

			HBITMAP hbmScreen, hbmOldBitmap;
			hbmScreen = CreateCompatibleBitmap(temphDC, rcclient.right, rcclient.bottom);
			hbmOldBitmap = (HBITMAP)SelectObject(hDC, hbmScreen);

			HPEN hpenOld = static_cast<HPEN>(SelectObject(hDC, GetStockObject(DC_PEN)));
			HBRUSH hbrushOld = static_cast<HBRUSH>(SelectObject(hDC, GetStockObject(NULL_BRUSH)));

			//colorbackground
			HBRUSH tempbrush0 = CreateSolidBrush(cs.background);
			FillRect(hDC, &rcclient, tempbrush0);

			//calculate thumb position
			if (a->start) {
				a->setPosWithVal(a->start_val);
				a->start = false;
			}
			a->thumb_region.left = (a->flags & CTB_VERT ? rcclient.left + 1 : rcclient.left + a->pos);
			a->thumb_region.top = (a->flags & CTB_VERT ? rcclient.top + a->pos : rcclient.top + 1);
			a->thumb_region.right = (a->flags & CTB_VERT ? rcclient.right - 1 : rcclient.left + a->thumb_size + a->pos);
			a->thumb_region.bottom = (a->flags & CTB_VERT ? rcclient.left + a->thumb_size + a->pos : rcclient.bottom - 1);

			//draw channel
			RECT rc_channel_left;
			RECT rc_channel_right;

			//left/top
			rc_channel_left.left = (a->flags & CTB_VERT ? rcclient.left + a->channel_size : rcclient.left);
			rc_channel_left.right = (a->flags & CTB_VERT ? rcclient.right - a->channel_size : rcclient.left + a->pos);
			rc_channel_left.top = (a->flags & CTB_VERT ? rcclient.top : rcclient.top + a->channel_size);
			rc_channel_left.bottom = (a->flags & CTB_VERT ? rcclient.top + a->pos : rcclient.bottom - a->channel_size);
			//right/bottom
			rc_channel_right.left = (a->flags & CTB_VERT ? rcclient.left + a->channel_size : rcclient.left + a->thumb_size + a->pos);
			rc_channel_right.right = (a->flags & CTB_VERT ? rcclient.right - a->channel_size : rcclient.right);
			rc_channel_right.top = (a->flags & CTB_VERT ? rcclient.top + a->pos : rcclient.top + a->channel_size);
			rc_channel_right.bottom = (a->flags & CTB_VERT ? rcclient.bottom : rcclient.bottom - a->channel_size);

			HBRUSH tempbrush1 = CreateSolidBrush(a->mouse_in_client ? cs.left_channel_highlight : cs.left_channel_idle);
			HBRUSH tempbrush2 = CreateSolidBrush(a->mouse_in_client ? cs.right_channel_highlight : cs.right_channel_idle);
			FillRect(hDC, &rc_channel_left, tempbrush1);
			FillRect(hDC, &rc_channel_right, tempbrush2);

			//draw focus rect
			if ((a->focus || a->flags & CTB_BORDER) && !(a->flags & CTB_NOBORDER)) {
				SetDCPenColor(hDC, cs.border);
				Rectangle(hDC, rcclient.left, rcclient.top, rcclient.right, rcclient.bottom);
			}

			//draw thumb
			a->thumbHitText();
			SIZE size;
			string text = a->flags & CTB_THUMBVALUE ? int_to_str(a->current_val) : "";
			GetTextExtentPoint32(hDC, str_to_wstr(text).c_str(), (int)text.length(), &size);
			SetTextColor(hDC, a->thumb_selected ? cs.thumb_text_selected : a->thumb_hover ? cs.thumb_text_hover : cs.thumb_text_idle);
			SetBkColor(hDC, a->thumb_selected ? cs.thumb_background_selected : a->thumb_hover ? cs.thumb_background_hover : cs.thumb_background_idle);
			ExtTextOut(hDC,
				((a->thumb_region.right - a->thumb_region.left) - size.cx) / 2 + (a->flags & CTB_VERT ? 0 : a->pos),
					   ((a->thumb_region.bottom - a->thumb_region.top) - size.cy) / 2 + (a->flags & CTB_VERT ? a->pos : 1),
					   ETO_OPAQUE | ETO_CLIPPED, &a->thumb_region, str_to_wstr(text).c_str(), text.length(), NULL);
			SetDCPenColor(hDC, a->thumb_selected ? cs.thumb_border_selected : a->thumb_hover || a->dragging ? cs.thumb_border_hover : cs.thumb_border_idle);
			Rectangle(hDC, a->thumb_region.left, a->thumb_region.top, a->thumb_region.right, a->thumb_region.bottom);

			//draw window name
			if (a->window_name.size() > 0) {
				SetBkMode(hDC, TRANSPARENT);
				SetTextColor(hDC, a->mouse_in_client ? cs.window_name_highlight : cs.window_name_idle);
				RECT rc = getclientrect(a->hwnd);
				DrawText(hDC, str_to_wstr(a->window_name).c_str(), a->window_name.length(), &rc, DT_CENTER | DT_VCENTER | DT_SINGLELINE);
			}

			//apply paint
			BitBlt(temphDC, 0, 0, rcclient.right, rcclient.bottom, hDC, 0, 0, SRCCOPY);

			//clean up			
			SelectObject(hDC, hpenOld);
			SelectObject(hDC, hbrushOld);
			SelectObject(hDC, hbmOldBitmap);

			DeleteObject(tempbrush0);
			DeleteObject(tempbrush1);
			DeleteObject(tempbrush2);
			DeleteObject(hbmScreen);
			DeleteDC(hDC);

			EndPaint(a->hwnd, &ps);

			break;
		}
		case WM_ERASEBKGND: {
			return TRUE;
		}
		case WM_LBUTTONDOWN:{
			a->focus = true;
			a->mouse_in_client = true;
			a->dragging = true;
			a->thumb_hover = true;
			a->thumb_selected = true;

			a->setFocus(true);

			POINT pt = getclientcursorpos(a->hwnd);

			if (a->flags & CTB_SMOOTH)//smooth dragging
				a->moveThumb((a->flags & CTB_VERT ? pt.y : pt.x) - (a->thumb_size / 2));
			else
				a->moveThumbReal((a->flags & CTB_VERT ? pt.y : pt.x) - (a->thumb_size / 2));

			customtrackbarProc(a->hwnd, WM_SETCURSOR, (WPARAM)a->hwnd, (LPARAM)MAKELONG(HTTHUMB, NULL));

			if (a->scrollbar_owner_handle)
				PostMessage(a->scrollbar_owner_handle, WM_COMMAND, MAKEWPARAM(a->id, CTB_CHANGE), (LPARAM)a->hwnd);
			PostMessage(GetParent(a->hwnd), WM_COMMAND, MAKEWPARAM(a->id, CTB_CHANGE), (LPARAM)a->hwnd);

			RedrawWindow(a->hwnd, NULL, NULL, RDW_INVALIDATE);

			break;
		}
		case WM_LBUTTONUP:{
			a->dragging = false;
			a->thumb_selected = false;
			ReleaseCapture();
			if (!(a->flags & CTB_SMOOTH) || !(a->flags & CTB_STAY))//not smooth dragging OR not smooth stay
				a->setPosWithVal(a->current_val);

			RedrawWindow(a->hwnd, NULL, NULL, RDW_INVALIDATE);
			break;
		}
		case WM_MOUSEMOVE:	{
			if (!a->mouse_in_client) {
				SendMessage(a->hwnd, WM_MOUSEENTER, NULL, NULL);
				TRACKMOUSEEVENT me;
				me.cbSize = sizeof(TRACKMOUSEEVENT);
				me.dwFlags = TME_LEAVE;
				me.hwndTrack = a->hwnd;
				me.dwHoverTime = 0;
				TrackMouseEvent(&me);
			}

			a->CustomTrackbar::thumbHitText();

			if (a->dragging) {

				POINT pt = getclientcursorpos(a->hwnd);

				if (a->flags & CTB_SMOOTH)//smooth dragging
					a->moveThumb((a->flags & CTB_VERT ? pt.y : pt.x) - (a->thumb_size / 2));
				else
					a->moveThumbReal((a->flags & CTB_VERT ? pt.y : pt.x) - (a->thumb_size / 2));

				if (a->scrollbar_owner_handle)
					PostMessage(a->scrollbar_owner_handle, WM_COMMAND, MAKEWPARAM(a->id, CTB_CHANGE), (LPARAM)a->hwnd);
				PostMessage(GetParent(a->hwnd), WM_COMMAND, MAKEWPARAM(a->id, CTB_CHANGE), (LPARAM)a->hwnd);

				RedrawWindow(a->hwnd, NULL, NULL, RDW_INVALIDATE);
			}
			break;
		}
		case WM_KEYDOWN:{
			bool wrongkey_skip = false;
			switch (wParam) {
				case VK_LEFT:
				{
					a->setPosWithVal(a->current_val - a->small_step);
					break;
				}
				case VK_DOWN:
				{
					if (a->flags & CTB_VERT)
						a->setPosWithVal(a->current_val + a->small_step);
					else
						a->setPosWithVal(a->current_val - a->small_step);
					break;
				}
				case VK_RIGHT:
				{
					a->setPosWithVal(a->current_val + a->small_step);
					break;
				}
				case VK_UP:
				{
					if (a->flags & CTB_VERT)
						a->setPosWithVal(a->current_val - a->small_step);
					else
						a->setPosWithVal(a->current_val + a->small_step);
					break;
				}
				case VK_HOME:
				{
					a->setPosWithVal(a->min_val);
					break;
				}
				case VK_END:
				{
					a->setPosWithVal(a->max_val);
					break;
				}
				case VK_PRIOR:
				{
					if (a->flags & CTB_VERT)
						a->setPosWithVal(a->current_val - a->large_step);
					else
						a->setPosWithVal(a->current_val + a->large_step);
					break;
				}
				case VK_NEXT:
				{
					if (a->flags & CTB_VERT)
						a->setPosWithVal(a->current_val + a->large_step);
					else
						a->setPosWithVal(a->current_val - a->large_step);
					break;
				}
				default:
					wrongkey_skip = true;
					break;
			}
			if (!wrongkey_skip) {
				if (a->scrollbar_owner_handle)
					PostMessage(a->scrollbar_owner_handle, WM_COMMAND, MAKEWPARAM(a->id, CTB_CHANGE), (LPARAM)a->hwnd);
				PostMessage(GetParent(a->hwnd), WM_COMMAND, MAKEWPARAM(a->id, CTB_CHANGE), (LPARAM)a->hwnd);
				RedrawWindow(a->hwnd, NULL, NULL, RDW_INVALIDATE);
			}
			break;
		}
		case WM_MOUSEWHEEL:{
			if (GET_WHEEL_DELTA_WPARAM(wParam) > 0) {
				if (GET_KEYSTATE_WPARAM(wParam) == MK_SHIFT || GET_KEYSTATE_WPARAM(wParam) == MK_MBUTTON) {
					if (a->flags & CTB_VERT)
						a->setPosWithVal(a->current_val - a->large_step);
					else
						a->setPosWithVal(a->current_val + a->large_step);
				}
				else {
					if (a->flags & CTB_VERT)
						a->setPosWithVal(a->current_val - a->small_step);
					else
						a->setPosWithVal(a->current_val + a->small_step);
				}
			}
			else if (GET_WHEEL_DELTA_WPARAM(wParam) < 0) {
				if (GET_KEYSTATE_WPARAM(wParam) == MK_SHIFT || GET_KEYSTATE_WPARAM(wParam) == MK_MBUTTON) {
					if (a->flags & CTB_VERT)
						a->setPosWithVal(a->current_val + a->large_step);
					else
						a->setPosWithVal(a->current_val - a->large_step);
				}
				else {
					if (a->flags & CTB_VERT)
						a->setPosWithVal(a->current_val + a->small_step);
					else
						a->setPosWithVal(a->current_val - a->small_step);
				}
			}
			else
				break;
			if (a->scrollbar_owner_handle)
				PostMessage(a->scrollbar_owner_handle, WM_COMMAND, MAKEWPARAM(a->id, CTB_CHANGE), (LPARAM)a->hwnd);
			PostMessage(GetParent(a->hwnd), WM_COMMAND, MAKEWPARAM(a->id, CTB_CHANGE), (LPARAM)a->hwnd);
			RedrawWindow(a->hwnd, NULL, NULL, RDW_INVALIDATE);
			break;
		}
		case WM_SIZE:{
			a->width = LOWORD(lParam);
			a->height = HIWORD(lParam);

			break;
		}
		case WM_MOVE:{
			a->xpos = LOWORD(lParam);
			a->ypos = HIWORD(lParam);

			break;
		}
		case WM_SETCURSOR:{
			if (a->dragging)
				lParam = MAKELPARAM(HTTHUMB, HIWORD(lParam));
			switch (LOWORD(lParam)) {
				case HTCLIENT:
					SetCursor(a->client_cursor);
					return TRUE;
				case HTTHUMB:
					SetCursor(a->thumb_cursor);
					return TRUE;
			}
			return DefWindowProc(a->hwnd, message, wParam, lParam);
		}
		case WM_KILLFOCUS:{
			a->setFocus(false, (HWND)wParam);

			a->mouse_in_client = false;
			a->dragging = false;
			a->thumb_hover = false;
			a->thumb_selected = false;

			break;
		}
		case WM_MOUSELEAVE:	{
			if (!a->dragging) {
				a->mouse_in_client = false;
				a->thumb_selected = false;
				a->thumb_hover = false;

				RedrawWindow(a->hwnd, NULL, NULL, RDW_INVALIDATE);
			}
			break;
		}
		case WM_MOUSEENTER:{
			a->mouse_in_client = true;

			RedrawWindow(a->hwnd, NULL, NULL, RDW_INVALIDATE);
			break;
		}
		case WM_DESTROY:{
			a->hwnd = NULL;

			break;
		}
	}
	return DefWindowProc(a->hwnd, message, wParam, lParam);
}

ATOM register_customtrackbar() {
	WNDCLASS wnd = {0};
	wnd.lpszClassName = CustomTrackbar_classname;
	wnd.style = CS_GLOBALCLASS;
	wnd.lpfnWndProc = CustomTrackbar::customtrackbarProc;
	return RegisterClass(&wnd);
}






































~-----------------------------------------------~
C:\Users\Josh\Documents\Visual Studio 2017\Projects\Sorting\Sorting\RtMidi.cpp
~-----------------------------------------------~
/**********************************************************************/
/*! \class RtMidi
	\brief An abstract base class for realtime MIDI input/output.

	This class implements some common functionality for the realtime
	MIDI input/output subclasses RtMidiIn and RtMidiOut.

	RtMidi GitHub site: https://github.com/thestk/rtmidi
	RtMidi WWW site: http://www.music.mcgill.ca/~gary/rtmidi/

	RtMidi: realtime MIDI i/o C++ classes
	Copyright (c) 2003-2019 Gary P. Scavone

	Permission is hereby granted, free of charge, to any person
	obtaining a copy of this software and associated documentation files
	(the "Software"), to deal in the Software without restriction,
	including without limitation the rights to use, copy, modify, merge,
	publish, distribute, sublicense, and/or sell copies of the Software,
	and to permit persons to whom the Software is furnished to do so,
	subject to the following conditions:

	The above copyright notice and this permission notice shall be
	included in all copies or substantial portions of the Software.

	Any person wishing to distribute modifications to the Software is
	asked to send the modifications to the original developer so that
	they can be incorporated into the canonical version.  This is,
	however, not a binding provision of this license.

	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
	EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
	IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR
	ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF
	CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
	WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
*/
/**********************************************************************/

#include "RtMidi.h"
#include <sstream>

#if defined(__MACOSX_CORE__)
#if TARGET_OS_IPHONE
#define AudioGetCurrentHostTime CAHostTimeBase::GetCurrentTime
#define AudioConvertHostTimeToNanos CAHostTimeBase::ConvertToNanos
#endif
#endif

// Default for Windows is to add an identifier to the port names; this
// flag can be defined (e.g. in your project file) to disable this behaviour.
//#define RTMIDI_DO_NOT_ENSURE_UNIQUE_PORTNAMES

// **************************************************************** //
//
// MidiInApi and MidiOutApi subclass prototypes.
//
// **************************************************************** //

#if !defined(__LINUX_ALSA__) && !defined(__UNIX_JACK__) && !defined(__MACOSX_CORE__) && !defined(__WINDOWS_MM__)
#define __RTMIDI_DUMMY__
#endif

#if defined(__MACOSX_CORE__)

class MidiInCore : public MidiInApi {
public:
	MidiInCore(const std::string &clientName, unsigned int queueSizeLimit);
	~MidiInCore(void);
	RtMidi::Api getCurrentApi(void) { return RtMidi::MACOSX_CORE; };
	void openPort(unsigned int portNumber, const std::string &portName);
	void openVirtualPort(const std::string &portName);
	void closePort(void);
	void setClientName(const std::string &clientName);
	void setPortName(const std::string &portName);
	unsigned int getPortCount(void);
	std::string getPortName(unsigned int portNumber);

protected:
	void initialize(const std::string& clientName);
};

class MidiOutCore : public MidiOutApi {
public:
	MidiOutCore(const std::string &clientName);
	~MidiOutCore(void);
	RtMidi::Api getCurrentApi(void) { return RtMidi::MACOSX_CORE; };
	void openPort(unsigned int portNumber, const std::string &portName);
	void openVirtualPort(const std::string &portName);
	void closePort(void);
	void setClientName(const std::string &clientName);
	void setPortName(const std::string &portName);
	unsigned int getPortCount(void);
	std::string getPortName(unsigned int portNumber);
	void sendMessage(const unsigned char *message, size_t size);

protected:
	void initialize(const std::string& clientName);
};

#endif

#if defined(__UNIX_JACK__)

class MidiInJack : public MidiInApi {
public:
	MidiInJack(const std::string &clientName, unsigned int queueSizeLimit);
	~MidiInJack(void);
	RtMidi::Api getCurrentApi(void) { return RtMidi::UNIX_JACK; };
	void openPort(unsigned int portNumber, const std::string &portName);
	void openVirtualPort(const std::string &portName);
	void closePort(void);
	void setClientName(const std::string &clientName);
	void setPortName(const std::string &portName);
	unsigned int getPortCount(void);
	std::string getPortName(unsigned int portNumber);

protected:
	std::string clientName;

	void connect(void);
	void initialize(const std::string& clientName);
};

class MidiOutJack : public MidiOutApi {
public:
	MidiOutJack(const std::string &clientName);
	~MidiOutJack(void);
	RtMidi::Api getCurrentApi(void) { return RtMidi::UNIX_JACK; };
	void openPort(unsigned int portNumber, const std::string &portName);
	void openVirtualPort(const std::string &portName);
	void closePort(void);
	void setClientName(const std::string &clientName);
	void setPortName(const std::string &portName);
	unsigned int getPortCount(void);
	std::string getPortName(unsigned int portNumber);
	void sendMessage(const unsigned char *message, size_t size);

protected:
	std::string clientName;

	void connect(void);
	void initialize(const std::string& clientName);
};

#endif

#if defined(__LINUX_ALSA__)

class MidiInAlsa : public MidiInApi {
public:
	MidiInAlsa(const std::string &clientName, unsigned int queueSizeLimit);
	~MidiInAlsa(void);
	RtMidi::Api getCurrentApi(void) { return RtMidi::LINUX_ALSA; };
	void openPort(unsigned int portNumber, const std::string &portName);
	void openVirtualPort(const std::string &portName);
	void closePort(void);
	void setClientName(const std::string &clientName);
	void setPortName(const std::string &portName);
	unsigned int getPortCount(void);
	std::string getPortName(unsigned int portNumber);

protected:
	void initialize(const std::string& clientName);
};

class MidiOutAlsa : public MidiOutApi {
public:
	MidiOutAlsa(const std::string &clientName);
	~MidiOutAlsa(void);
	RtMidi::Api getCurrentApi(void) { return RtMidi::LINUX_ALSA; };
	void openPort(unsigned int portNumber, const std::string &portName);
	void openVirtualPort(const std::string &portName);
	void closePort(void);
	void setClientName(const std::string &clientName);
	void setPortName(const std::string &portName);
	unsigned int getPortCount(void);
	std::string getPortName(unsigned int portNumber);
	void sendMessage(const unsigned char *message, size_t size);

protected:
	void initialize(const std::string& clientName);
};

#endif

#if defined(__WINDOWS_MM__)

class MidiInWinMM : public MidiInApi {
public:
	MidiInWinMM(const std::string &clientName, unsigned int queueSizeLimit);
	~MidiInWinMM(void);
	RtMidi::Api getCurrentApi(void) { return RtMidi::WINDOWS_MM; };
	void openPort(unsigned int portNumber, const std::string &portName);
	void openVirtualPort(const std::string &portName);
	void closePort(void);
	void setClientName(const std::string &clientName);
	void setPortName(const std::string &portName);
	unsigned int getPortCount(void);
	std::string getPortName(unsigned int portNumber);

protected:
	void initialize(const std::string& clientName);
};

class MidiOutWinMM : public MidiOutApi {
public:
	MidiOutWinMM(const std::string &clientName);
	~MidiOutWinMM(void);
	RtMidi::Api getCurrentApi(void) { return RtMidi::WINDOWS_MM; };
	void openPort(unsigned int portNumber, const std::string &portName);
	void openVirtualPort(const std::string &portName);
	void closePort(void);
	void setClientName(const std::string &clientName);
	void setPortName(const std::string &portName);
	unsigned int getPortCount(void);
	std::string getPortName(unsigned int portNumber);
	void sendMessage(const unsigned char *message, size_t size);

protected:
	void initialize(const std::string& clientName);
};

#endif

#if defined(__RTMIDI_DUMMY__)

class MidiInDummy : public MidiInApi {
public:
	MidiInDummy(const std::string &/*clientName*/, unsigned int queueSizeLimit) : MidiInApi(queueSizeLimit) { errorString_ = "MidiInDummy: This class provides no functionality."; error(RtMidiError::WARNING, errorString_); }
	RtMidi::Api getCurrentApi(void) { return RtMidi::RTMIDI_DUMMY; }
	void openPort(unsigned int /*portNumber*/, const std::string &/*portName*/) {}
	void openVirtualPort(const std::string &/*portName*/) {}
	void closePort(void) {}
	void setClientName(const std::string &/*clientName*/) {};
	void setPortName(const std::string &/*portName*/) {};
	unsigned int getPortCount(void) { return 0; }
	std::string getPortName(unsigned int /*portNumber*/) { return ""; }

protected:
	void initialize(const std::string& /*clientName*/) {}
};

class MidiOutDummy : public MidiOutApi {
public:
	MidiOutDummy(const std::string &/*clientName*/) { errorString_ = "MidiOutDummy: This class provides no functionality."; error(RtMidiError::WARNING, errorString_); }
	RtMidi::Api getCurrentApi(void) { return RtMidi::RTMIDI_DUMMY; }
	void openPort(unsigned int /*portNumber*/, const std::string &/*portName*/) {}
	void openVirtualPort(const std::string &/*portName*/) {}
	void closePort(void) {}
	void setClientName(const std::string &/*clientName*/) {};
	void setPortName(const std::string &/*portName*/) {};
	unsigned int getPortCount(void) { return 0; }
	std::string getPortName(unsigned int /*portNumber*/) { return ""; }
	void sendMessage(const unsigned char * /*message*/, size_t /*size*/) {}

protected:
	void initialize(const std::string& /*clientName*/) {}
};

#endif

//*********************************************************************//
//  RtMidi Definitions
//*********************************************************************//

RtMidi::RtMidi()
	: rtapi_(0) {}

RtMidi :: ~RtMidi() {
	delete rtapi_;
	rtapi_ = 0;
}

std::string RtMidi::getVersion(void) throw() {
	return std::string(RTMIDI_VERSION);
}

// Define API names and display names.
// Must be in same order as API enum.
extern "C" {
	const char* rtmidi_api_names[][2] = {
	  { "unspecified" , "Unknown" },
	  { "core"        , "CoreMidi" },
	  { "alsa"        , "ALSA" },
	  { "jack"        , "Jack" },
	  { "winmm"       , "Windows MultiMedia" },
	  { "dummy"       , "Dummy" },
	};
	const unsigned int rtmidi_num_api_names =
		sizeof(rtmidi_api_names) / sizeof(rtmidi_api_names[0]);

	  // The order here will control the order of RtMidi's API search in
	  // the constructor.
	extern "C" const RtMidi::Api rtmidi_compiled_apis[] = {
	#if defined(__MACOSX_CORE__)
	  RtMidi::MACOSX_CORE,
	#endif
	#if defined(__LINUX_ALSA__)
	  RtMidi::LINUX_ALSA,
	#endif
	#if defined(__UNIX_JACK__)
	  RtMidi::UNIX_JACK,
	#endif
	#if defined(__WINDOWS_MM__)
	  RtMidi::WINDOWS_MM,
	#endif
	#if defined(__RTMIDI_DUMMY__)
	  RtMidi::RTMIDI_DUMMY,
	#endif
	  RtMidi::UNSPECIFIED,
	};
	extern "C" const unsigned int rtmidi_num_compiled_apis =
		sizeof(rtmidi_compiled_apis) / sizeof(rtmidi_compiled_apis[0]) - 1;
}

// This is a compile-time check that rtmidi_num_api_names == RtMidi::NUM_APIS.
// If the build breaks here, check that they match.
template<bool b> class StaticAssert { private: StaticAssert() {} };
template<> class StaticAssert<true> { public: StaticAssert() {} };
class StaticAssertions {
	StaticAssertions() {
		StaticAssert<rtmidi_num_api_names == RtMidi::NUM_APIS>();
	}
};

void RtMidi::getCompiledApi(std::vector<RtMidi::Api> &apis) throw() {
	apis = std::vector<RtMidi::Api>(rtmidi_compiled_apis,
									rtmidi_compiled_apis + rtmidi_num_compiled_apis);
}

std::string RtMidi::getApiName(RtMidi::Api api) {
	if (api < 0 || api >= RtMidi::NUM_APIS)
		return "";
	return rtmidi_api_names[api][0];
}

std::string RtMidi::getApiDisplayName(RtMidi::Api api) {
	if (api < 0 || api >= RtMidi::NUM_APIS)
		return "Unknown";
	return rtmidi_api_names[api][1];
}

RtMidi::Api RtMidi::getCompiledApiByName(const std::string &name) {
	unsigned int i = 0;
	for (i = 0; i < rtmidi_num_compiled_apis; ++i)
		if (name == rtmidi_api_names[rtmidi_compiled_apis[i]][0])
			return rtmidi_compiled_apis[i];
	return RtMidi::UNSPECIFIED;
}

void RtMidi::setClientName(const std::string &clientName) {
	rtapi_->setClientName(clientName);
}

void RtMidi::setPortName(const std::string &portName) {
	rtapi_->setPortName(portName);
}


//*********************************************************************//
//  RtMidiIn Definitions
//*********************************************************************//

void RtMidiIn::openMidiApi(RtMidi::Api api, const std::string &clientName, unsigned int queueSizeLimit) {
	delete rtapi_;
	rtapi_ = 0;

#if defined(__UNIX_JACK__)
	if (api == UNIX_JACK)
		rtapi_ = new MidiInJack(clientName, queueSizeLimit);
#endif
#if defined(__LINUX_ALSA__)
	if (api == LINUX_ALSA)
		rtapi_ = new MidiInAlsa(clientName, queueSizeLimit);
#endif
#if defined(__WINDOWS_MM__)
	if (api == WINDOWS_MM)
		rtapi_ = new MidiInWinMM(clientName, queueSizeLimit);
#endif
#if defined(__MACOSX_CORE__)
	if (api == MACOSX_CORE)
		rtapi_ = new MidiInCore(clientName, queueSizeLimit);
#endif
#if defined(__RTMIDI_DUMMY__)
	if (api == RTMIDI_DUMMY)
		rtapi_ = new MidiInDummy(clientName, queueSizeLimit);
#endif
}

RTMIDI_DLL_PUBLIC RtMidiIn::RtMidiIn(RtMidi::Api api, const std::string &clientName, unsigned int queueSizeLimit)
	: RtMidi() {
	if (api != UNSPECIFIED) {
	  // Attempt to open the specified API.
		openMidiApi(api, clientName, queueSizeLimit);
		if (rtapi_) return;

		// No compiled support for specified API value.  Issue a warning
		// and continue as if no API was specified.
		std::cerr << "\nRtMidiIn: no compiled support for specified API argument!\n\n" << std::endl;
	}

	// Iterate through the compiled APIs and return as soon as we find
	// one with at least one port or we reach the end of the list.
	std::vector< RtMidi::Api > apis;
	getCompiledApi(apis);
	for (unsigned int i = 0; i < apis.size(); i++) {
		openMidiApi(apis[i], clientName, queueSizeLimit);
		if (rtapi_ && rtapi_->getPortCount()) break;
	}

	if (rtapi_) return;

	// It should not be possible to get here because the preprocessor
	// definition __RTMIDI_DUMMY__ is automatically defined if no
	// API-specific definitions are passed to the compiler. But just in
	// case something weird happens, we'll throw an error.
	std::string errorText = "RtMidiIn: no compiled API support found ... critical error!!";
	throw(RtMidiError(errorText, RtMidiError::UNSPECIFIED));
}

RtMidiIn :: ~RtMidiIn() throw() {}


//*********************************************************************//
//  RtMidiOut Definitions
//*********************************************************************//

void RtMidiOut::openMidiApi(RtMidi::Api api, const std::string &clientName) {
	delete rtapi_;
	rtapi_ = 0;

#if defined(__UNIX_JACK__)
	if (api == UNIX_JACK)
		rtapi_ = new MidiOutJack(clientName);
#endif
#if defined(__LINUX_ALSA__)
	if (api == LINUX_ALSA)
		rtapi_ = new MidiOutAlsa(clientName);
#endif
#if defined(__WINDOWS_MM__)
	if (api == WINDOWS_MM)
		rtapi_ = new MidiOutWinMM(clientName);
#endif
#if defined(__MACOSX_CORE__)
	if (api == MACOSX_CORE)
		rtapi_ = new MidiOutCore(clientName);
#endif
#if defined(__RTMIDI_DUMMY__)
	if (api == RTMIDI_DUMMY)
		rtapi_ = new MidiOutDummy(clientName);
#endif
}

RTMIDI_DLL_PUBLIC RtMidiOut::RtMidiOut(RtMidi::Api api, const std::string &clientName) {
	if (api != UNSPECIFIED) {
	  // Attempt to open the specified API.
		openMidiApi(api, clientName);
		if (rtapi_) return;

		// No compiled support for specified API value.  Issue a warning
		// and continue as if no API was specified.
		std::cerr << "\nRtMidiOut: no compiled support for specified API argument!\n\n" << std::endl;
	}

	// Iterate through the compiled APIs and return as soon as we find
	// one with at least one port or we reach the end of the list.
	std::vector< RtMidi::Api > apis;
	getCompiledApi(apis);
	for (unsigned int i = 0; i < apis.size(); i++) {
		openMidiApi(apis[i], clientName);
		if (rtapi_ && rtapi_->getPortCount()) break;
	}

	if (rtapi_) return;

	// It should not be possible to get here because the preprocessor
	// definition __RTMIDI_DUMMY__ is automatically defined if no
	// API-specific definitions are passed to the compiler. But just in
	// case something weird happens, we'll thrown an error.
	std::string errorText = "RtMidiOut: no compiled API support found ... critical error!!";
	throw(RtMidiError(errorText, RtMidiError::UNSPECIFIED));
}

RtMidiOut :: ~RtMidiOut() throw() {}

//*********************************************************************//
//  Common MidiApi Definitions
//*********************************************************************//

MidiApi::MidiApi(void)
	: apiData_(0), connected_(false), errorCallback_(0), firstErrorOccurred_(false), errorCallbackUserData_(0) {}

MidiApi :: ~MidiApi(void) {}

void MidiApi::setErrorCallback(RtMidiErrorCallback errorCallback, void *userData = 0) {
	errorCallback_ = errorCallback;
	errorCallbackUserData_ = userData;
}

void MidiApi::error(RtMidiError::Type type, std::string errorString) {
	if (errorCallback_) {

		if (firstErrorOccurred_)
			return;

		firstErrorOccurred_ = true;
		const std::string errorMessage = errorString;

		errorCallback_(type, errorMessage, errorCallbackUserData_);
		firstErrorOccurred_ = false;
		return;
	}

	if (type == RtMidiError::WARNING) {
		std::cerr << '\n' << errorString << "\n\n";
	}
	else if (type == RtMidiError::DEBUG_WARNING) {
#if defined(__RTMIDI_DEBUG__)
		std::cerr << '\n' << errorString << "\n\n";
#endif
	}
	else {
		std::cerr << '\n' << errorString << "\n\n";
		throw RtMidiError(errorString, type);
	}
}

//*********************************************************************//
//  Common MidiInApi Definitions
//*********************************************************************//

MidiInApi::MidiInApi(unsigned int queueSizeLimit)
	: MidiApi() {
	// Allocate the MIDI queue.
	inputData_.queue.ringSize = queueSizeLimit;
	if (inputData_.queue.ringSize > 0)
		inputData_.queue.ring = new MidiMessage[inputData_.queue.ringSize];
}

MidiInApi :: ~MidiInApi(void) {
  // Delete the MIDI queue.
	if (inputData_.queue.ringSize > 0) delete[] inputData_.queue.ring;
}

void MidiInApi::setCallback(RtMidiIn::RtMidiCallback callback, void *userData) {
	if (inputData_.usingCallback) {
		errorString_ = "MidiInApi::setCallback: a callback function is already set!";
		error(RtMidiError::WARNING, errorString_);
		return;
	}

	if (!callback) {
		errorString_ = "RtMidiIn::setCallback: callback function value is invalid!";
		error(RtMidiError::WARNING, errorString_);
		return;
	}

	inputData_.userCallback = callback;
	inputData_.userData = userData;
	inputData_.usingCallback = true;
}

void MidiInApi::cancelCallback() {
	if (!inputData_.usingCallback) {
		errorString_ = "RtMidiIn::cancelCallback: no callback function was set!";
		error(RtMidiError::WARNING, errorString_);
		return;
	}

	inputData_.userCallback = 0;
	inputData_.userData = 0;
	inputData_.usingCallback = false;
}

void MidiInApi::ignoreTypes(bool midiSysex, bool midiTime, bool midiSense) {
	inputData_.ignoreFlags = 0;
	if (midiSysex) inputData_.ignoreFlags = 0x01;
	if (midiTime) inputData_.ignoreFlags |= 0x02;
	if (midiSense) inputData_.ignoreFlags |= 0x04;
}

double MidiInApi::getMessage(std::vector<unsigned char> *message) {
	message->clear();

	if (inputData_.usingCallback) {
		errorString_ = "RtMidiIn::getNextMessage: a user callback is currently set for this port.";
		error(RtMidiError::WARNING, errorString_);
		return 0.0;
	}

	double timeStamp;
	if (!inputData_.queue.pop(message, &timeStamp))
		return 0.0;

	return timeStamp;
}

unsigned int MidiInApi::MidiQueue::size(unsigned int *__back,
										unsigned int *__front) {
 // Access back/front members exactly once and make stack copies for
 // size calculation
	unsigned int _back = back, _front = front, _size;
	if (_back >= _front)
		_size = _back - _front;
	else
		_size = ringSize - _front + _back;

	  // Return copies of back/front so no new and unsynchronized accesses
	  // to member variables are needed.
	if (__back) *__back = _back;
	if (__front) *__front = _front;
	return _size;
}

// As long as we haven't reached our queue size limit, push the message.
bool MidiInApi::MidiQueue::push(const MidiInApi::MidiMessage& msg) {
  // Local stack copies of front/back
	unsigned int _back, _front, _size;

	// Get back/front indexes exactly once and calculate current size
	_size = size(&_back, &_front);

	if (_size < ringSize - 1) {
		ring[_back] = msg;
		back = (back + 1) % ringSize;
		return true;
	}

	return false;
}

bool MidiInApi::MidiQueue::pop(std::vector<unsigned char> *msg, double* timeStamp) {
  // Local stack copies of front/back
	unsigned int _back, _front, _size;

	// Get back/front indexes exactly once and calculate current size
	_size = size(&_back, &_front);

	if (_size == 0)
		return false;

	  // Copy queued message to the vector pointer argument and then "pop" it.
	msg->assign(ring[_front].bytes.begin(), ring[_front].bytes.end());
	*timeStamp = ring[_front].timeStamp;

	// Update front
	front = (front + 1) % ringSize;
	return true;
}

//*********************************************************************//
//  Common MidiOutApi Definitions
//*********************************************************************//

MidiOutApi::MidiOutApi(void)
	: MidiApi() {}

MidiOutApi :: ~MidiOutApi(void) {}

// *************************************************** //
//
// OS/API-specific methods.
//
// *************************************************** //

#if defined(__MACOSX_CORE__)

// The CoreMIDI API is based on the use of a callback function for
// MIDI input.  We convert the system specific time stamps to delta
// time values.

// OS-X CoreMIDI header files.
#include <CoreMIDI/CoreMIDI.h>
#include <CoreAudio/HostTime.h>
#include <CoreServices/CoreServices.h>

// A structure to hold variables related to the CoreMIDI API
// implementation.
struct CoreMidiData {
	MIDIClientRef client;
	MIDIPortRef port;
	MIDIEndpointRef endpoint;
	MIDIEndpointRef destinationId;
	unsigned long long lastTime;
	MIDISysexSendRequest sysexreq;
};

//*********************************************************************//
//  API: OS-X
//  Class Definitions: MidiInCore
//*********************************************************************//

static void midiInputCallback(const MIDIPacketList *list, void *procRef, void */*srcRef*/) {
	MidiInApi::RtMidiInData *data = static_cast<MidiInApi::RtMidiInData *> (procRef);
	CoreMidiData *apiData = static_cast<CoreMidiData *> (data->apiData);

	unsigned char status;
	unsigned short nBytes, iByte, size;
	unsigned long long time;

	bool& continueSysex = data->continueSysex;
	MidiInApi::MidiMessage& message = data->message;

	const MIDIPacket *packet = &list->packet[0];
	for (unsigned int i = 0; i < list->numPackets; ++i) {

	  // My interpretation of the CoreMIDI documentation: all message
	  // types, except sysex, are complete within a packet and there may
	  // be several of them in a single packet.  Sysex messages can be
	  // broken across multiple packets and PacketLists but are bundled
	  // alone within each packet (these packets do not contain other
	  // message types).  If sysex messages are split across multiple
	  // MIDIPacketLists, they must be hwndd by multiple calls to this
	  // function.

		nBytes = packet->length;
		if (nBytes == 0) {
			packet = MIDIPacketNext(packet);
			continue;
		}

		// Calculate time stamp.
		if (data->firstMessage) {
			message.timeStamp = 0.0;
			data->firstMessage = false;
		}
		else {
			time = packet->timeStamp;
			if (time == 0) { // this happens when receiving asynchronous sysex messages
				time = AudioGetCurrentHostTime();
			}
			time -= apiData->lastTime;
			time = AudioConvertHostTimeToNanos(time);
			if (!continueSysex)
				message.timeStamp = time * 0.000000001;
		}

		// Track whether any non-filtered messages were found in this
		// packet for timestamp calculation
		bool foundNonFiltered = false;

		iByte = 0;
		if (continueSysex) {
		  // We have a continuing, segmented sysex message.
			if (!(data->ignoreFlags & 0x01)) {
			  // If we're not ignoring sysex messages, copy the entire packet.
				for (unsigned int j = 0; j < nBytes; ++j)
					message.bytes.push_back(packet->data[j]);
			}
			continueSysex = packet->data[nBytes - 1] != 0xF7;

			if (!(data->ignoreFlags & 0x01) && !continueSysex) {
			  // If not a continuing sysex message, invoke the user callback function or queue the message.
				if (data->usingCallback) {
					RtMidiIn::RtMidiCallback callback = (RtMidiIn::RtMidiCallback) data->userCallback;
					callback(message.timeStamp, &message.bytes, data->userData);
				}
				else {
				  // As long as we haven't reached our queue size limit, push the message.
					if (!data->queue.push(message))
						std::cerr << "\nMidiInCore: message queue limit reached!!\n\n";
				}
				message.bytes.clear();
			}
		}
		else {
			while (iByte < nBytes) {
				size = 0;
				// We are expecting that the next byte in the packet is a status byte.
				status = packet->data[iByte];
				if (!(status & 0x80)) break;
				// Determine the number of bytes in the MIDI message.
				if (status < 0xC0) size = 3;
				else if (status < 0xE0) size = 2;
				else if (status < 0xF0) size = 3;
				else if (status == 0xF0) {
				  // A MIDI sysex
					if (data->ignoreFlags & 0x01) {
						size = 0;
						iByte = nBytes;
					}
					else size = nBytes - iByte;
					continueSysex = packet->data[nBytes - 1] != 0xF7;
				}
				else if (status == 0xF1) {
				  // A MIDI time code message
					if (data->ignoreFlags & 0x02) {
						size = 0;
						iByte += 2;
					}
					else size = 2;
				}
				else if (status == 0xF2) size = 3;
				else if (status == 0xF3) size = 2;
				else if (status == 0xF8 && (data->ignoreFlags & 0x02)) {
				  // A MIDI timing tick message and we're ignoring it.
					size = 0;
					iByte += 1;
				}
				else if (status == 0xFE && (data->ignoreFlags & 0x04)) {
				  // A MIDI active sensing message and we're ignoring it.
					size = 0;
					iByte += 1;
				}
				else size = 1;

				// Copy the MIDI data to our vector.
				if (size) {
					foundNonFiltered = true;
					message.bytes.assign(&packet->data[iByte], &packet->data[iByte + size]);
					if (!continueSysex) {
					  // If not a continuing sysex message, invoke the user callback function or queue the message.
						if (data->usingCallback) {
							RtMidiIn::RtMidiCallback callback = (RtMidiIn::RtMidiCallback) data->userCallback;
							callback(message.timeStamp, &message.bytes, data->userData);
						}
						else {
						  // As long as we haven't reached our queue size limit, push the message.
							if (!data->queue.push(message))
								std::cerr << "\nMidiInCore: message queue limit reached!!\n\n";
						}
						message.bytes.clear();
					}
					iByte += size;
				}
			}
		}

		// Save the time of the last non-filtered message
		if (foundNonFiltered) {
			apiData->lastTime = packet->timeStamp;
			if (apiData->lastTime == 0) { // this happens when receiving asynchronous sysex messages
				apiData->lastTime = AudioGetCurrentHostTime();
			}
		}

		packet = MIDIPacketNext(packet);
	}
}

MidiInCore::MidiInCore(const std::string &clientName, unsigned int queueSizeLimit)
	: MidiInApi(queueSizeLimit) {
	MidiInCore::initialize(clientName);
}

MidiInCore :: ~MidiInCore(void) {
  // Close a connection if it exists.
	MidiInCore::closePort();

	// Cleanup.
	CoreMidiData *data = static_cast<CoreMidiData *> (apiData_);
	MIDIClientDispose(data->client);
	if (data->endpoint) MIDIEndpointDispose(data->endpoint);
	delete data;
}

void MidiInCore::initialize(const std::string& clientName) {
  // Set up our client.
	MIDIClientRef client;
	CFStringRef name = CFStringCreateWithCString(NULL, clientName.c_str(), kCFStringEncodingASCII);
	OSStatus result = MIDIClientCreate(name, NULL, NULL, &client);
	if (result != noErr) {
		std::ostringstream ost;
		ost << "MidiInCore::initialize: error creating OS-X MIDI client object (" << result << ").";
		errorString_ = ost.str();
		error(RtMidiError::DRIVER_ERROR, errorString_);
		return;
	}

	// Save our api-specific connection information.
	CoreMidiData *data = (CoreMidiData *) new CoreMidiData;
	data->client = client;
	data->endpoint = 0;
	apiData_ = (void *)data;
	inputData_.apiData = (void *)data;
	CFRelease(name);
}

void MidiInCore::openPort(unsigned int portNumber, const std::string &portName) {
	if (connected_) {
		errorString_ = "MidiInCore::openPort: a valid connection already exists!";
		error(RtMidiError::WARNING, errorString_);
		return;
	}

	CFRunLoopRunInMode(kCFRunLoopDefaultMode, 0, false);
	unsigned int nSrc = MIDIGetNumberOfSources();
	if (nSrc < 1) {
		errorString_ = "MidiInCore::openPort: no MIDI input sources found!";
		error(RtMidiError::NO_DEVICES_FOUND, errorString_);
		return;
	}

	if (portNumber >= nSrc) {
		std::ostringstream ost;
		ost << "MidiInCore::openPort: the 'portNumber' argument (" << portNumber << ") is invalid.";
		errorString_ = ost.str();
		error(RtMidiError::INVALID_PARAMETER, errorString_);
		return;
	}

	MIDIPortRef port;
	CoreMidiData *data = static_cast<CoreMidiData *> (apiData_);
	CFStringRef portNameRef = CFStringCreateWithCString(NULL, portName.c_str(), kCFStringEncodingASCII);
	OSStatus result = MIDIInputPortCreate(data->client,
										  portNameRef,
										  midiInputCallback, (void *)&inputData_, &port);
	CFRelease(portNameRef);

	if (result != noErr) {
		MIDIClientDispose(data->client);
		errorString_ = "MidiInCore::openPort: error creating OS-X MIDI input port.";
		error(RtMidiError::DRIVER_ERROR, errorString_);
		return;
	}

	// Get the desired input source identifier.
	MIDIEndpointRef endpoint = MIDIGetSource(portNumber);
	if (endpoint == 0) {
		MIDIPortDispose(port);
		MIDIClientDispose(data->client);
		errorString_ = "MidiInCore::openPort: error getting MIDI input source reference.";
		error(RtMidiError::DRIVER_ERROR, errorString_);
		return;
	}

	// Make the connection.
	result = MIDIPortConnectSource(port, endpoint, NULL);
	if (result != noErr) {
		MIDIPortDispose(port);
		MIDIClientDispose(data->client);
		errorString_ = "MidiInCore::openPort: error connecting OS-X MIDI input port.";
		error(RtMidiError::DRIVER_ERROR, errorString_);
		return;
	}

	// Save our api-specific port information.
	data->port = port;

	connected_ = true;
}

void MidiInCore::openVirtualPort(const std::string &portName) {
	CoreMidiData *data = static_cast<CoreMidiData *> (apiData_);

	// Create a virtual MIDI input destination.
	MIDIEndpointRef endpoint;
	CFStringRef portNameRef = CFStringCreateWithCString(NULL, portName.c_str(), kCFStringEncodingASCII);
	OSStatus result = MIDIDestinationCreate(data->client,
											portNameRef,
											midiInputCallback, (void *)&inputData_, &endpoint);
	CFRelease(portNameRef);

	if (result != noErr) {
		errorString_ = "MidiInCore::openVirtualPort: error creating virtual OS-X MIDI destination.";
		error(RtMidiError::DRIVER_ERROR, errorString_);
		return;
	}

	// Save our api-specific connection information.
	data->endpoint = endpoint;
}

void MidiInCore::closePort(void) {
	CoreMidiData *data = static_cast<CoreMidiData *> (apiData_);

	if (data->endpoint) {
		MIDIEndpointDispose(data->endpoint);
		data->endpoint = 0;
	}

	if (data->port) {
		MIDIPortDispose(data->port);
		data->port = 0;
	}

	connected_ = false;
}

void MidiInCore::setClientName(const std::string&) {

	errorString_ = "MidiInCore::setClientName: this function is not implemented for the MACOSX_CORE API!";
	error(RtMidiError::WARNING, errorString_);

}

void MidiInCore::setPortName(const std::string&) {

	errorString_ = "MidiInCore::setPortName: this function is not implemented for the MACOSX_CORE API!";
	error(RtMidiError::WARNING, errorString_);

}

unsigned int MidiInCore::getPortCount() {
	CFRunLoopRunInMode(kCFRunLoopDefaultMode, 0, false);
	return MIDIGetNumberOfSources();
}

// This function was submitted by Douglas Casey Tucker and apparently
// derived largely from PortMidi.
CFStringRef EndpointName(MIDIEndpointRef endpoint, bool isExternal) {
	CFMutableStringRef result = CFStringCreateMutable(NULL, 0);
	CFStringRef str;

	// Begin with the endpoint's name.
	str = NULL;
	MIDIObjectGetStringProperty(endpoint, kMIDIPropertyName, &str);
	if (str != NULL) {
		CFStringAppend(result, str);
		CFRelease(str);
	}

	MIDIEntityRef entity = 0;
	MIDIEndpointGetEntity(endpoint, &entity);
	if (entity == 0)
	  // probably virtual
		return result;

	if (CFStringGetLength(result) == 0) {
	  // endpoint name has zero length -- try the entity
		str = NULL;
		MIDIObjectGetStringProperty(entity, kMIDIPropertyName, &str);
		if (str != NULL) {
			CFStringAppend(result, str);
			CFRelease(str);
		}
	}
	// now consider the device's name
	MIDIDeviceRef device = 0;
	MIDIEntityGetDevice(entity, &device);
	if (device == 0)
		return result;

	str = NULL;
	MIDIObjectGetStringProperty(device, kMIDIPropertyName, &str);
	if (CFStringGetLength(result) == 0) {
		CFRelease(result);
		return str;
	}
	if (str != NULL) {
	  // if an external device has only one entity, throw away
	  // the endpoint name and just use the device name
		if (isExternal && MIDIDeviceGetNumberOfEntities(device) < 2) {
			CFRelease(result);
			return str;
		}
		else {
			if (CFStringGetLength(str) == 0) {
				CFRelease(str);
				return result;
			}
			// does the entity name already start with the device name?
			// (some drivers do this though they shouldn't)
			// if so, do not prepend
			if (CFStringCompareWithOptions(result, /* endpoint name */
				str /* device name */,
				CFRangeMake(0, CFStringGetLength(str)), 0) != kCFCompareEqualTo) {
// prepend the device name to the entity name
				if (CFStringGetLength(result) > 0)
					CFStringInsert(result, 0, CFSTR(" "));

				CFStringInsert(result, 0, str);
			}
			CFRelease(str);
		}
	}
	return result;
}

// This function was submitted by Douglas Casey Tucker and apparently
// derived largely from PortMidi.
static CFStringRef ConnectedEndpointName(MIDIEndpointRef endpoint) {
	CFMutableStringRef result = CFStringCreateMutable(NULL, 0);
	CFStringRef str;
	OSStatus err;
	int i;

	// Does the endpoint have connections?
	CFDataRef connections = NULL;
	int nConnected = 0;
	bool anyStrings = false;
	err = MIDIObjectGetDataProperty(endpoint, kMIDIPropertyConnectionUniqueID, &connections);
	if (connections != NULL) {
	  // It has connections, follow them
	  // Concatenate the names of all connected devices
		nConnected = CFDataGetLength(connections) / sizeof(MIDIUniqueID);
		if (nConnected) {
			const SInt32 *pid = (const SInt32 *)(CFDataGetBytePtr(connections));
			for (i = 0; i < nConnected; ++i, ++pid) {
				MIDIUniqueID id = EndianS32_BtoN(*pid);
				MIDIObjectRef connObject;
				MIDIObjectType connObjectType;
				err = MIDIObjectFindByUniqueID(id, &connObject, &connObjectType);
				if (err == noErr) {
					if (connObjectType == kMIDIObjectType_ExternalSource ||
						connObjectType == kMIDIObjectType_ExternalDestination) {
					 // Connected to an external device's endpoint (10.3 and later).
						str = EndpointName((MIDIEndpointRef)(connObject), true);
					}
					else {
				   // Connected to an external device (10.2) (or something else, catch-
						str = NULL;
						MIDIObjectGetStringProperty(connObject, kMIDIPropertyName, &str);
					}
					if (str != NULL) {
						if (anyStrings)
							CFStringAppend(result, CFSTR(", "));
						else
							anyStrings = true;
						CFStringAppend(result, str);
						CFRelease(str);
					}
				}
			}
		}
		CFRelease(connections);
	}
	if (anyStrings)
		return result;

	CFRelease(result);

	// Here, either the endpoint had no connections, or we failed to obtain names
	return EndpointName(endpoint, false);
}

std::string MidiInCore::getPortName(unsigned int portNumber) {
	CFStringRef nameRef;
	MIDIEndpointRef portRef;
	char name[128];

	std::string stringName;
	CFRunLoopRunInMode(kCFRunLoopDefaultMode, 0, false);
	if (portNumber >= MIDIGetNumberOfSources()) {
		std::ostringstream ost;
		ost << "MidiInCore::getPortName: the 'portNumber' argument (" << portNumber << ") is invalid.";
		errorString_ = ost.str();
		error(RtMidiError::WARNING, errorString_);
		return stringName;
	}

	portRef = MIDIGetSource(portNumber);
	nameRef = ConnectedEndpointName(portRef);
	CFStringGetCString(nameRef, name, sizeof(name), kCFStringEncodingUTF8);
	CFRelease(nameRef);

	return stringName = name;
}

//*********************************************************************//
//  API: OS-X
//  Class Definitions: MidiOutCore
//*********************************************************************//

MidiOutCore::MidiOutCore(const std::string &clientName)
	: MidiOutApi() {
	MidiOutCore::initialize(clientName);
}

MidiOutCore :: ~MidiOutCore(void) {
  // Close a connection if it exists.
	MidiOutCore::closePort();

	// Cleanup.
	CoreMidiData *data = static_cast<CoreMidiData *> (apiData_);
	MIDIClientDispose(data->client);
	if (data->endpoint) MIDIEndpointDispose(data->endpoint);
	delete data;
}

void MidiOutCore::initialize(const std::string& clientName) {
  // Set up our client.
	MIDIClientRef client;
	CFStringRef name = CFStringCreateWithCString(NULL, clientName.c_str(), kCFStringEncodingASCII);
	OSStatus result = MIDIClientCreate(name, NULL, NULL, &client);
	if (result != noErr) {
		std::ostringstream ost;
		ost << "MidiInCore::initialize: error creating OS-X MIDI client object (" << result << ").";
		errorString_ = ost.str();
		error(RtMidiError::DRIVER_ERROR, errorString_);
		return;
	}

	// Save our api-specific connection information.
	CoreMidiData *data = (CoreMidiData *) new CoreMidiData;
	data->client = client;
	data->endpoint = 0;
	apiData_ = (void *)data;
	CFRelease(name);
}

unsigned int MidiOutCore::getPortCount() {
	CFRunLoopRunInMode(kCFRunLoopDefaultMode, 0, false);
	return MIDIGetNumberOfDestinations();
}

std::string MidiOutCore::getPortName(unsigned int portNumber) {
	CFStringRef nameRef;
	MIDIEndpointRef portRef;
	char name[128];

	std::string stringName;
	CFRunLoopRunInMode(kCFRunLoopDefaultMode, 0, false);
	if (portNumber >= MIDIGetNumberOfDestinations()) {
		std::ostringstream ost;
		ost << "MidiOutCore::getPortName: the 'portNumber' argument (" << portNumber << ") is invalid.";
		errorString_ = ost.str();
		error(RtMidiError::WARNING, errorString_);
		return stringName;
	}

	portRef = MIDIGetDestination(portNumber);
	nameRef = ConnectedEndpointName(portRef);
	CFStringGetCString(nameRef, name, sizeof(name), kCFStringEncodingUTF8);
	CFRelease(nameRef);

	return stringName = name;
}

void MidiOutCore::openPort(unsigned int portNumber, const std::string &portName) {
	if (connected_) {
		errorString_ = "MidiOutCore::openPort: a valid connection already exists!";
		error(RtMidiError::WARNING, errorString_);
		return;
	}

	CFRunLoopRunInMode(kCFRunLoopDefaultMode, 0, false);
	unsigned int nDest = MIDIGetNumberOfDestinations();
	if (nDest < 1) {
		errorString_ = "MidiOutCore::openPort: no MIDI output destinations found!";
		error(RtMidiError::NO_DEVICES_FOUND, errorString_);
		return;
	}

	if (portNumber >= nDest) {
		std::ostringstream ost;
		ost << "MidiOutCore::openPort: the 'portNumber' argument (" << portNumber << ") is invalid.";
		errorString_ = ost.str();
		error(RtMidiError::INVALID_PARAMETER, errorString_);
		return;
	}

	MIDIPortRef port;
	CoreMidiData *data = static_cast<CoreMidiData *> (apiData_);
	CFStringRef portNameRef = CFStringCreateWithCString(NULL, portName.c_str(), kCFStringEncodingASCII);
	OSStatus result = MIDIOutputPortCreate(data->client, portNameRef, &port);
	CFRelease(portNameRef);
	if (result != noErr) {
		MIDIClientDispose(data->client);
		errorString_ = "MidiOutCore::openPort: error creating OS-X MIDI output port.";
		error(RtMidiError::DRIVER_ERROR, errorString_);
		return;
	}

	// Get the desired output port identifier.
	MIDIEndpointRef destination = MIDIGetDestination(portNumber);
	if (destination == 0) {
		MIDIPortDispose(port);
		MIDIClientDispose(data->client);
		errorString_ = "MidiOutCore::openPort: error getting MIDI output destination reference.";
		error(RtMidiError::DRIVER_ERROR, errorString_);
		return;
	}

	// Save our api-specific connection information.
	data->port = port;
	data->destinationId = destination;
	connected_ = true;
}

void MidiOutCore::closePort(void) {
	CoreMidiData *data = static_cast<CoreMidiData *> (apiData_);

	if (data->endpoint) {
		MIDIEndpointDispose(data->endpoint);
		data->endpoint = 0;
	}

	if (data->port) {
		MIDIPortDispose(data->port);
		data->port = 0;
	}

	connected_ = false;
}

void MidiOutCore::setClientName(const std::string&) {

	errorString_ = "MidiOutCore::setClientName: this function is not implemented for the MACOSX_CORE API!";
	error(RtMidiError::WARNING, errorString_);

}

void MidiOutCore::setPortName(const std::string&) {

	errorString_ = "MidiOutCore::setPortName: this function is not implemented for the MACOSX_CORE API!";
	error(RtMidiError::WARNING, errorString_);

}

void MidiOutCore::openVirtualPort(const std::string &portName) {
	CoreMidiData *data = static_cast<CoreMidiData *> (apiData_);

	if (data->endpoint) {
		errorString_ = "MidiOutCore::openVirtualPort: a virtual output port already exists!";
		error(RtMidiError::WARNING, errorString_);
		return;
	}

	// Create a virtual MIDI output source.
	MIDIEndpointRef endpoint;
	CFStringRef portNameRef = CFStringCreateWithCString(NULL, portName.c_str(), kCFStringEncodingASCII);
	OSStatus result = MIDISourceCreate(data->client, portNameRef, &endpoint);
	CFRelease(portNameRef);

	if (result != noErr) {
		errorString_ = "MidiOutCore::initialize: error creating OS-X virtual MIDI source.";
		error(RtMidiError::DRIVER_ERROR, errorString_);
		return;
	}

	// Save our api-specific connection information.
	data->endpoint = endpoint;
}

void MidiOutCore::sendMessage(const unsigned char *message, size_t size) {
  // We use the MIDISendSysex() function to asynchronously send sysex
  // messages.  Otherwise, we use a single CoreMidi MIDIPacket.
	unsigned int nBytes = static_cast<unsigned int> (size);
	if (nBytes == 0) {
		errorString_ = "MidiOutCore::sendMessage: no data in message argument!";
		error(RtMidiError::WARNING, errorString_);
		return;
	}

	MIDITimeStamp timeStamp = AudioGetCurrentHostTime();
	CoreMidiData *data = static_cast<CoreMidiData *> (apiData_);
	OSStatus result;

	if (message[0] != 0xF0 && nBytes > 3) {
		errorString_ = "MidiOutCore::sendMessage: message format problem ... not sysex but > 3 bytes?";
		error(RtMidiError::WARNING, errorString_);
		return;
	}

	Byte buffer[nBytes + (sizeof(MIDIPacketList))];
	ByteCount listSize = sizeof(buffer);
	MIDIPacketList *packetList = (MIDIPacketList*)buffer;
	MIDIPacket *packet = MIDIPacketListInit(packetList);

	ByteCount remainingBytes = nBytes;
	while (remainingBytes && packet) {
		ByteCount bytesForPacket = remainingBytes > 65535 ? 65535 : remainingBytes; // 65535 = maximum size of a MIDIPacket
		const Byte* dataStartPtr = (const Byte *)&message[nBytes - remainingBytes];
		packet = MIDIPacketListAdd(packetList, listSize, packet, timeStamp, bytesForPacket, dataStartPtr);
		remainingBytes -= bytesForPacket;
	}

	if (!packet) {
		errorString_ = "MidiOutCore::sendMessage: could not allocate packet list";
		error(RtMidiError::DRIVER_ERROR, errorString_);
		return;
	}

	// Send to any destinations that may have connected to us.
	if (data->endpoint) {
		result = MIDIReceived(data->endpoint, packetList);
		if (result != noErr) {
			errorString_ = "MidiOutCore::sendMessage: error sending MIDI to virtual destinations.";
			error(RtMidiError::WARNING, errorString_);
		}
	}

	// And send to an explicit destination port if we're connected.
	if (connected_) {
		result = MIDISend(data->port, data->destinationId, packetList);
		if (result != noErr) {
			errorString_ = "MidiOutCore::sendMessage: error sending MIDI message to port.";
			error(RtMidiError::WARNING, errorString_);
		}
	}
}

#endif  // __MACOSX_CORE__


//*********************************************************************//
//  API: LINUX ALSA SEQUENCER
//*********************************************************************//

// API information found at:
//   - http://www.alsa-project.org/documentation.php#Library

#if defined(__LINUX_ALSA__)

// The ALSA Sequencer API is based on the use of a callback function for
// MIDI input.
//
// Thanks to Pedro Lopez-Cabanillas for help with the ALSA sequencer
// time stamps and other assorted fixes!!!

// If you don't need timestamping for incoming MIDI events, define the
// preprocessor definition AVOID_TIMESTAMPING to save resources
// associated with the ALSA sequencer queues.

#include <pthread.h>
#include <sys/time.h>

// ALSA header file.
#include <alsa/asoundlib.h>

// A structure to hold variables related to the ALSA API
// implementation.
struct AlsaMidiData {
	snd_seq_t *seq;
	unsigned int portNum;
	int vport;
	snd_seq_port_subscribe_t *subscription;
	snd_midi_event_t *coder;
	unsigned int bufferSize;
	unsigned char *buffer;
	pthread_t thread;
	pthread_t dummy_thread_id;
	snd_seq_real_time_t lastTime;
	int queue_id; // an input queue is needed to get timestamped events
	int trigger_fds[2];
};

#define PORT_TYPE( pinfo, bits ) ((snd_seq_port_info_get_capability(pinfo) & (bits)) == (bits))

//*********************************************************************//
//  API: LINUX ALSA
//  Class Definitions: MidiInAlsa
//*********************************************************************//

static void *alsaMidihwndr(void *ptr) {
	MidiInApi::RtMidiInData *data = static_cast<MidiInApi::RtMidiInData *> (ptr);
	AlsaMidiData *apiData = static_cast<AlsaMidiData *> (data->apiData);

	long nBytes;
	double time;
	bool continueSysex = false;
	bool doDecode = false;
	MidiInApi::MidiMessage message;
	int poll_fd_count;
	struct pollfd *poll_fds;

	snd_seq_event_t *ev;
	int result;
	apiData->bufferSize = 32;
	result = snd_midi_event_new(0, &apiData->coder);
	if (result < 0) {
		data->doInput = false;
		std::cerr << "\nMidiInAlsa::alsaMidihwndr: error initializing MIDI event parser!\n\n";
		return 0;
	}
	unsigned char *buffer = (unsigned char *)malloc(apiData->bufferSize);
	if (buffer == NULL) {
		data->doInput = false;
		snd_midi_event_free(apiData->coder);
		apiData->coder = 0;
		std::cerr << "\nMidiInAlsa::alsaMidihwndr: error initializing buffer memory!\n\n";
		return 0;
	}
	snd_midi_event_init(apiData->coder);
	snd_midi_event_no_status(apiData->coder, 1); // suppress running status messages

	poll_fd_count = snd_seq_poll_descriptors_count(apiData->seq, POLLIN) + 1;
	poll_fds = (struct pollfd*)alloca(poll_fd_count * sizeof(struct pollfd));
	snd_seq_poll_descriptors(apiData->seq, poll_fds + 1, poll_fd_count - 1, POLLIN);
	poll_fds[0].fd = apiData->trigger_fds[0];
	poll_fds[0].events = POLLIN;

	while (data->doInput) {

		if (snd_seq_event_input_pending(apiData->seq, 1) == 0) {
		  // No data pending
			if (poll(poll_fds, poll_fd_count, -1) >= 0) {
				if (poll_fds[0].revents & POLLIN) {
					bool dummy;
					int res = read(poll_fds[0].fd, &dummy, sizeof(dummy));
					(void)res;
				}
			}
			continue;
		}

		// If here, there should be data.
		result = snd_seq_event_input(apiData->seq, &ev);
		if (result == -ENOSPC) {
			std::cerr << "\nMidiInAlsa::alsaMidihwndr: MIDI input buffer overrun!\n\n";
			continue;
		}
		else if (result <= 0) {
			std::cerr << "\nMidiInAlsa::alsaMidihwndr: unknown MIDI input error!\n";
			perror("System reports");
			continue;
		}

		// This is a bit weird, but we now have to decode an ALSA MIDI
		// event (back) into MIDI bytes.  We'll ignore non-MIDI types.
		if (!continueSysex) message.bytes.clear();

		doDecode = false;
		switch (ev->type) {

			case SND_SEQ_EVENT_PORT_SUBSCRIBED:
#if defined(__RTMIDI_DEBUG__)
				std::cout << "MidiInAlsa::alsaMidihwndr: port connection made!\n";
#endif
				break;

			case SND_SEQ_EVENT_PORT_UNSUBSCRIBED:
#if defined(__RTMIDI_DEBUG__)
				std::cerr << "MidiInAlsa::alsaMidihwndr: port connection has closed!\n";
				std::cout << "sender = " << (int)ev->data.connect.sender.client << ":"
					<< (int)ev->data.connect.sender.port
					<< ", dest = " << (int)ev->data.connect.dest.client << ":"
					<< (int)ev->data.connect.dest.port
					<< std::endl;
#endif
				break;

			case SND_SEQ_EVENT_QFRAME: // MIDI time code
				if (!(data->ignoreFlags & 0x02)) doDecode = true;
				break;

			case SND_SEQ_EVENT_TICK: // 0xF9 ... MIDI timing tick
				if (!(data->ignoreFlags & 0x02)) doDecode = true;
				break;

			case SND_SEQ_EVENT_CLOCK: // 0xF8 ... MIDI timing (clock) tick
				if (!(data->ignoreFlags & 0x02)) doDecode = true;
				break;

			case SND_SEQ_EVENT_SENSING: // Active sensing
				if (!(data->ignoreFlags & 0x04)) doDecode = true;
				break;

			case SND_SEQ_EVENT_SYSEX:
				if ((data->ignoreFlags & 0x01)) break;
				if (ev->data.ext.len > apiData->bufferSize) {
					apiData->bufferSize = ev->data.ext.len;
					free(buffer);
					buffer = (unsigned char *)malloc(apiData->bufferSize);
					if (buffer == NULL) {
						data->doInput = false;
						std::cerr << "\nMidiInAlsa::alsaMidihwndr: error resizing buffer memory!\n\n";
						break;
					}
				}
				doDecode = true;
				break;

			default:
				doDecode = true;
		}

		if (doDecode) {

			nBytes = snd_midi_event_decode(apiData->coder, buffer, apiData->bufferSize, ev);
			if (nBytes > 0) {
			  // The ALSA sequencer has a maximum buffer size for MIDI sysex
			  // events of 256 bytes.  If a device sends sysex messages larger
			  // than this, they are segmented into 256 byte chunks.  So,
			  // we'll watch for this and concatenate sysex chunks into a
			  // single sysex message if necessary.
				if (!continueSysex)
					message.bytes.assign(buffer, &buffer[nBytes]);
				else
					message.bytes.insert(message.bytes.end(), buffer, &buffer[nBytes]);

				continueSysex = ((ev->type == SND_SEQ_EVENT_SYSEX) && (message.bytes.back() != 0xF7));
				if (!continueSysex) {

				  // Calculate the time stamp:
					message.timeStamp = 0.0;

					// Method 1: Use the system time.
					//(void)gettimeofday(&tv, (struct timezone *)NULL);
					//time = (tv.tv_sec * 1000000) + tv.tv_usec;

					// Method 2: Use the ALSA sequencer event time data.
					// (thanks to Pedro Lopez-Cabanillas!).

					// Using method from:
					// https://www.gnu.org/software/libc/manual/html_node/Elapsed-Time.html

					// Perform the carry for the later subtraction by updating y.
					// Temp var y is timespec because computation requires signed types,
					// while snd_seq_real_time_t has unsigned types.
					snd_seq_real_time_t &x(ev->time.time);
					struct timespec y;
					y.tv_nsec = apiData->lastTime.tv_nsec;
					y.tv_sec = apiData->lastTime.tv_sec;
					if (x.tv_nsec < y.tv_nsec) {
						int nsec = (y.tv_nsec - (int)x.tv_nsec) / 1000000000 + 1;
						y.tv_nsec -= 1000000000 * nsec;
						y.tv_sec += nsec;
					}
					if (x.tv_nsec - y.tv_nsec > 1000000000) {
						int nsec = ((int)x.tv_nsec - y.tv_nsec) / 1000000000;
						y.tv_nsec += 1000000000 * nsec;
						y.tv_sec -= nsec;
					}

					// Compute the time difference.
					time = (int)x.tv_sec - y.tv_sec + ((int)x.tv_nsec - y.tv_nsec)*1e-9;

					apiData->lastTime = ev->time.time;

					if (data->firstMessage == true)
						data->firstMessage = false;
					else
						message.timeStamp = time;
				}
				else {
#if defined(__RTMIDI_DEBUG__)
					std::cerr << "\nMidiInAlsa::alsaMidihwndr: event parsing error or not a MIDI event!\n\n";
#endif
				}
			}
		}

		snd_seq_free_event(ev);
		if (message.bytes.size() == 0 || continueSysex) continue;

		if (data->usingCallback) {
			RtMidiIn::RtMidiCallback callback = (RtMidiIn::RtMidiCallback) data->userCallback;
			callback(message.timeStamp, &message.bytes, data->userData);
		}
		else {
		  // As long as we haven't reached our queue size limit, push the message.
			if (!data->queue.push(message))
				std::cerr << "\nMidiInAlsa: message queue limit reached!!\n\n";
		}
	}

	if (buffer) free(buffer);
	snd_midi_event_free(apiData->coder);
	apiData->coder = 0;
	apiData->thread = apiData->dummy_thread_id;
	return 0;
}

MidiInAlsa::MidiInAlsa(const std::string &clientName, unsigned int queueSizeLimit)
	: MidiInApi(queueSizeLimit) {
	MidiInAlsa::initialize(clientName);
}

MidiInAlsa :: ~MidiInAlsa() {
  // Close a connection if it exists.
	MidiInAlsa::closePort();

	// Shutdown the input thread.
	AlsaMidiData *data = static_cast<AlsaMidiData *> (apiData_);
	if (inputData_.doInput) {
		inputData_.doInput = false;
		int res = write(data->trigger_fds[1], &inputData_.doInput, sizeof(inputData_.doInput));
		(void)res;
		if (!pthread_equal(data->thread, data->dummy_thread_id))
			pthread_join(data->thread, NULL);
	}

	// Cleanup.
	close(data->trigger_fds[0]);
	close(data->trigger_fds[1]);
	if (data->vport >= 0) snd_seq_delete_port(data->seq, data->vport);
#ifndef AVOID_TIMESTAMPING
	snd_seq_free_queue(data->seq, data->queue_id);
#endif
	snd_seq_close(data->seq);
	delete data;
}

void MidiInAlsa::initialize(const std::string& clientName) {
  // Set up the ALSA sequencer client.
	snd_seq_t *seq;
	int result = snd_seq_open(&seq, "default", SND_SEQ_OPEN_DUPLEX, SND_SEQ_NONBLOCK);
	if (result < 0) {
		errorString_ = "MidiInAlsa::initialize: error creating ALSA sequencer client object.";
		error(RtMidiError::DRIVER_ERROR, errorString_);
		return;
	}

	// Set client name.
	snd_seq_set_client_name(seq, clientName.c_str());

	// Save our api-specific connection information.
	AlsaMidiData *data = (AlsaMidiData *) new AlsaMidiData;
	data->seq = seq;
	data->portNum = -1;
	data->vport = -1;
	data->subscription = 0;
	data->dummy_thread_id = pthread_self();
	data->thread = data->dummy_thread_id;
	data->trigger_fds[0] = -1;
	data->trigger_fds[1] = -1;
	apiData_ = (void *)data;
	inputData_.apiData = (void *)data;

	if (pipe(data->trigger_fds) == -1) {
		errorString_ = "MidiInAlsa::initialize: error creating pipe objects.";
		error(RtMidiError::DRIVER_ERROR, errorString_);
		return;
	}

	// Create the input queue
#ifndef AVOID_TIMESTAMPING
	data->queue_id = snd_seq_alloc_named_queue(seq, "RtMidi Queue");
	// Set arbitrary tempo (mm=100) and resolution (240)
	snd_seq_queue_tempo_t *qtempo;
	snd_seq_queue_tempo_alloca(&qtempo);
	snd_seq_queue_tempo_set_tempo(qtempo, 600000);
	snd_seq_queue_tempo_set_ppq(qtempo, 240);
	snd_seq_set_queue_tempo(data->seq, data->queue_id, qtempo);
	snd_seq_drain_output(data->seq);
#endif
}

// This function is used to count or get the pinfo structure for a given port number.
unsigned int portInfo(snd_seq_t *seq, snd_seq_port_info_t *pinfo, unsigned int type, int portNumber) {
	snd_seq_client_info_t *cinfo;
	int client;
	int count = 0;
	snd_seq_client_info_alloca(&cinfo);

	snd_seq_client_info_set_client(cinfo, -1);
	while (snd_seq_query_next_client(seq, cinfo) >= 0) {
		client = snd_seq_client_info_get_client(cinfo);
		if (client == 0) continue;
		// Reset query info
		snd_seq_port_info_set_client(pinfo, client);
		snd_seq_port_info_set_port(pinfo, -1);
		while (snd_seq_query_next_port(seq, pinfo) >= 0) {
			unsigned int atyp = snd_seq_port_info_get_type(pinfo);
			if (((atyp & SND_SEQ_PORT_TYPE_MIDI_GENERIC) == 0) &&
				((atyp & SND_SEQ_PORT_TYPE_SYNTH) == 0) &&
				((atyp & SND_SEQ_PORT_TYPE_APPLICATION) == 0)) continue;

			unsigned int caps = snd_seq_port_info_get_capability(pinfo);
			if ((caps & type) != type) continue;
			if (count == portNumber) return 1;
			++count;
		}
	}

	// If a negative portNumber was used, return the port count.
	if (portNumber < 0) return count;
	return 0;
}

unsigned int MidiInAlsa::getPortCount() {
	snd_seq_port_info_t *pinfo;
	snd_seq_port_info_alloca(&pinfo);

	AlsaMidiData *data = static_cast<AlsaMidiData *> (apiData_);
	return portInfo(data->seq, pinfo, SND_SEQ_PORT_CAP_READ | SND_SEQ_PORT_CAP_SUBS_READ, -1);
}

std::string MidiInAlsa::getPortName(unsigned int portNumber) {
	snd_seq_client_info_t *cinfo;
	snd_seq_port_info_t *pinfo;
	snd_seq_client_info_alloca(&cinfo);
	snd_seq_port_info_alloca(&pinfo);

	std::string stringName;
	AlsaMidiData *data = static_cast<AlsaMidiData *> (apiData_);
	if (portInfo(data->seq, pinfo, SND_SEQ_PORT_CAP_READ | SND_SEQ_PORT_CAP_SUBS_READ, (int)portNumber)) {
		int cnum = snd_seq_port_info_get_client(pinfo);
		snd_seq_get_any_client_info(data->seq, cnum, cinfo);
		std::ostringstream os;
		os << snd_seq_client_info_get_name(cinfo);
		os << ":";
		os << snd_seq_port_info_get_name(pinfo);
		os << " ";                                    // These lines added to make sure devices are listed
		os << snd_seq_port_info_get_client(pinfo);  // with full portnames added to ensure individual device names
		os << ":";
		os << snd_seq_port_info_get_port(pinfo);
		stringName = os.str();
		return stringName;
	}

	// If we get here, we didn't find a match.
	errorString_ = "MidiInAlsa::getPortName: error looking for port name!";
	error(RtMidiError::WARNING, errorString_);
	return stringName;
}

void MidiInAlsa::openPort(unsigned int portNumber, const std::string &portName) {
	if (connected_) {
		errorString_ = "MidiInAlsa::openPort: a valid connection already exists!";
		error(RtMidiError::WARNING, errorString_);
		return;
	}

	unsigned int nSrc = this->getPortCount();
	if (nSrc < 1) {
		errorString_ = "MidiInAlsa::openPort: no MIDI input sources found!";
		error(RtMidiError::NO_DEVICES_FOUND, errorString_);
		return;
	}

	snd_seq_port_info_t *src_pinfo;
	snd_seq_port_info_alloca(&src_pinfo);
	AlsaMidiData *data = static_cast<AlsaMidiData *> (apiData_);
	if (portInfo(data->seq, src_pinfo, SND_SEQ_PORT_CAP_READ | SND_SEQ_PORT_CAP_SUBS_READ, (int)portNumber) == 0) {
		std::ostringstream ost;
		ost << "MidiInAlsa::openPort: the 'portNumber' argument (" << portNumber << ") is invalid.";
		errorString_ = ost.str();
		error(RtMidiError::INVALID_PARAMETER, errorString_);
		return;
	}

	snd_seq_addr_t sender, receiver;
	sender.client = snd_seq_port_info_get_client(src_pinfo);
	sender.port = snd_seq_port_info_get_port(src_pinfo);
	receiver.client = snd_seq_client_id(data->seq);

	snd_seq_port_info_t *pinfo;
	snd_seq_port_info_alloca(&pinfo);
	if (data->vport < 0) {
		snd_seq_port_info_set_client(pinfo, 0);
		snd_seq_port_info_set_port(pinfo, 0);
		snd_seq_port_info_set_capability(pinfo,
										 SND_SEQ_PORT_CAP_WRITE |
										 SND_SEQ_PORT_CAP_SUBS_WRITE);
		snd_seq_port_info_set_type(pinfo,
								   SND_SEQ_PORT_TYPE_MIDI_GENERIC |
								   SND_SEQ_PORT_TYPE_APPLICATION);
		snd_seq_port_info_set_midi_channels(pinfo, 16);
#ifndef AVOID_TIMESTAMPING
		snd_seq_port_info_set_timestamping(pinfo, 1);
		snd_seq_port_info_set_timestamp_real(pinfo, 1);
		snd_seq_port_info_set_timestamp_queue(pinfo, data->queue_id);
#endif
		snd_seq_port_info_set_name(pinfo, portName.c_str());
		data->vport = snd_seq_create_port(data->seq, pinfo);

		if (data->vport < 0) {
			errorString_ = "MidiInAlsa::openPort: ALSA error creating input port.";
			error(RtMidiError::DRIVER_ERROR, errorString_);
			return;
		}
		data->vport = snd_seq_port_info_get_port(pinfo);
	}

	receiver.port = data->vport;

	if (!data->subscription) {
	  // Make subscription
		if (snd_seq_port_subscribe_malloc(&data->subscription) < 0) {
			errorString_ = "MidiInAlsa::openPort: ALSA error allocation port subscription.";
			error(RtMidiError::DRIVER_ERROR, errorString_);
			return;
		}
		snd_seq_port_subscribe_set_sender(data->subscription, &sender);
		snd_seq_port_subscribe_set_dest(data->subscription, &receiver);
		if (snd_seq_subscribe_port(data->seq, data->subscription)) {
			snd_seq_port_subscribe_free(data->subscription);
			data->subscription = 0;
			errorString_ = "MidiInAlsa::openPort: ALSA error making port connection.";
			error(RtMidiError::DRIVER_ERROR, errorString_);
			return;
		}
	}

	if (inputData_.doInput == false) {
	  // Start the input queue
#ifndef AVOID_TIMESTAMPING
		snd_seq_start_queue(data->seq, data->queue_id, NULL);
		snd_seq_drain_output(data->seq);
#endif
	// Start our MIDI input thread.
		pthread_attr_t attr;
		pthread_attr_init(&attr);
		pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_JOINABLE);
		pthread_attr_setschedpolicy(&attr, SCHED_OTHER);

		inputData_.doInput = true;
		int err = pthread_create(&data->thread, &attr, alsaMidihwndr, &inputData_);
		pthread_attr_destroy(&attr);
		if (err) {
			snd_seq_unsubscribe_port(data->seq, data->subscription);
			snd_seq_port_subscribe_free(data->subscription);
			data->subscription = 0;
			inputData_.doInput = false;
			errorString_ = "MidiInAlsa::openPort: error starting MIDI input thread!";
			error(RtMidiError::THREAD_ERROR, errorString_);
			return;
		}
	}

	connected_ = true;
}

void MidiInAlsa::openVirtualPort(const std::string &portName) {
	AlsaMidiData *data = static_cast<AlsaMidiData *> (apiData_);
	if (data->vport < 0) {
		snd_seq_port_info_t *pinfo;
		snd_seq_port_info_alloca(&pinfo);
		snd_seq_port_info_set_capability(pinfo,
										 SND_SEQ_PORT_CAP_WRITE |
										 SND_SEQ_PORT_CAP_SUBS_WRITE);
		snd_seq_port_info_set_type(pinfo,
								   SND_SEQ_PORT_TYPE_MIDI_GENERIC |
								   SND_SEQ_PORT_TYPE_APPLICATION);
		snd_seq_port_info_set_midi_channels(pinfo, 16);
#ifndef AVOID_TIMESTAMPING
		snd_seq_port_info_set_timestamping(pinfo, 1);
		snd_seq_port_info_set_timestamp_real(pinfo, 1);
		snd_seq_port_info_set_timestamp_queue(pinfo, data->queue_id);
#endif
		snd_seq_port_info_set_name(pinfo, portName.c_str());
		data->vport = snd_seq_create_port(data->seq, pinfo);

		if (data->vport < 0) {
			errorString_ = "MidiInAlsa::openVirtualPort: ALSA error creating virtual port.";
			error(RtMidiError::DRIVER_ERROR, errorString_);
			return;
		}
		data->vport = snd_seq_port_info_get_port(pinfo);
	}

	if (inputData_.doInput == false) {
	  // Wait for old thread to stop, if still running
		if (!pthread_equal(data->thread, data->dummy_thread_id))
			pthread_join(data->thread, NULL);

		  // Start the input queue
#ifndef AVOID_TIMESTAMPING
		snd_seq_start_queue(data->seq, data->queue_id, NULL);
		snd_seq_drain_output(data->seq);
#endif
	// Start our MIDI input thread.
		pthread_attr_t attr;
		pthread_attr_init(&attr);
		pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_JOINABLE);
		pthread_attr_setschedpolicy(&attr, SCHED_OTHER);

		inputData_.doInput = true;
		int err = pthread_create(&data->thread, &attr, alsaMidihwndr, &inputData_);
		pthread_attr_destroy(&attr);
		if (err) {
			if (data->subscription) {
				snd_seq_unsubscribe_port(data->seq, data->subscription);
				snd_seq_port_subscribe_free(data->subscription);
				data->subscription = 0;
			}
			inputData_.doInput = false;
			errorString_ = "MidiInAlsa::openPort: error starting MIDI input thread!";
			error(RtMidiError::THREAD_ERROR, errorString_);
			return;
		}
	}
}

void MidiInAlsa::closePort(void) {
	AlsaMidiData *data = static_cast<AlsaMidiData *> (apiData_);

	if (connected_) {
		if (data->subscription) {
			snd_seq_unsubscribe_port(data->seq, data->subscription);
			snd_seq_port_subscribe_free(data->subscription);
			data->subscription = 0;
		}
		// Stop the input queue
#ifndef AVOID_TIMESTAMPING
		snd_seq_stop_queue(data->seq, data->queue_id, NULL);
		snd_seq_drain_output(data->seq);
#endif
		connected_ = false;
	}

	// Stop thread to avoid triggering the callback, while the port is intended to be closed
	if (inputData_.doInput) {
		inputData_.doInput = false;
		int res = write(data->trigger_fds[1], &inputData_.doInput, sizeof(inputData_.doInput));
		(void)res;
		if (!pthread_equal(data->thread, data->dummy_thread_id))
			pthread_join(data->thread, NULL);
	}
}

void MidiInAlsa::setClientName(const std::string &clientName) {

	AlsaMidiData *data = static_cast<AlsaMidiData *> (apiData_);
	snd_seq_set_client_name(data->seq, clientName.c_str());

}

void MidiInAlsa::setPortName(const std::string &portName) {
	AlsaMidiData *data = static_cast<AlsaMidiData *> (apiData_);
	snd_seq_port_info_t *pinfo;
	snd_seq_port_info_alloca(&pinfo);
	snd_seq_get_port_info(data->seq, data->vport, pinfo);
	snd_seq_port_info_set_name(pinfo, portName.c_str());
	snd_seq_set_port_info(data->seq, data->vport, pinfo);
}

//*********************************************************************//
//  API: LINUX ALSA
//  Class Definitions: MidiOutAlsa
//*********************************************************************//

MidiOutAlsa::MidiOutAlsa(const std::string &clientName) : MidiOutApi() {
	MidiOutAlsa::initialize(clientName);
}

MidiOutAlsa :: ~MidiOutAlsa() {
  // Close a connection if it exists.
	MidiOutAlsa::closePort();

	// Cleanup.
	AlsaMidiData *data = static_cast<AlsaMidiData *> (apiData_);
	if (data->vport >= 0) snd_seq_delete_port(data->seq, data->vport);
	if (data->coder) snd_midi_event_free(data->coder);
	if (data->buffer) free(data->buffer);
	snd_seq_close(data->seq);
	delete data;
}

void MidiOutAlsa::initialize(const std::string& clientName) {
  // Set up the ALSA sequencer client.
	snd_seq_t *seq;
	int result1 = snd_seq_open(&seq, "default", SND_SEQ_OPEN_OUTPUT, SND_SEQ_NONBLOCK);
	if (result1 < 0) {
		errorString_ = "MidiOutAlsa::initialize: error creating ALSA sequencer client object.";
		error(RtMidiError::DRIVER_ERROR, errorString_);
		return;
	}

	// Set client name.
	snd_seq_set_client_name(seq, clientName.c_str());

	// Save our api-specific connection information.
	AlsaMidiData *data = (AlsaMidiData *) new AlsaMidiData;
	data->seq = seq;
	data->portNum = -1;
	data->vport = -1;
	data->bufferSize = 32;
	data->coder = 0;
	data->buffer = 0;
	int result = snd_midi_event_new(data->bufferSize, &data->coder);
	if (result < 0) {
		delete data;
		errorString_ = "MidiOutAlsa::initialize: error initializing MIDI event parser!\n\n";
		error(RtMidiError::DRIVER_ERROR, errorString_);
		return;
	}
	data->buffer = (unsigned char *)malloc(data->bufferSize);
	if (data->buffer == NULL) {
		delete data;
		errorString_ = "MidiOutAlsa::initialize: error allocating buffer memory!\n\n";
		error(RtMidiError::MEMORY_ERROR, errorString_);
		return;
	}
	snd_midi_event_init(data->coder);
	apiData_ = (void *)data;
}

unsigned int MidiOutAlsa::getPortCount() {
	snd_seq_port_info_t *pinfo;
	snd_seq_port_info_alloca(&pinfo);

	AlsaMidiData *data = static_cast<AlsaMidiData *> (apiData_);
	return portInfo(data->seq, pinfo, SND_SEQ_PORT_CAP_WRITE | SND_SEQ_PORT_CAP_SUBS_WRITE, -1);
}

std::string MidiOutAlsa::getPortName(unsigned int portNumber) {
	snd_seq_client_info_t *cinfo;
	snd_seq_port_info_t *pinfo;
	snd_seq_client_info_alloca(&cinfo);
	snd_seq_port_info_alloca(&pinfo);

	std::string stringName;
	AlsaMidiData *data = static_cast<AlsaMidiData *> (apiData_);
	if (portInfo(data->seq, pinfo, SND_SEQ_PORT_CAP_WRITE | SND_SEQ_PORT_CAP_SUBS_WRITE, (int)portNumber)) {
		int cnum = snd_seq_port_info_get_client(pinfo);
		snd_seq_get_any_client_info(data->seq, cnum, cinfo);
		std::ostringstream os;
		os << snd_seq_client_info_get_name(cinfo);
		os << ":";
		os << snd_seq_port_info_get_name(pinfo);
		os << " ";                                    // These lines added to make sure devices are listed
		os << snd_seq_port_info_get_client(pinfo);  // with full portnames added to ensure individual device names
		os << ":";
		os << snd_seq_port_info_get_port(pinfo);
		stringName = os.str();
		return stringName;
	}

	// If we get here, we didn't find a match.
	errorString_ = "MidiOutAlsa::getPortName: error looking for port name!";
	error(RtMidiError::WARNING, errorString_);
	return stringName;
}

void MidiOutAlsa::openPort(unsigned int portNumber, const std::string &portName) {
	if (connected_) {
		errorString_ = "MidiOutAlsa::openPort: a valid connection already exists!";
		error(RtMidiError::WARNING, errorString_);
		return;
	}

	unsigned int nSrc = this->getPortCount();
	if (nSrc < 1) {
		errorString_ = "MidiOutAlsa::openPort: no MIDI output sources found!";
		error(RtMidiError::NO_DEVICES_FOUND, errorString_);
		return;
	}

	snd_seq_port_info_t *pinfo;
	snd_seq_port_info_alloca(&pinfo);
	AlsaMidiData *data = static_cast<AlsaMidiData *> (apiData_);
	if (portInfo(data->seq, pinfo, SND_SEQ_PORT_CAP_WRITE | SND_SEQ_PORT_CAP_SUBS_WRITE, (int)portNumber) == 0) {
		std::ostringstream ost;
		ost << "MidiOutAlsa::openPort: the 'portNumber' argument (" << portNumber << ") is invalid.";
		errorString_ = ost.str();
		error(RtMidiError::INVALID_PARAMETER, errorString_);
		return;
	}

	snd_seq_addr_t sender, receiver;
	receiver.client = snd_seq_port_info_get_client(pinfo);
	receiver.port = snd_seq_port_info_get_port(pinfo);
	sender.client = snd_seq_client_id(data->seq);

	if (data->vport < 0) {
		data->vport = snd_seq_create_simple_port(data->seq, portName.c_str(),
												 SND_SEQ_PORT_CAP_READ | SND_SEQ_PORT_CAP_SUBS_READ,
												 SND_SEQ_PORT_TYPE_MIDI_GENERIC | SND_SEQ_PORT_TYPE_APPLICATION);
		if (data->vport < 0) {
			errorString_ = "MidiOutAlsa::openPort: ALSA error creating output port.";
			error(RtMidiError::DRIVER_ERROR, errorString_);
			return;
		}
	}

	sender.port = data->vport;

	// Make subscription
	if (snd_seq_port_subscribe_malloc(&data->subscription) < 0) {
		snd_seq_port_subscribe_free(data->subscription);
		errorString_ = "MidiOutAlsa::openPort: error allocating port subscription.";
		error(RtMidiError::DRIVER_ERROR, errorString_);
		return;
	}
	snd_seq_port_subscribe_set_sender(data->subscription, &sender);
	snd_seq_port_subscribe_set_dest(data->subscription, &receiver);
	snd_seq_port_subscribe_set_time_update(data->subscription, 1);
	snd_seq_port_subscribe_set_time_real(data->subscription, 1);
	if (snd_seq_subscribe_port(data->seq, data->subscription)) {
		snd_seq_port_subscribe_free(data->subscription);
		errorString_ = "MidiOutAlsa::openPort: ALSA error making port connection.";
		error(RtMidiError::DRIVER_ERROR, errorString_);
		return;
	}

	connected_ = true;
}

void MidiOutAlsa::closePort(void) {
	if (connected_) {
		AlsaMidiData *data = static_cast<AlsaMidiData *> (apiData_);
		snd_seq_unsubscribe_port(data->seq, data->subscription);
		snd_seq_port_subscribe_free(data->subscription);
		data->subscription = 0;
		connected_ = false;
	}
}

void MidiOutAlsa::setClientName(const std::string &clientName) {

	AlsaMidiData *data = static_cast<AlsaMidiData *> (apiData_);
	snd_seq_set_client_name(data->seq, clientName.c_str());

}

void MidiOutAlsa::setPortName(const std::string &portName) {
	AlsaMidiData *data = static_cast<AlsaMidiData *> (apiData_);
	snd_seq_port_info_t *pinfo;
	snd_seq_port_info_alloca(&pinfo);
	snd_seq_get_port_info(data->seq, data->vport, pinfo);
	snd_seq_port_info_set_name(pinfo, portName.c_str());
	snd_seq_set_port_info(data->seq, data->vport, pinfo);
}

void MidiOutAlsa::openVirtualPort(const std::string &portName) {
	AlsaMidiData *data = static_cast<AlsaMidiData *> (apiData_);
	if (data->vport < 0) {
		data->vport = snd_seq_create_simple_port(data->seq, portName.c_str(),
												 SND_SEQ_PORT_CAP_READ | SND_SEQ_PORT_CAP_SUBS_READ,
												 SND_SEQ_PORT_TYPE_MIDI_GENERIC | SND_SEQ_PORT_TYPE_APPLICATION);

		if (data->vport < 0) {
			errorString_ = "MidiOutAlsa::openVirtualPort: ALSA error creating virtual port.";
			error(RtMidiError::DRIVER_ERROR, errorString_);
		}
	}
}

void MidiOutAlsa::sendMessage(const unsigned char *message, size_t size) {
	int result;
	AlsaMidiData *data = static_cast<AlsaMidiData *> (apiData_);
	unsigned int nBytes = static_cast<unsigned int> (size);
	if (nBytes > data->bufferSize) {
		data->bufferSize = nBytes;
		result = snd_midi_event_resize_buffer(data->coder, nBytes);
		if (result != 0) {
			errorString_ = "MidiOutAlsa::sendMessage: ALSA error resizing MIDI event buffer.";
			error(RtMidiError::DRIVER_ERROR, errorString_);
			return;
		}
		free(data->buffer);
		data->buffer = (unsigned char *)malloc(data->bufferSize);
		if (data->buffer == NULL) {
			errorString_ = "MidiOutAlsa::initialize: error allocating buffer memory!\n\n";
			error(RtMidiError::MEMORY_ERROR, errorString_);
			return;
		}
	}

	snd_seq_event_t ev;
	snd_seq_ev_clear(&ev);
	snd_seq_ev_set_source(&ev, data->vport);
	snd_seq_ev_set_subs(&ev);
	snd_seq_ev_set_direct(&ev);
	for (unsigned int i = 0; i < nBytes; ++i) data->buffer[i] = message[i];
	result = snd_midi_event_encode(data->coder, data->buffer, (long)nBytes, &ev);
	if (result < (int)nBytes) {
		errorString_ = "MidiOutAlsa::sendMessage: event parsing error!";
		error(RtMidiError::WARNING, errorString_);
		return;
	}

	// Send the event.
	result = snd_seq_event_output(data->seq, &ev);
	if (result < 0) {
		errorString_ = "MidiOutAlsa::sendMessage: error sending MIDI message to port.";
		error(RtMidiError::WARNING, errorString_);
		return;
	}
	snd_seq_drain_output(data->seq);
}

#endif // __LINUX_ALSA__


//*********************************************************************//
//  API: Windows Multimedia Library (MM)
//*********************************************************************//

// API information deciphered from:
//  - http://msdn.microsoft.com/library/default.asp?url=/library/en-us/multimed/htm/_win32_midi_reference.asp

// Thanks to Jean-Baptiste Berruchon for the sysex code.

#if defined(__WINDOWS_MM__)

// The Windows MM API is based on the use of a callback function for
// MIDI input.  We convert the system specific time stamps to delta
// time values.

// Windows MM MIDI header files.
#include <windows.h>
#include <mmsystem.h>

// Convert a null-terminated wide string or ANSI-encoded string to UTF-8.
static std::string ConvertToUTF8(const TCHAR *str) {
	std::string u8str;
	const WCHAR *wstr = L"";
#if defined( UNICODE ) || defined( _UNICODE )
	wstr = str;
#else
  // Convert from ANSI encoding to wide string
	int wlength = MultiByteToWideChar(CP_ACP, 0, str, -1, NULL, 0);
	std::wstring wstrtemp;
	if (wlength) {
		wstrtemp.assign(wlength - 1, 0);
		MultiByteToWideChar(CP_ACP, 0, str, -1, &wstrtemp[0], wlength);
		wstr = &wstrtemp[0];
	}
#endif
  // Convert from wide string to UTF-8
	int length = WideCharToMultiByte(CP_UTF8, 0, wstr, -1, NULL, 0, NULL, NULL);
	if (length) {
		u8str.assign(length - 1, 0);
		length = WideCharToMultiByte(CP_UTF8, 0, wstr, -1, &u8str[0], length, NULL, NULL);
	}
	return u8str;
}

#define  RT_SYSEX_BUFFER_SIZE 1024
#define  RT_SYSEX_BUFFER_COUNT 4

// A structure to hold variables related to the CoreMIDI API
// implementation.
struct WinMidiData {
	HMIDIIN inhwnd;    // hwnd to Midi Input Device
	HMIDIOUT outhwnd;  // hwnd to Midi Output Device
	DWORD lastTime;
	MidiInApi::MidiMessage message;
	LPMIDIHDR sysexBuffer[RT_SYSEX_BUFFER_COUNT];
	CRITICAL_SECTION _mutex; // [Patrice] see https://groups.google.com/forum/#!topic/mididev/6OUjHutMpEo
};

//*********************************************************************//
//  API: Windows MM
//  Class Definitions: MidiInWinMM
//*********************************************************************//

static void CALLBACK midiInputCallback(HMIDIIN /*hmin*/,
									   UINT inputStatus,
									   DWORD_PTR instancePtr,
									   DWORD_PTR midiMessage,
									   DWORD timestamp) {
	if (inputStatus != MIM_DATA && inputStatus != MIM_LONGDATA && inputStatus != MIM_LONGERROR) return;

	//MidiInApi::RtMidiInData *data = static_cast<MidiInApi::RtMidiInData *> (instancePtr);
	MidiInApi::RtMidiInData *data = (MidiInApi::RtMidiInData *)instancePtr;
	WinMidiData *apiData = static_cast<WinMidiData *> (data->apiData);

	// Calculate time stamp.
	if (data->firstMessage == true) {
		apiData->message.timeStamp = 0.0;
		data->firstMessage = false;
	}
	else apiData->message.timeStamp = (double)(timestamp - apiData->lastTime) * 0.001;

	if (inputStatus == MIM_DATA) { // Channel or system message

	  // Make sure the first byte is a status byte.
		unsigned char status = (unsigned char)(midiMessage & 0x000000FF);
		if (!(status & 0x80)) return;

		// Determine the number of bytes in the MIDI message.
		unsigned short nBytes = 1;
		if (status < 0xC0) nBytes = 3;
		else if (status < 0xE0) nBytes = 2;
		else if (status < 0xF0) nBytes = 3;
		else if (status == 0xF1) {
			if (data->ignoreFlags & 0x02) return;
			else nBytes = 2;
		}
		else if (status == 0xF2) nBytes = 3;
		else if (status == 0xF3) nBytes = 2;
		else if (status == 0xF8 && (data->ignoreFlags & 0x02)) {
		  // A MIDI timing tick message and we're ignoring it.
			return;
		}
		else if (status == 0xFE && (data->ignoreFlags & 0x04)) {
		  // A MIDI active sensing message and we're ignoring it.
			return;
		}

		// Copy bytes to our MIDI message.
		unsigned char *ptr = (unsigned char *)&midiMessage;
		for (int i = 0; i < nBytes; ++i) apiData->message.bytes.push_back(*ptr++);
	}
	else { // Sysex message ( MIM_LONGDATA or MIM_LONGERROR )
		MIDIHDR *sysex = (MIDIHDR *)midiMessage;
		if (!(data->ignoreFlags & 0x01) && inputStatus != MIM_LONGERROR) {
		  // Sysex message and we're not ignoring it
			for (int i = 0; i < (int)sysex->dwBytesRecorded; ++i)
				apiData->message.bytes.push_back(sysex->lpData[i]);
		}

		// The WinMM API requires that the sysex buffer be requeued after
		// input of each sysex message.  Even if we are ignoring sysex
		// messages, we still need to requeue the buffer in case the user
		// decides to not ignore sysex messages in the future.  However,
		// it seems that WinMM calls this function with an empty sysex
		// buffer when an application closes and in this case, we should
		// avoid requeueing it, else the computer suddenly reboots after
		// one or two minutes.
		if (apiData->sysexBuffer[sysex->dwUser]->dwBytesRecorded > 0) {
		  //if ( sysex->dwBytesRecorded > 0 ) {
			EnterCriticalSection(&(apiData->_mutex));
			MMRESULT result = midiInAddBuffer(apiData->inhwnd, apiData->sysexBuffer[sysex->dwUser], sizeof(MIDIHDR));
			LeaveCriticalSection(&(apiData->_mutex));
			if (result != MMSYSERR_NOERROR)
				std::cerr << "\nRtMidiIn::midiInputCallback: error sending sysex to Midi device!!\n\n";

			if (data->ignoreFlags & 0x01) return;
		}
		else return;
	}

	// Save the time of the last non-filtered message
	apiData->lastTime = timestamp;

	if (data->usingCallback) {
		RtMidiIn::RtMidiCallback callback = (RtMidiIn::RtMidiCallback) data->userCallback;
		callback(apiData->message.timeStamp, &apiData->message.bytes, data->userData);
	}
	else {
	  // As long as we haven't reached our queue size limit, push the message.
		if (!data->queue.push(apiData->message))
			std::cerr << "\nMidiInWinMM: message queue limit reached!!\n\n";
	}

	// Clear the vector for the next input message.
	apiData->message.bytes.clear();
}

MidiInWinMM::MidiInWinMM(const std::string &clientName, unsigned int queueSizeLimit)
	: MidiInApi(queueSizeLimit) {
	MidiInWinMM::initialize(clientName);
}

MidiInWinMM :: ~MidiInWinMM() {
  // Close a connection if it exists.
	MidiInWinMM::closePort();

	WinMidiData *data = static_cast<WinMidiData *> (apiData_);
	DeleteCriticalSection(&(data->_mutex));

	// Cleanup.
	delete data;
}

void MidiInWinMM::initialize(const std::string& /*clientName*/) {
  // We'll issue a warning here if no devices are available but not
  // throw an error since the user can plugin something later.
	unsigned int nDevices = midiInGetNumDevs();
	if (nDevices == 0) {
		errorString_ = "MidiInWinMM::initialize: no MIDI input devices currently available.";
		error(RtMidiError::WARNING, errorString_);
	}

	// Save our api-specific connection information.
	WinMidiData *data = (WinMidiData *) new WinMidiData;
	apiData_ = (void *)data;
	inputData_.apiData = (void *)data;
	data->message.bytes.clear();  // needs to be empty for first input message

	if (!InitializeCriticalSectionAndSpinCount(&(data->_mutex), 0x00000400)) {
		errorString_ = "MidiInWinMM::initialize: InitializeCriticalSectionAndSpinCount failed.";
		error(RtMidiError::WARNING, errorString_);
	}
}

void MidiInWinMM::openPort(unsigned int portNumber, const std::string &/*portName*/) {
	if (connected_) {
		errorString_ = "MidiInWinMM::openPort: a valid connection already exists!";
		error(RtMidiError::WARNING, errorString_);
		return;
	}

	unsigned int nDevices = midiInGetNumDevs();
	if (nDevices == 0) {
		errorString_ = "MidiInWinMM::openPort: no MIDI input sources found!";
		error(RtMidiError::NO_DEVICES_FOUND, errorString_);
		return;
	}

	if (portNumber >= nDevices) {
		std::ostringstream ost;
		ost << "MidiInWinMM::openPort: the 'portNumber' argument (" << portNumber << ") is invalid.";
		errorString_ = ost.str();
		error(RtMidiError::INVALID_PARAMETER, errorString_);
		return;
	}

	WinMidiData *data = static_cast<WinMidiData *> (apiData_);
	MMRESULT result = midiInOpen(&data->inhwnd,
								 portNumber,
								 (DWORD_PTR)&midiInputCallback,
								 (DWORD_PTR)&inputData_,
								 CALLBACK_FUNCTION);
	if (result != MMSYSERR_NOERROR) {
		errorString_ = "MidiInWinMM::openPort: error creating Windows MM MIDI input port.";
		error(RtMidiError::DRIVER_ERROR, errorString_);
		return;
	}

	// Allocate and init the sysex buffers.
	for (int i = 0; i < RT_SYSEX_BUFFER_COUNT; ++i) {
		data->sysexBuffer[i] = (MIDIHDR*) new char[sizeof(MIDIHDR)];
		data->sysexBuffer[i]->lpData = new char[RT_SYSEX_BUFFER_SIZE];
		data->sysexBuffer[i]->dwBufferLength = RT_SYSEX_BUFFER_SIZE;
		data->sysexBuffer[i]->dwUser = i; // We use the dwUser parameter as buffer indicator
		data->sysexBuffer[i]->dwFlags = 0;

		result = midiInPrepareHeader(data->inhwnd, data->sysexBuffer[i], sizeof(MIDIHDR));
		if (result != MMSYSERR_NOERROR) {
			midiInClose(data->inhwnd);
			data->inhwnd = 0;
			errorString_ = "MidiInWinMM::openPort: error starting Windows MM MIDI input port (PrepareHeader).";
			error(RtMidiError::DRIVER_ERROR, errorString_);
			return;
		}

		// Register the buffer.
		result = midiInAddBuffer(data->inhwnd, data->sysexBuffer[i], sizeof(MIDIHDR));
		if (result != MMSYSERR_NOERROR) {
			midiInClose(data->inhwnd);
			data->inhwnd = 0;
			errorString_ = "MidiInWinMM::openPort: error starting Windows MM MIDI input port (AddBuffer).";
			error(RtMidiError::DRIVER_ERROR, errorString_);
			return;
		}
	}

	result = midiInStart(data->inhwnd);
	if (result != MMSYSERR_NOERROR) {
		midiInClose(data->inhwnd);
		data->inhwnd = 0;
		errorString_ = "MidiInWinMM::openPort: error starting Windows MM MIDI input port.";
		error(RtMidiError::DRIVER_ERROR, errorString_);
		return;
	}

	connected_ = true;
}

void MidiInWinMM::openVirtualPort(const std::string &/*portName*/) {
  // This function cannot be implemented for the Windows MM MIDI API.
	errorString_ = "MidiInWinMM::openVirtualPort: cannot be implemented in Windows MM MIDI API!";
	error(RtMidiError::WARNING, errorString_);
}

void MidiInWinMM::closePort(void) {
	if (connected_) {
		WinMidiData *data = static_cast<WinMidiData *> (apiData_);
		EnterCriticalSection(&(data->_mutex));
		midiInReset(data->inhwnd);
		midiInStop(data->inhwnd);

		for (int i = 0; i < RT_SYSEX_BUFFER_COUNT; ++i) {
			int result = midiInUnprepareHeader(data->inhwnd, data->sysexBuffer[i], sizeof(MIDIHDR));
			delete[] data->sysexBuffer[i]->lpData;
			delete[] data->sysexBuffer[i];
			if (result != MMSYSERR_NOERROR) {
				midiInClose(data->inhwnd);
				data->inhwnd = 0;
				errorString_ = "MidiInWinMM::openPort: error closing Windows MM MIDI input port (midiInUnprepareHeader).";
				error(RtMidiError::DRIVER_ERROR, errorString_);
				return;
			}
		}

		midiInClose(data->inhwnd);
		data->inhwnd = 0;
		connected_ = false;
		LeaveCriticalSection(&(data->_mutex));
	}
}

void MidiInWinMM::setClientName(const std::string&) {

	errorString_ = "MidiInWinMM::setClientName: this function is not implemented for the WINDOWS_MM API!";
	error(RtMidiError::WARNING, errorString_);

}

void MidiInWinMM::setPortName(const std::string&) {

	errorString_ = "MidiInWinMM::setPortName: this function is not implemented for the WINDOWS_MM API!";
	error(RtMidiError::WARNING, errorString_);

}

unsigned int MidiInWinMM::getPortCount() {
	return midiInGetNumDevs();
}

std::string MidiInWinMM::getPortName(unsigned int portNumber) {
	std::string stringName;
	unsigned int nDevices = midiInGetNumDevs();
	if (portNumber >= nDevices) {
		std::ostringstream ost;
		ost << "MidiInWinMM::getPortName: the 'portNumber' argument (" << portNumber << ") is invalid.";
		errorString_ = ost.str();
		error(RtMidiError::WARNING, errorString_);
		return stringName;
	}

	MIDIINCAPS deviceCaps;
	midiInGetDevCaps(portNumber, &deviceCaps, sizeof(MIDIINCAPS));
	stringName = ConvertToUTF8(deviceCaps.szPname);

	// Next lines added to add the portNumber to the name so that
	// the device's names are sure to be listed with individual names
	// even when they have the same brand name
#ifndef RTMIDI_DO_NOT_ENSURE_UNIQUE_PORTNAMES
	std::ostringstream os;
	os << " ";
	os << portNumber;
	stringName += os.str();
#endif

	return stringName;
}

//*********************************************************************//
//  API: Windows MM
//  Class Definitions: MidiOutWinMM
//*********************************************************************//

MidiOutWinMM::MidiOutWinMM(const std::string &clientName) : MidiOutApi() {
	MidiOutWinMM::initialize(clientName);
}

MidiOutWinMM :: ~MidiOutWinMM() {
  // Close a connection if it exists.
	MidiOutWinMM::closePort();

	// Cleanup.
	WinMidiData *data = static_cast<WinMidiData *> (apiData_);
	delete data;
}

void MidiOutWinMM::initialize(const std::string& /*clientName*/) {
  // We'll issue a warning here if no devices are available but not
  // throw an error since the user can plug something in later.
	unsigned int nDevices = midiOutGetNumDevs();
	if (nDevices == 0) {
		errorString_ = "MidiOutWinMM::initialize: no MIDI output devices currently available.";
		error(RtMidiError::WARNING, errorString_);
	}

	// Save our api-specific connection information.
	WinMidiData *data = (WinMidiData *) new WinMidiData;
	apiData_ = (void *)data;
}

unsigned int MidiOutWinMM::getPortCount() {
	return midiOutGetNumDevs();
}

std::string MidiOutWinMM::getPortName(unsigned int portNumber) {
	std::string stringName;
	unsigned int nDevices = midiOutGetNumDevs();
	if (portNumber >= nDevices) {
		std::ostringstream ost;
		ost << "MidiOutWinMM::getPortName: the 'portNumber' argument (" << portNumber << ") is invalid.";
		errorString_ = ost.str();
		error(RtMidiError::WARNING, errorString_);
		return stringName;
	}

	MIDIOUTCAPS deviceCaps;
	midiOutGetDevCaps(portNumber, &deviceCaps, sizeof(MIDIOUTCAPS));
	stringName = ConvertToUTF8(deviceCaps.szPname);

	// Next lines added to add the portNumber to the name so that
	// the device's names are sure to be listed with individual names
	// even when they have the same brand name
	std::ostringstream os;
#ifndef RTMIDI_DO_NOT_ENSURE_UNIQUE_PORTNAMES
	os << " ";
	os << portNumber;
	stringName += os.str();
#endif

	return stringName;
}

void MidiOutWinMM::openPort(unsigned int portNumber, const std::string &/*portName*/) {
	if (connected_) {
		errorString_ = "MidiOutWinMM::openPort: a valid connection already exists!";
		error(RtMidiError::WARNING, errorString_);
		return;
	}

	unsigned int nDevices = midiOutGetNumDevs();
	if (nDevices < 1) {
		errorString_ = "MidiOutWinMM::openPort: no MIDI output destinations found!";
		error(RtMidiError::NO_DEVICES_FOUND, errorString_);
		return;
	}

	if (portNumber >= nDevices) {
		std::ostringstream ost;
		ost << "MidiOutWinMM::openPort: the 'portNumber' argument (" << portNumber << ") is invalid.";
		errorString_ = ost.str();
		error(RtMidiError::INVALID_PARAMETER, errorString_);
		return;
	}

	WinMidiData *data = static_cast<WinMidiData *> (apiData_);
	MMRESULT result = midiOutOpen(&data->outhwnd,
								  portNumber,
								  (DWORD)NULL,
								  (DWORD)NULL,
								  CALLBACK_NULL);
	if (result != MMSYSERR_NOERROR) {
		errorString_ = "MidiOutWinMM::openPort: error creating Windows MM MIDI output port.";
		error(RtMidiError::DRIVER_ERROR, errorString_);
		return;
	}

	connected_ = true;
}

void MidiOutWinMM::closePort(void) {
	if (connected_) {
		WinMidiData *data = static_cast<WinMidiData *> (apiData_);
		midiOutReset(data->outhwnd);
		midiOutClose(data->outhwnd);
		data->outhwnd = 0;
		connected_ = false;
	}
}

void MidiOutWinMM::setClientName(const std::string&) {

	errorString_ = "MidiOutWinMM::setClientName: this function is not implemented for the WINDOWS_MM API!";
	error(RtMidiError::WARNING, errorString_);

}

void MidiOutWinMM::setPortName(const std::string&) {

	errorString_ = "MidiOutWinMM::setPortName: this function is not implemented for the WINDOWS_MM API!";
	error(RtMidiError::WARNING, errorString_);

}

void MidiOutWinMM::openVirtualPort(const std::string &/*portName*/) {
  // This function cannot be implemented for the Windows MM MIDI API.
	errorString_ = "MidiOutWinMM::openVirtualPort: cannot be implemented in Windows MM MIDI API!";
	error(RtMidiError::WARNING, errorString_);
}

void MidiOutWinMM::sendMessage(const unsigned char *message, size_t size) {
	if (!connected_) return;

	unsigned int nBytes = static_cast<unsigned int>(size);
	if (nBytes == 0) {
		errorString_ = "MidiOutWinMM::sendMessage: message argument is empty!";
		error(RtMidiError::WARNING, errorString_);
		return;
	}

	MMRESULT result;
	WinMidiData *data = static_cast<WinMidiData *> (apiData_);
	if (message[0] == 0xF0) { // Sysex message

	  // Allocate buffer for sysex data.
		char *buffer = (char *)malloc(nBytes);
		if (buffer == NULL) {
			errorString_ = "MidiOutWinMM::sendMessage: error allocating sysex message memory!";
			error(RtMidiError::MEMORY_ERROR, errorString_);
			return;
		}

		// Copy data to buffer.
		for (unsigned int i = 0; i < nBytes; ++i) buffer[i] = message[i];

		// Create and prepare MIDIHDR structure.
		MIDIHDR sysex;
		sysex.lpData = (LPSTR)buffer;
		sysex.dwBufferLength = nBytes;
		sysex.dwFlags = 0;
		result = midiOutPrepareHeader(data->outhwnd, &sysex, sizeof(MIDIHDR));
		if (result != MMSYSERR_NOERROR) {
			free(buffer);
			errorString_ = "MidiOutWinMM::sendMessage: error preparing sysex header.";
			error(RtMidiError::DRIVER_ERROR, errorString_);
			return;
		}

		// Send the message.
		result = midiOutLongMsg(data->outhwnd, &sysex, sizeof(MIDIHDR));
		if (result != MMSYSERR_NOERROR) {
			free(buffer);
			errorString_ = "MidiOutWinMM::sendMessage: error sending sysex message.";
			error(RtMidiError::DRIVER_ERROR, errorString_);
			return;
		}

		// Unprepare the buffer and MIDIHDR.
		while (MIDIERR_STILLPLAYING == midiOutUnprepareHeader(data->outhwnd, &sysex, sizeof(MIDIHDR))) Sleep(1);
		free(buffer);
	}
	else { // Channel or system message.

	  // Make sure the message size isn't too big.
		if (nBytes > 3) {
			errorString_ = "MidiOutWinMM::sendMessage: message size is greater than 3 bytes (and not sysex)!";
			error(RtMidiError::WARNING, errorString_);
			return;
		}

		// Pack MIDI bytes into double word.
		DWORD packet;
		unsigned char *ptr = (unsigned char *)&packet;
		for (unsigned int i = 0; i < nBytes; ++i) {
			*ptr = message[i];
			++ptr;
		}

		// Send the message immediately.
		result = midiOutShortMsg(data->outhwnd, packet);
		if (result != MMSYSERR_NOERROR) {
			errorString_ = "MidiOutWinMM::sendMessage: error sending MIDI message.";
			error(RtMidiError::DRIVER_ERROR, errorString_);
		}
	}
}

#endif  // __WINDOWS_MM__


//*********************************************************************//
//  API: UNIX JACK
//
//  Written primarily by Alexander Svetalkin, with updates for delta
//  time by Gary Scavone, April 2011.
//
//  *********************************************************************//

#if defined(__UNIX_JACK__)

// JACK header files
#include <jack/jack.h>
#include <jack/midiport.h>
#include <jack/ringbuffer.h>
#ifdef HAVE_SEMAPHORE
#include <semaphore.h>
#endif

#define JACK_RINGBUFFER_SIZE 16384 // Default size for ringbuffer

struct JackMidiData {
	jack_client_t *client;
	jack_port_t *port;
	jack_ringbuffer_t *buffSize;
	jack_ringbuffer_t *buffMessage;
	jack_time_t lastTime;
#ifdef HAVE_SEMAPHORE
	sem_t sem_cleanup;
	sem_t sem_needpost;
#endif
	MidiInApi::RtMidiInData *rtMidiIn;
};

//*********************************************************************//
//  API: JACK
//  Class Definitions: MidiInJack
//*********************************************************************//

static int jackProcessIn(jack_nframes_t nframes, void *arg) {
	JackMidiData *jData = (JackMidiData *)arg;
	MidiInApi::RtMidiInData *rtData = jData->rtMidiIn;
	jack_midi_event_t event;
	jack_time_t time;

	// Is port created?
	if (jData->port == NULL) return 0;

	void *buff = jack_port_get_buffer(jData->port, nframes);
	bool& continueSysex = rtData->continueSysex;
	unsigned char& ignoreFlags = rtData->ignoreFlags;

	// We have midi events in buffer
	int evCount = jack_midi_get_event_count(buff);
	for (int j = 0; j < evCount; j++) {
		MidiInApi::MidiMessage& message = rtData->message;
		jack_midi_event_get(&event, buff, j);

		// Compute the delta time.
		time = jack_get_time();
		if (rtData->firstMessage == true) {
			message.timeStamp = 0.0;
			rtData->firstMessage = false;
		}
		else
			message.timeStamp = (time - jData->lastTime) * 0.000001;

		jData->lastTime = time;

		if (!continueSysex)
			message.bytes.clear();

		if (!((continueSysex || event.buffer[0] == 0xF0) && (ignoreFlags & 0x01))) {
		  // Unless this is a (possibly continued) SysEx message and we're ignoring SysEx,
		  // copy the event buffer into the MIDI message struct.
			for (unsigned int i = 0; i < event.size; i++)
				message.bytes.push_back(event.buffer[i]);
		}

		switch (event.buffer[0]) {
			case 0xF0:
			  // Start of a SysEx message
				continueSysex = event.buffer[event.size - 1] != 0xF7;
				if (ignoreFlags & 0x01) continue;
				break;
			case 0xF1:
			case 0xF8:
			  // MIDI Time Code or Timing Clock message
				if (ignoreFlags & 0x02) continue;
				break;
			case 0xFE:
			  // Active Sensing message
				if (ignoreFlags & 0x04) continue;
				break;
			default:
				if (continueSysex) {
				  // Continuation of a SysEx message
					continueSysex = event.buffer[event.size - 1] != 0xF7;
					if (ignoreFlags & 0x01) continue;
				}
				// All other MIDI messages
		}

		if (!continueSysex) {
		  // If not a continuation of a SysEx message,
		  // invoke the user callback function or queue the message.
			if (rtData->usingCallback) {
				RtMidiIn::RtMidiCallback callback = (RtMidiIn::RtMidiCallback) rtData->userCallback;
				callback(message.timeStamp, &message.bytes, rtData->userData);
			}
			else {
			  // As long as we haven't reached our queue size limit, push the message.
				if (!rtData->queue.push(message))
					std::cerr << "\nMidiInJack: message queue limit reached!!\n\n";
			}
		}
	}

	return 0;
}

MidiInJack::MidiInJack(const std::string &clientName, unsigned int queueSizeLimit)
	: MidiInApi(queueSizeLimit) {
	MidiInJack::initialize(clientName);
}

void MidiInJack::initialize(const std::string& clientName) {
	JackMidiData *data = new JackMidiData;
	apiData_ = (void *)data;

	data->rtMidiIn = &inputData_;
	data->port = NULL;
	data->client = NULL;
	this->clientName = clientName;

	connect();
}

void MidiInJack::connect() {
	JackMidiData *data = static_cast<JackMidiData *> (apiData_);
	if (data->client)
		return;

	  // Initialize JACK client
	if ((data->client = jack_client_open(clientName.c_str(), JackNoStartServer, NULL)) == 0) {
		errorString_ = "MidiInJack::initialize: JACK server not running?";
		error(RtMidiError::WARNING, errorString_);
		return;
	}

	jack_set_process_callback(data->client, jackProcessIn, data);
	jack_activate(data->client);
}

MidiInJack :: ~MidiInJack() {
	JackMidiData *data = static_cast<JackMidiData *> (apiData_);
	MidiInJack::closePort();

	if (data->client)
		jack_client_close(data->client);
	delete data;
}

void MidiInJack::openPort(unsigned int portNumber, const std::string &portName) {
	JackMidiData *data = static_cast<JackMidiData *> (apiData_);

	connect();

	// Creating new port
	if (data->port == NULL)
		data->port = jack_port_register(data->client, portName.c_str(),
										JACK_DEFAULT_MIDI_TYPE, JackPortIsInput, 0);

	if (data->port == NULL) {
		errorString_ = "MidiInJack::openPort: JACK error creating port";
		error(RtMidiError::DRIVER_ERROR, errorString_);
		return;
	}

	// Connecting to the output
	std::string name = getPortName(portNumber);
	jack_connect(data->client, name.c_str(), jack_port_name(data->port));

	connected_ = true;
}

void MidiInJack::openVirtualPort(const std::string &portName) {
	JackMidiData *data = static_cast<JackMidiData *> (apiData_);

	connect();
	if (data->port == NULL)
		data->port = jack_port_register(data->client, portName.c_str(),
										JACK_DEFAULT_MIDI_TYPE, JackPortIsInput, 0);

	if (data->port == NULL) {
		errorString_ = "MidiInJack::openVirtualPort: JACK error creating virtual port";
		error(RtMidiError::DRIVER_ERROR, errorString_);
	}
}

unsigned int MidiInJack::getPortCount() {
	int count = 0;
	JackMidiData *data = static_cast<JackMidiData *> (apiData_);
	connect();
	if (!data->client)
		return 0;

	  // List of available ports
	const char **ports = jack_get_ports(data->client, NULL, JACK_DEFAULT_MIDI_TYPE, JackPortIsOutput);

	if (ports == NULL) return 0;
	while (ports[count] != NULL)
		count++;

	free(ports);

	return count;
}

std::string MidiInJack::getPortName(unsigned int portNumber) {
	JackMidiData *data = static_cast<JackMidiData *> (apiData_);
	std::string retStr("");

	connect();

	// List of available ports
	const char **ports = jack_get_ports(data->client, NULL,
										JACK_DEFAULT_MIDI_TYPE, JackPortIsOutput);

   // Check port validity
	if (ports == NULL) {
		errorString_ = "MidiInJack::getPortName: no ports available!";
		error(RtMidiError::WARNING, errorString_);
		return retStr;
	}

	unsigned int i;
	for (i = 0; i < portNumber && ports[i]; i++) {}
	if (i < portNumber || !ports[portNumber]) {
		std::ostringstream ost;
		ost << "MidiInJack::getPortName: the 'portNumber' argument (" << portNumber << ") is invalid.";
		errorString_ = ost.str();
		error(RtMidiError::WARNING, errorString_);
	}
	else retStr.assign(ports[portNumber]);

	jack_free(ports);
	return retStr;
}

void MidiInJack::closePort() {
	JackMidiData *data = static_cast<JackMidiData *> (apiData_);

	if (data->port == NULL) return;
	jack_port_unregister(data->client, data->port);
	data->port = NULL;

	connected_ = false;
}

void MidiInJack::setClientName(const std::string&) {

	errorString_ = "MidiInJack::setClientName: this function is not implemented for the UNIX_JACK API!";
	error(RtMidiError::WARNING, errorString_);

}

void MidiInJack::setPortName(const std::string &portName) {
	JackMidiData *data = static_cast<JackMidiData *> (apiData_);
#ifdef JACK_HAS_PORT_RENAME
	jack_port_rename(data->client, data->port, portName.c_str());
#else
	jack_port_set_name(data->port, portName.c_str());
#endif
}

//*********************************************************************//
//  API: JACK
//  Class Definitions: MidiOutJack
//*********************************************************************//

// Jack process callback
static int jackProcessOut(jack_nframes_t nframes, void *arg) {
	JackMidiData *data = (JackMidiData *)arg;
	jack_midi_data_t *midiData;
	int space;

	// Is port created?
	if (data->port == NULL) return 0;

	void *buff = jack_port_get_buffer(data->port, nframes);
	jack_midi_clear_buffer(buff);

	while (jack_ringbuffer_read_space(data->buffSize) > 0) {
		jack_ringbuffer_read(data->buffSize, (char *)&space, (size_t) sizeof(space));
		midiData = jack_midi_event_reserve(buff, 0, space);

		jack_ringbuffer_read(data->buffMessage, (char *)midiData, (size_t)space);
	}

#ifdef HAVE_SEMAPHORE
	if (!sem_trywait(&data->sem_needpost))
		sem_post(&data->sem_cleanup);
#endif

	return 0;
}

MidiOutJack::MidiOutJack(const std::string &clientName) : MidiOutApi() {
	MidiOutJack::initialize(clientName);
}

void MidiOutJack::initialize(const std::string& clientName) {
	JackMidiData *data = new JackMidiData;
	apiData_ = (void *)data;

	data->port = NULL;
	data->client = NULL;
#ifdef HAVE_SEMAPHORE
	sem_init(&data->sem_cleanup, 0, 0);
	sem_init(&data->sem_needpost, 0, 0);
#endif
	this->clientName = clientName;

	connect();
}

void MidiOutJack::connect() {
	JackMidiData *data = static_cast<JackMidiData *> (apiData_);
	if (data->client)
		return;

	  // Initialize output ringbuffers
	data->buffSize = jack_ringbuffer_create(JACK_RINGBUFFER_SIZE);
	data->buffMessage = jack_ringbuffer_create(JACK_RINGBUFFER_SIZE);

	// Initialize JACK client
	if ((data->client = jack_client_open(clientName.c_str(), JackNoStartServer, NULL)) == 0) {
		errorString_ = "MidiOutJack::initialize: JACK server not running?";
		error(RtMidiError::WARNING, errorString_);
		return;
	}

	jack_set_process_callback(data->client, jackProcessOut, data);
	jack_activate(data->client);
}

MidiOutJack :: ~MidiOutJack() {
	JackMidiData *data = static_cast<JackMidiData *> (apiData_);
	MidiOutJack::closePort();

	// Cleanup
	jack_ringbuffer_free(data->buffSize);
	jack_ringbuffer_free(data->buffMessage);
	if (data->client) {
		jack_client_close(data->client);
	}

#ifdef HAVE_SEMAPHORE
	sem_destroy(&data->sem_cleanup);
	sem_destroy(&data->sem_needpost);
#endif

	delete data;
}

void MidiOutJack::openPort(unsigned int portNumber, const std::string &portName) {
	JackMidiData *data = static_cast<JackMidiData *> (apiData_);

	connect();

	// Creating new port
	if (data->port == NULL)
		data->port = jack_port_register(data->client, portName.c_str(),
										JACK_DEFAULT_MIDI_TYPE, JackPortIsOutput, 0);

	if (data->port == NULL) {
		errorString_ = "MidiOutJack::openPort: JACK error creating port";
		error(RtMidiError::DRIVER_ERROR, errorString_);
		return;
	}

	// Connecting to the output
	std::string name = getPortName(portNumber);
	jack_connect(data->client, jack_port_name(data->port), name.c_str());

	connected_ = true;
}

void MidiOutJack::openVirtualPort(const std::string &portName) {
	JackMidiData *data = static_cast<JackMidiData *> (apiData_);

	connect();
	if (data->port == NULL)
		data->port = jack_port_register(data->client, portName.c_str(),
										JACK_DEFAULT_MIDI_TYPE, JackPortIsOutput, 0);

	if (data->port == NULL) {
		errorString_ = "MidiOutJack::openVirtualPort: JACK error creating virtual port";
		error(RtMidiError::DRIVER_ERROR, errorString_);
	}
}

unsigned int MidiOutJack::getPortCount() {
	int count = 0;
	JackMidiData *data = static_cast<JackMidiData *> (apiData_);
	connect();
	if (!data->client)
		return 0;

	  // List of available ports
	const char **ports = jack_get_ports(data->client, NULL,
										JACK_DEFAULT_MIDI_TYPE, JackPortIsInput);

	if (ports == NULL) return 0;
	while (ports[count] != NULL)
		count++;

	free(ports);

	return count;
}

std::string MidiOutJack::getPortName(unsigned int portNumber) {
	JackMidiData *data = static_cast<JackMidiData *> (apiData_);
	std::string retStr("");

	connect();

	// List of available ports
	const char **ports = jack_get_ports(data->client, NULL,
										JACK_DEFAULT_MIDI_TYPE, JackPortIsInput);

   // Check port validity
	if (ports == NULL) {
		errorString_ = "MidiOutJack::getPortName: no ports available!";
		error(RtMidiError::WARNING, errorString_);
		return retStr;
	}

	if (ports[portNumber] == NULL) {
		std::ostringstream ost;
		ost << "MidiOutJack::getPortName: the 'portNumber' argument (" << portNumber << ") is invalid.";
		errorString_ = ost.str();
		error(RtMidiError::WARNING, errorString_);
	}
	else retStr.assign(ports[portNumber]);

	free(ports);
	return retStr;
}

void MidiOutJack::closePort() {
	JackMidiData *data = static_cast<JackMidiData *> (apiData_);

	if (data->port == NULL) return;

#ifdef HAVE_SEMAPHORE
	struct timespec ts;
	if (clock_gettime(CLOCK_REALTIME, &ts) != -1) {
		ts.tv_sec += 1; // wait max one second
		sem_post(&data->sem_needpost);
		sem_timedwait(&data->sem_cleanup, &ts);
	}
#endif

	jack_port_unregister(data->client, data->port);
	data->port = NULL;

	connected_ = false;
}

void MidiOutJack::setClientName(const std::string&) {

	errorString_ = "MidiOutJack::setClientName: this function is not implemented for the UNIX_JACK API!";
	error(RtMidiError::WARNING, errorString_);

}

void MidiOutJack::setPortName(const std::string &portName) {
	JackMidiData *data = static_cast<JackMidiData *> (apiData_);
#ifdef JACK_HAS_PORT_RENAME
	jack_port_rename(data->client, data->port, portName.c_str());
#else
	jack_port_set_name(data->port, portName.c_str());
#endif
}

void MidiOutJack::sendMessage(const unsigned char *message, size_t size) {
	int nBytes = static_cast<int>(size);
	JackMidiData *data = static_cast<JackMidiData *> (apiData_);

	// Write full message to buffer
	jack_ringbuffer_write(data->buffMessage, (const char *)message, nBytes);
	jack_ringbuffer_write(data->buffSize, (char *)&nBytes, sizeof(nBytes));
}

#endif  // __UNIX_JACK__




















































~-----------------------------------------------~
C:\Users\Josh\Documents\Visual Studio 2017\Projects\Sorting\Sorting\sounds.cpp
~-----------------------------------------------~
#include "sounds.h"

#include <map>
#include <algorithm>

#define X(x) { Instrument::x, L#x },
std::map<unsigned, std::wstring> InstrumentNames = {
	X(Acoustic_Grand_Piano)X(Bright_Acoustic_Piano)X(Electric_Grand_Piano)X(Honkytonk_Piano)X(Electric_Piano_1)X(Electric_Piano_2)X(Harpsichord)X(Clavi)
	X(Celesta)	X(Glockenspiel)X(Music_Box)X(Vibraphone)X(Marimba)X(Xylophone)X(Tubular_Bells)X(Dulcimer)
	X(Drawbar_Organ)X(Percussive_Organ)X(Rock_Organ)X(Church_Organ)X(Reed_Organ)X(Accordion)X(Harmonica)X(Tango_Accordion)
	X(Acoustic_Guitar_nylon)X(Acoustic_Guitar_steel)X(Electric_Guitar_jazz)X(Electric_Guitar_clean)X(Electric_Guitar_muted)X(Overdriven_Guitar)X(Distortion_Guitar)X(Guitar_harmonics)
	X(Acoustic_Bass)X(Electric_Bass_finger)X(Electric_Bass_pick)X(Fretless_Bass)X(Slap_Bass_1)X(Slap_Bass_2)X(Synth_Bass_1)X(Synth_Bass_2)
	X(Violin)X(Viola)X(Cello)X(Contrabass)X(Tremolo_Strings)X(Pizzicato_Strings)X(Orchestral_Harp)X(Timpani)
	X(String_Ensemble_1)X(String_Ensemble_2)X(SynthStrings_1)X(SynthStrings_2)X(Choir_Aahs)X(Voice_Oohs)X(Synth_Voice)X(Orchestra_Hit)
	X(Trumpet)X(Trombone)X(Tuba)X(Muted_Trumpet)X(French_Horn)X(Brass_Section)X(SynthBrass_1)X(SynthBrass_2)
	X(Soprano_Sax)X(Alto_Sax)X(Tenor_Sax)X(Baritone_Sax)X(Oboe)X(English_Horn)X(Bassoon)X(Clarinet)
	X(Piccolo)X(Flute)X(Recorder)X(Pan_Flute)X(Blown_Bottle)X(Shakuhachi)X(Whistle)X(Ocarina)
	X(Lead_1_square)X(Lead_2_sawtooth)X(Lead_3_calliope)X(Lead_4_chiff)X(Lead_5_charang)X(Lead_6_voice)X(Lead_7_fifths)X(Lead_8_bass_and_lead)
	X(Pad_1_new_age)X(Pad_2_warm)X(Pad_3_polysynth)X(Pad_4_choir)X(Pad_5_bowed)X(Pad_6_metallic)X(Pad_7_halo)X(Pad_8_sweep)
	X(FX_1_rain)X(FX_2_soundtrack)X(FX_3_crystal)X(FX_4_atmosphere)X(FX_5_brightness)X(FX_6_goblins)X(FX_7_echoes)X(FX_8_sci_fi)
	X(Sitar)X(Banjo)X(Shamisen)X(Koto)X(Kalimba)X(Bag_pipe)X(Fiddle)X(Shanai)
	X(Tinkle_Bell)X(Agogo)X(Steel_Drums)X(Woodblock)X(Taiko_Drum)X(Melodic_Tom)X(Synth_Drum)X(Reverse_Cymbal)
	X(Guitar_Fret_Noise)X(Breath_Noise)X(Seashore)X(Bird_Tweet)X(Telephone_Ring)X(Helicopter)X(Applause)X(Gunshot)
};
#undef X

MIDISoundPlayer::MIDISoundPlayer(int instrument) {
	if ((port_count = midiout.getPortCount())) {
		if (!midiout.isPortOpen())
			midiout.openPort(0);
	}

	selected_instrument = instrument;
	std::vector<unsigned char> message(3);
	message[0] = PROGRAM_CHANGE;
	message[1] = selected_instrument;
	midiout.sendMessage(&message);
}

MIDISoundPlayer::~MIDISoundPlayer() {
	if (!midiout.isPortOpen()) midiout.closePort();
}

void MIDISoundPlayer::SetInstrument(unsigned char instrument) {
	selected_instrument = instrument;
	std::vector<unsigned char> message(3);
	message[0] = PROGRAM_CHANGE;
	message[1] = instrument;
	midiout.sendMessage(&message);
}

int MIDISoundPlayer::GetInstrument() {
	return selected_instrument;
}

std::wstring MIDISoundPlayer::GetInstrumentName() {
	return GetInstrumentName(selected_instrument);
}

std::wstring MIDISoundPlayer::GetInstrumentName(int id) {
	return InstrumentNames[id];
}

void MIDISoundPlayer::SetVolume(char volume) {
	std::vector<unsigned char> message(3);
	message[0] = CONTROL_CHANGE;
	message[1] = CONTROL_CHANGE_VOLUME;
	message[2] = (unsigned char)volume;
	midiout.sendMessage(&message);
}

void MIDISoundPlayer::PlayNote(char note, char on_velocity, char off_velocity, int duration) {
	std::thread a{ [](MIDISoundPlayer* midi, char note, char on_velocity, char off_velocity, int duration) {
		midi->NoteOn(note, on_velocity);
		std::this_thread::sleep_for(std::chrono::milliseconds(duration));
		midi->NoteOff(note, off_velocity);
	}, this, note, on_velocity, off_velocity, duration };
	a.detach();
}

void MIDISoundPlayer::PlayNotes(const std::vector<char>& notes, char on_velocity, char off_velocity, int duration) {
	std::thread a{[](MIDISoundPlayer* midi, std::vector<char> notes, char on_velocity, char off_velocity, int duration) {
		for (auto & note : notes) midi->NoteOn(note, on_velocity);
		std::this_thread::sleep_for(std::chrono::milliseconds(duration));
		for (auto & note : notes) midi->NoteOff(note, off_velocity);
	}, this, std::vector<char>(notes), on_velocity, off_velocity, duration};
	a.detach();
}

void MIDISoundPlayer::StopAllNotes() {
	std::vector<unsigned char> message(3);
	message[0] = CONTROL_CHANGE;
	message[1] = CONTROL_CHANGE_ALL_NOTES_OFF;
	midiout.sendMessage(&message);
}

void MIDISoundPlayer::NoteOn(char note, char velocity) {
	std::vector<unsigned char> message(3);
	message[0] = NOTE_ON;
	message[1] = (unsigned char)note;
	message[2] = (unsigned char)velocity;
	midiout.sendMessage(&message);
}

void MIDISoundPlayer::NoteOff(char note, char velocity) {
	std::vector<unsigned char> message(3);
	message[0] = NOTE_OFF;
	message[1] = (unsigned char)note;
	message[2] = (unsigned char)velocity;
	midiout.sendMessage(&message);
}
































~-----------------------------------------------~
C:\Users\Josh\Documents\Visual Studio 2017\Projects\Sorting\Sorting\Source.cpp
~-----------------------------------------------~
#include <Windows.h>
#include <windowsx.h>
#include <commctrl.h>
#pragma comment(lib, "Comctl32.lib")
#include <vector>
#include <map>
#include <string>
#include <algorithm>
#include <iostream>
#include <conio.h>
#include <ctime>
#include <functional>
#include <thread>

#include "sorting.h"
#include "resource.h"

#include "benchmark.h"
#include "trace.h"
#include "visualizer.h"
#include "chart.h"

#include "timsort.h"
#include "quicksort.h"
#include "mergesort.h"
#include "heapsort.h"
#include "softheapsort.h"
#include "weakheapsort.h"
#include "insertionsort.h"
#include "bubblesort.h"
#include "gnomesort.h"
#include "selectionsort.h"
#include "cyclesort.h"
#include "radixsort.h"
#include "pigeonholesort.h"
#include "smoothsort.h"
#include "wikisort.h"
#include "grailsort.h"
#include "binarytreesort.h"
#include "badsorts.h"
#include "vergesort.h"
#include "pdqsort.h"
#include "gravitysort.h"
#include "skasort.h"
#include "poplarsort.h"
#include "dropmergesort.h"
#include "countingsort.h"
#include "regionssort.h"
#include "patiencesort.h"
#include "tim\timsort.h"
#include "sqrtsort.h"
#include "neatsort.h"
#include "melsort.h"
#include "quickmergesort.h"
#include "mergeinsertionsort.h"
#define BOOST_INSTALLED true
#if BOOST_INSTALLED
#include "C:/boost_1_72_0/boost/sort/sort.hpp"
#endif

//TODO:
//quicksort variations
//soft heap sort fix
//weave merge complexity
//weak heap sort complexity
//shatter sort
//spread sort
//bogobogosort
//fix bogobogosort
//fix fast draw
//fix scatter plot (optimized (crush horz and vert))
//line plot
//fix comparison draw (not redrawing prev?)
//square plot
//region sort!!!!!!!!!!!!
//multi select options
//benchmark chart
//benchmark table??

#define SORTING_ALGORITHM(alg, alg_name, bc, ac, wc, sp, st, desc) { L#alg, {(TVSortAlgPtr)alg<tvit, tvcmp>, (VSortAlgPtr)alg<vit, vcmp>, alg_name, bc, ac, wc, sp, st, desc} }

#define TEST_SORT(alg, alg_name) { (VSortAlgPtr)alg<vit, vcmp>, alg_name }

int g_vis_id_counter = 0;
#define CREATE_VISUALIZER(sz, vis_type, col_mode, init_type_val, init_type_ord, draw_opts, alg) \
																						{Visualizer* visualizer = new Visualizer(hwnd, g_hInst, (HMENU)g_vis_id_counter++, \
																						sz, \
																						vis_type, \
																						col_mode, \
																						init_type_val, \
																						init_type_ord, \
																						DrawOption(draw_opts), \
																						SortingAlgorithms[L#alg]); \
																						Visualizer_HWNDS.push_back(visualizer->GetHWND());}

HWND g_hwnd;
HINSTANCE g_hInst;

std::vector<HWND> Visualizer_HWNDS;

BOOL CALLBACK DialogProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam);

void SHOW_CONSOLE(bool show = true, bool noclose = false) {
	static bool show_state = false;
	if (show && !show_state) {
		std::cout.clear();
		FILE *stream;
		AllocConsole();
		AttachConsole(GetCurrentProcessId());
		freopen_s(&stream, "CONOUT$", "w", stdout);
		if (noclose)
			EnableMenuItem(GetSystemMenu(GetConsoleWindow(), FALSE), SC_CLOSE, MF_GRAYED);
	}
	if (!show)
		FreeConsole();
	show_state = show;
}

struct Rect {
	int x, y, w, h;
	Rect(int x, int y, int w, int h) : x(x), y(y), w(w), h(h) { }
};
std::vector<Rect> calc_window_rects(unsigned num_wnd, const RECT& rcclient) {
	std::vector<Rect> ret;
	if (!num_wnd) return ret;	
	unsigned cols = num_wnd < 5 ? 1 : (int)log2(num_wnd - 3);
	unsigned rows = num_wnd < 5 ? num_wnd : (unsigned)ceil((double)num_wnd / (double)cols);
	double w = ((double)rcclient.right / (double)cols) - 4.0;
	double h = ((double)rcclient.bottom / (double)rows) - 4.0;
	for (unsigned row = 0; row < rows; row++) {
		for (unsigned col = 0, pos = row * cols + col; col < cols && (pos = row * cols + col) < num_wnd; col++) {
			unsigned x = 2 + (4 * col) + (unsigned)((double)col * w), y = 2 + (4 * row) + (unsigned)((double)row * h);
			Rect rect(x, y, (int)w, (int)h);
			ret.push_back(rect);
		}
	}
	return ret;
}

void Resize() {
	RECT rcclient;
	GetClientRect(g_hwnd, &rcclient);

	rcclient.right -= 80;

	SetWindowPos(GetDlgItem(g_hwnd, BTN_ADD), NULL, rcclient.right + 5, rcclient.bottom - 100, 0, 0, SWP_NOSIZE | SWP_NOZORDER);
	SetWindowPos(GetDlgItem(g_hwnd, BTN_REMOVE), NULL, rcclient.right + 5, rcclient.bottom - 70, 0, 0, SWP_NOSIZE | SWP_NOZORDER);
	SetWindowPos(GetDlgItem(g_hwnd, BTN_RUN_ALL), NULL, rcclient.right + 5, rcclient.bottom - 40, 0, 0, SWP_NOSIZE | SWP_NOZORDER);

	std::vector<Rect> r = calc_window_rects(Visualizer_HWNDS.size(), rcclient); 
	for (unsigned i = 0; i < r.size(); i++) {
		SetWindowPos(Visualizer_HWNDS[i], NULL, r[i].x, r[i].y, r[i].w, r[i].h, SWP_NOZORDER);
	}
}

//void Redraw() {
//	for (unsigned i = 0; i < Visualizer_HWNDS.size(); i++) {
//		Visualizer* vis = Visualizer::getVisualizer(Visualizer_HWNDS[i]);
//		vis->DrawScreen();
//	}
//}

int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE/* hPrevInstance*/, LPSTR/* args*/, int/* iCmdShow*/) {
	g_hInst = hInstance;

	SHOW_CONSOLE();
	
	srand(clock());

	register_visualizer_control();
	register_customtrackbar();

	//std::string filepath = "C:\\Users\\Josh\\Documents\\Visual Studio 2017\\Projects\\SortingAlgorithms\\SortingAlgorithms";//pc
	//std::string filepath = "C:\\Users\\JO20026780\\source\\repos\\Sorting\\Sorting";//work
	std::string filepath = "C:\\Users\\Josh\\Documents\\Visual Studio 2017\\Projects\\Sorting\\Sorting";//laptop

#ifndef _DEBUG
	SaveSourceToFile(filepath);
	LoadSourceFromFile(filepath);
#endif

	InitCommonControls();

	DialogBox(GetModuleHandle(0), MAKEINTRESOURCE(IDD_DIALOG), NULL, (DLGPROC)DialogProc);

	return 0;
}

template<class T, class C>
inline void rotater(T _First, T _Last, C compare) {
	while (true) {
		typename T::value_type val = *_First;
		T _Ptr = _First + 1;
		for (; _Ptr != _Last; ++_Ptr) {
			*(_Ptr - 1) = *_Ptr;
		}
		*(_Ptr - 1) = val;
	}
}

template <class RandomAccessIter, class Compare>
inline void integer_sort(RandomAccessIter first, RandomAccessIter last, Compare compare) {
  // Don't sort if it's too small to optimize.
	if (last - first < boost::sort::spreadsort::detail::min_sort_size)
		boost::sort::pdqsort(first, last);
	else
		boost::sort::spreadsort::detail::integer_sort(first, last, *first >> 0);
}

std::map<std::wstring, SortingAlgorithm> SortingAlgorithms = {
	///............|  alg_name					|				best case		|	average case		|	worst case			|	space		|	stable		|
//	SORTING_ALGORITHM(bozosort,									L"O(n)",			L"O(n)",				L"O(\u221E)",			L"O(1)",		false),
////	SORTING_ALGORITHM(bogobogosort,								L"O(n\u00B2)",		L"O(n*(n!)\u207F)",		L"O(\u221E)",			L"O(1)",		false),
//	SORTING_ALGORITHM(lexipermsort,								L"O(n)",			L"O(n!)",				L"O(n!)",				L"O(1)",		false),
//	SORTING_ALGORITHM(bogosort,									L"O(n)",			L"O((n + 1)!)",			L"O(\u221E)",			L"O(1)",		false),
//	SORTING_ALGORITHM(slowsort,									L"O(n^(log n))",	L"O(n^(log n))",		L"O(n^(log n))",		L"O(n)",		false),
//	SORTING_ALGORITHM(stoogesort,								L"O(n^2.7095)",		L"O(n^2.7095)",			L"O(n^2.7095)",			L"O(n)",		false),
//	SORTING_ALGORITHM(sillysort,								L"O(n^(log n))",	L"O(n^(log n))",		L"O(n^(log n))",		L"O(n)",		false), //this is the same things a slow sort, but with min vals instead of max
	SORTING_ALGORITHM(pancakesort,								L"Pancake Sort",										L"O(n\u00B2)",		L"O(n\u00B2)",			L"O(n\u00B2)",			L"O(1)",				false,	L"Pancake sort"),
	SORTING_ALGORITHM(selectionsort,							L"Selection Sort",										L"O(n\u00B2)",		L"O(n\u00B2)",			L"O(n\u00B2)",			L"O(1)",				false,	L"Select the largest value in the list, then swap it with the last unselected value in the list, repeat until last unselected value is the first element."),
	SORTING_ALGORITHM(doubleselectionsort,						L"Double Selection Sort",								L"O(n\u00B2)",		L"O(n\u00B2)",			L"O(n\u00B2)",			L"O(1)",				false,	L"Select the smallest and largest value, then swap the smallest value to the front, and the biggest value to the end, repeat until unselected values meet in the center of the list."),
	SORTING_ALGORITHM(bubblesort,								L"Bubble Sort",											L"O(n)",			L"O(n\u00B2)",			L"O(n\u00B2)",			L"O(1)",				true,	L"Check each adjacent pair in the list (left to right), swap them if the right element is greater than the left element, repeat until an entire pass is made without a swap. This Quickly moves large elements to the end of the list, but slowly moves small values to the front. These small values are sometimes called \"turtles\"."),
	SORTING_ALGORITHM(cocktailshakersort,						L"Cocktail Shaker Sort",								L"O(n)",			L"O(n\u00B2)",			L"O(n\u00B2)",			L"O(1)",				true,	L"Bubble sort from left to right, then right to left, repeat until no swaps are made. This is an attempt to move bubble sorts small value \"turtles\" to the left as quickly as large values move right."),
	SORTING_ALGORITHM(evenoddsort,								L"Even Odd Sort",										L"O(n)",			L"O(n\u00B2)",			L"O(n\u00B2)",			L"O(1)",				true,	L""),
	SORTING_ALGORITHM(combsort,									L"Comb Sort",											L"O(n log n)",		L"O(n\u00B2)",			L"O(n\u00B2)",			L"O(1)",				false,	L"Bubble sort, but instead of comparing adjacent elments it compares elements with increasingly smaller gaps until the gap size is 1. Then do passes of gap size 1 until no swaps are made."),
	SORTING_ALGORITHM(cyclesort,								L"Cycle Sort",											L"O(n\u00B2)",		L"O(n\u00B2)",			L"O(n\u00B2)",			L"O(1)",				false,	L""),
	SORTING_ALGORITHM(gnomesort,								L"Gnome Sort",											L"O(n)",			L"O(n\u00B2)",			L"O(n\u00B2)",			L"O(1)",				true,	L""),
	SORTING_ALGORITHM(optimizedgnomesort,						L"Gnome Sort (Optimized)",								L"O(n)",			L"O(n\u00B2)",			L"O(n\u00B2)",			L"O(1)",				true,	L""),
	SORTING_ALGORITHM(insertionsort,							L"Insertion Sort",										L"O(n)",			L"O(n\u00B2)",			L"O(n\u00B2)",			L"O(1)",				true,	L""),
	SORTING_ALGORITHM(binaryinsertionsort,						L"Binary Insertion Sort",								L"O(n log n)",		L"O(n\u00B2)",			L"O(n\u00B2)",			L"O(1)",				true,	L""),
	SORTING_ALGORITHM(stdinsertionsort,							L"std::insertion_sort",									L"O(n)",			L"O(n\u00B2)",			L"O(n\u00B2)",			L"O(1)",				true,	L""),
	SORTING_ALGORITHM(shellsort,								L"Shell Sort",											L"O(n log n)",		L"O(n log\u00B2 n)",	L"Unknown",				L"O(1)",				false,	L""),
	SORTING_ALGORITHM(weavemergesort,							L"Weave Merge Sort",									L"Unknown",			L"Unknown",				L"Unknown",				L"O(n)",				false,	L""),
	SORTING_ALGORITHM(mergesort,								L"Merge Sort",											L"O(n log n)",		L"O(n log n)",			L"O(n log n)",			L"O(n)",				true,	L""),
	SORTING_ALGORITHM(timsort,									L"Tim Sort",											L"O(n)",			L"O(n log n)",			L"O(n log n)",			L"O(n)",				true,	L""),
	SORTING_ALGORITHM(tim::timsort,								L"Tim Sort (Optimized)",								L"O(n)",			L"O(n log n)",			L"O(n log n)",			L"O(n)",				true,	L""),
	SORTING_ALGORITHM(heapsort,									L"Heap Sort (Max)",										L"O(n log n)",		L"O(n log n)",			L"O(n log n)",			L"O(1)",				false,	L""),
	SORTING_ALGORITHM(minheapsort,								L"Heap Sort (Min)",										L"O(n log n)",		L"O(n log n)",			L"O(n log n)",			L"O(1)",				false,	L""),
	SORTING_ALGORITHM(stdheapsort,								L"std::heap_sort",										L"O(n log n)",		L"O(n log n)",			L"O(n log n)",			L"O(1)",				false,	L""),
	SORTING_ALGORITHM(smoothsort,								L"Smooth Sort",											L"O(n)",			L"O(n log n)",			L"O(n log n)",			L"O(1)",				false,	L""),
	SORTING_ALGORITHM(weakheapsort,								L"Weak Heap Sort",										L"O(n log n)",		L"O(n log n)",			L"O(n log n)",			L"O(n)",				false,	L""),
	SORTING_ALGORITHM(binarytreesort,							L"Binary Tree Sort",									L"O(n log n)",		L"O(n log n)",			L"O(n log n)",			L"O(n)",				true,	L""),
//	SORTING_ALGORITHM(softheapsort,								L"Soft Heap Sort",										L"Unknown",			L"Unknown",				L"Unknown",				L"Unknown",				false,	L""),//doesn't sort in place :(
	SORTING_ALGORITHM(radixsort_LSD_2,							L"Radix Sort (LSD Base 2)",								L"O(w * n)",		L"O(w * n)",			L"O(w * n)",			L"O(w + n)",			true,	L""),
	SORTING_ALGORITHM(radixsort_LSD_4,							L"Radix Sort (LSD Base 4)",								L"O(w * n)",		L"O(w * n)",			L"O(w * n)",			L"O(w + n)",			true,	L""),
	SORTING_ALGORITHM(radixsort_LSD_10,							L"Radix Sort (LSD Base 10)",							L"O(w * n)",		L"O(w * n)",			L"O(w * n)",			L"O(w + n)",			true,	L""),
	SORTING_ALGORITHM(radixsort_LSD_16,							L"Radix Sort (LSD Base 16)",							L"O(w * n)",		L"O(w * n)",			L"O(w * n)",			L"O(w + n)",			true,	L""),
	SORTING_ALGORITHM(radixsort_LSD_32,							L"Radix Sort (LSD Base 32)",							L"O(w * n)",		L"O(w * n)",			L"O(w * n)",			L"O(w + n)",			true,	L""),
	SORTING_ALGORITHM(inPlaceRadixLSDSortBase2,					L"In-Place Radix Sort (LSD Base 2)",					L"Unknown",			L"Unknown",				L"Unknown",				L"O(b)",				true,	L""),
	SORTING_ALGORITHM(inPlaceRadixLSDSortBase4,					L"In-Place Radix Sort (LSD Base 4)",					L"Unknown",			L"Unknown",				L"Unknown",				L"O(b)",				true,	L""),
	SORTING_ALGORITHM(inPlaceRadixLSDSortBase10,				L"In-Place Radix Sort (LSD Base 10)",					L"Unknown",			L"Unknown",				L"Unknown",				L"O(b)",				true,	L""),
	SORTING_ALGORITHM(inPlaceRadixLSDSortBase16,				L"In-Place Radix Sort (LSD Base 16)",					L"Unknown",			L"Unknown",				L"Unknown",				L"O(b)",				true,	L""),
	SORTING_ALGORITHM(pigeonholesort,							L"Pigeon Hole Sort",									L"O(N + n)",		L"O(N + n)",			L"O(N + n)",			L"O(N + n)",			true,	L""),
	SORTING_ALGORITHM(quicksort,								L"Quick Sort (Median of Three, Dual Pointer)",			L"O(n log n)",		L"O(n log n)",			L"O(n\u00B2)",			L"O(log n)",			false,	L""),
	SORTING_ALGORITHM(std::stable_sort,							L"std::stable_sort",									L"O(n log n)",		L"O(n log n)",			L"O(n log\u00B2 n)",	L"O(n)",				true,	L""),
	SORTING_ALGORITHM(std::sort,								L"std::sort",											L"O(n log n)",		L"O(n log n)",			L"O(n log n)",			L"O(log n)",			false,	L""),
	SORTING_ALGORITHM(wikisort_nobuffer,						L"Wiki Sort (Buffer Size: 0)",							L"O(n log n)",		L"O(n log n)",			L"O(n log n)",			L"O(1)",				true,	L"Block sort implementation (stable in-place merge sort"),
	SORTING_ALGORITHM(wikisort_fixedbuffer,						L"Wiki Sort (Buffer Size: 512)",						L"O(n log n)",		L"O(n log n)",			L"O(n log n)",			L"O(1)",				true,	L""),
	SORTING_ALGORITHM(wikisort_sqrtbuffer,						L"Wiki Sort (Buffer Size: sqrt(N / 2))",				L"O(n log n)",		L"O(n log n)",			L"O(n log n)",			L"O(sqrt(n))",			true,	L""),
	SORTING_ALGORITHM(wikisort_fullbuffer,						L"Wiki Sort (Buffer Size: (N / 2))",					L"O(n log n)",		L"O(n log n)",			L"O(n log n)",			L"O(n)",				true,	L""),
	SORTING_ALGORITHM(grailsort_nobuffer,						L"Grail Sort (Buffer Size: 0)",							L"O(n log n)",		L"O(n log n)",			L"O(n log n)",			L"O(1)",				true,	L""),
	SORTING_ALGORITHM(grailsort_fixedbuffer,					L"Grail Sort (Buffer Size: 512)",						L"O(n log n)",		L"O(n log n)",			L"O(n log n)",			L"O(1)",				true,	L""),
	SORTING_ALGORITHM(grailsort_fullbuffer,						L"Grail Sort (Buffer Size: N)",							L"O(n log n)",		L"O(n log n)",			L"O(n log n)",			L"O(n)",				true,	L""),
	SORTING_ALGORITHM(vergesort,								L"Verge Sort",											L"O(n)",			L"O(n log n)",			L"O(n log n)",			L"O(n)",				false,	L""),	
	SORTING_ALGORITHM(gravitysort,								L"Gravity Sort (Bead Sort)",							L"O(S)",			L"O(S)",				L"O(S)",				L"O(n\u00B2)",			false,	L""),
	SORTING_ALGORITHM(skasort,									L"Ska Sort",											L"O(b * n)",		L"O(b * n)",			L"O(n log n)",			L"O(b)",				false,	L"Ska sort is an optimized and generalized american flag sort."),
	SORTING_ALGORITHM(vergeskasort,								L"Ska Verge Sort",										L"O(n)",			L"Unknown",				L"Unknown",				L"Unknown",				false,	L""),
	SORTING_ALGORITHM(americanflagsort,							L"American Flag Sort (Serial In-place MSD Radix Sort)",	L"O(b * n)",		L"O(b * n)",			L"O(n log n)",			L"O(b)",				false,	L"Serial In-place MSD Radix sort with 256 buckets"),
	SORTING_ALGORITHM(poplarsort,								L"Poplar Heap Sort",									L"O(n log n)",		L"O(n log n)",			L"O(n log n)",			L"O(1)",				false,	L""),
	SORTING_ALGORITHM(dropmergesort,							L"Drop Merge Sort",										L"O(n)",			L"O(n + k log k)",		L"O(n + k log k)",		L"O(k)",				false,	L""),
	SORTING_ALGORITHM(patiencesort, 							L"Patience Sort",										L"Unknown",			L"Unknown",				L"Unknown",				L"Unknown",				false,	L""),

	SORTING_ALGORITHM(sqrtsort, 								L"Sqrtsort",											L"O(n log n)",		L"O(n log n)",			L"O(n log n)",			L"O(sqrt(n))",			true,	L"Similar to Grail sort, but allocates sqrt(n) size buffer on the heap"),
	SORTING_ALGORITHM(neatsort, 								L"NeatSort",											L"O(n)",			L"O(n log n)",			L"O(n log n)",			L"O(n)",				false,	L"Adaptive mergesort that finds natural non-decreasing runs and merges them together."),
	SORTING_ALGORITHM(melsort, 									L"Melsort",												L"O(n)",			L"O(n log n)",			L"O(n log n)",			L"O(n)",				false,	L"Builds a set of encroaching lists, then merges them until there is only one sorted list left"),
	SORTING_ALGORITHM(quickmergesort, 							L"Quick Merge Sort",									L"O(n log n)",		L"O(n log n)",			L"O(n log n)",			L"O(log n)",			false,	L""),
//	SORTING_ALGORITHM(merge_insertion_sort, 					L"Merge Insertion Sort",								L"Unknown",			L"Unknown",				L"Unknown",				L"Unknown",				false,	L""),

	//	SORTING_ALGORITHM(AVLTreeSort,								L"AVL Tree Sort",										L"O(n log n)",		L"O(n log n)",			L"O(n log n)",			L"O(n)",				false,	L""),
#if BOOST_INSTALLED	
	SORTING_ALGORITHM(boost::sort::block_indirect_sort, 		L"boost::block_indirect_sort (parallel)",				L"O(n)",			L"O(n log n)",			L"O(n log n)",			L"O(block_size * T)",	false,	L""),
	SORTING_ALGORITHM(boost::sort::parallel_stable_sort, 		L"boost::parallel_stable_sort (parallel)",				L"O(n)",			L"O(n log n)",			L"O(n log n)",			L"O(n)",				true,	L""),//O(n / 2) space
	SORTING_ALGORITHM(boost::sort::sample_sort, 				L"boost::sample_sort (parallel)",						L"O(n)",			L"O(n log n)",			L"O(n log n)",			L"O(n)",				true,	L""),
	SORTING_ALGORITHM(integer_sort, 							L"boost::spread_sort",									L"O(n)",			L"Unknown",				L"O(k)",				L"Unknown",				false,	L""),
	SORTING_ALGORITHM(boost::sort::flat_stable_sort, 			L"boost::flat_stable_sort",								L"O(n)",			L"O(n log n)",			L"O(n log n)",			L"Unknown",				true,	L""),
	SORTING_ALGORITHM(boost::sort::indirect_flat_stable_sort, 	L"boost::indirect_flat_stable_sort",					L"O(n)",			L"O(n log n)",			L"O(n log n)",			L"Unknown",				true,	L""),
	SORTING_ALGORITHM(boost::sort::spinsort, 					L"boost::spinsort",										L"O(n)",			L"O(n log n)",			L"O(n log n)",			L"O(n)",				true,	L""),//O(n / 2) space
	SORTING_ALGORITHM(boost::sort::indirect_spinsort, 			L"boost::indirect_spinsort",							L"O(n)",			L"O(n log n)",			L"O(n log n)",			L"O(n)",				true,	L""),//O(n / 2) space
	SORTING_ALGORITHM(boost::sort::pdqsort_branchless, 			L"boost::pdqsort_branchless",							L"O(n)",			L"O(n log n)",			L"O(n log n)",			L"O(log n)",			false,	L""),
	SORTING_ALGORITHM(boost::sort::pdqsort,						L"boost::pdqsort",										L"O(n)",			L"O(n log n)",			L"O(n log n)",			L"O(log n)",			false,	L""),
#endif
	//	SORTING_ALGORITHM(regionssort,					L"Regions Sort",									L"Unknown",			L"Unknown",				L"Unknown",				L"Unknown",		false,	L""),
//big crash (BIG ALLOCATE)	SORTING_ALGORITHM(countingsort,					L"Counting Sort",			L"Unknown",			L"Unknown",				L"Unknown",				L"Unknown",		false,	L""),
	//	SORTING_ALGORITHM(rotater, L"", L"", L"", L"", false, L"")
};

double runSortN(const SortingAlgorithm& sort_alg, const std::vector<unsigned>& list, unsigned test_runs) {
	Benchmark timer;
	
	//SortingAlgorithm alg((VSortAlgPtr)merge_insertion_sort<vit, vit, vcmp>, L"Merge insertion sort");
	//Visualizer v(1,2,3,4,VisualizationType::BarGraph,ColorMode::RainbowHSV,InitTypeValue::Regular,InitTypeOrder::Shuffled,DrawOption::Accesses,)


	double total_time = 0.0;

	int runs = 1;
	for (; runs <= test_runs; runs++) {
		std::vector<unsigned> l(list);

		timer.start();
		sort_alg.vsort(l.begin(), l.end(), vcmp());
		timer.stop();

		double runtime = timer.getElapsedMS();

		total_time += runtime;
	}

	return total_time / (double)runs;
}

void BenchmarkOrdering(unsigned n, InitTypeValue values, int test_runs, const std::vector<SortingAlgorithm>& test_sorts) {
	std::wofstream outfile;
	outfile.open(L"ordering (" + (std::to_wstring(n)) + L" elements).xls");

	//=B2=MIN($B2:$AD2)

	//write all the sort names
	outfile << '\t';
	for (auto & sort : test_sorts) {
		outfile << sort.name << '\t';
	}
	outfile << '\n';

	for (auto a : InitTypeOrderNames) {
		outfile << a.second << '\t';

		InitTypeOrder order = a.first;

		std::vector<unsigned> list;
		Initializer::Init(&list, n, values, order);

		std::wcout << a.second << '\n';

		for (auto & sort : test_sorts) {
			std::wcout << '\t' << sort.name << ' ';

			double runtime = runSortN(sort, list, test_runs);

			Visualizer::SortRunData srd(sort.name, n, runtime, 0, 0, 0, 0, InitTypeValueNames[values], a.second);
			Visualizer::SortTable.AddRow(srd);
			Visualizer::SortTable.SortByColumn(Visualizer::SortRunData::ColumnId::runtime, true);

			std::wcout << runtime << '\n';

			outfile << runtime << '\t';
		}

		outfile << '\n';
	}

	outfile.close();
}

BOOL CALLBACK DialogProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam) {
	static bool IsCursorInClient = false;
	static bool IsDragging = false;
	static int DragCount = 0;
	static POINT ClickDownPoint = {-1, -1};
	static POINT ClickUpPoint = {-1, -1};
	static RECT SelectionRect;

	switch (message) {
		case WM_INITDIALOG: {
			g_hwnd = hwnd;
		
			RECT rcclient;
			GetClientRect(hwnd, &rcclient);			
			
			int def_opts = DrawOption::Comparisons | DrawOption::Assignments;

#ifdef BENCHMARK
			InitTypeValue values = Regular;
			InitTypeOrder order = Shuffled;
			Table results;
			int max_power = 20;//20;
			int test_runs = 5;
			double max_time = 100.0;
			Benchmark timer;

			std::vector<unsigned> sizes;
			for (int i = 1; i <= max_power; i++)
				sizes.push_back((unsigned)pow(2, i));

			for (unsigned i = 0; i < sizes.size(); ++i) {
				unsigned n = sizes[i];
				std::vector<unsigned> list;
				Initializer::Init(&list, n, values, order);

				printf("size: %d %d of %d                                                                       \n", n, i + 1, sizes.size());

				int sai = 0;
				for (auto & sort : SortingAlgorithms) {
					if (sort.second.desc == L"skip")
						continue;

					double total_time = 0.0;

				//	dummy->SetSize(n);
				//	dummy->SetSort(a.second);

					int runs = 1;
					for (; runs <= test_runs; runs++) {
						std::vector<unsigned> l(list);
						
						printf("%ls(%d of %d) run %d of %d elapsed: %f                                               \r", sort.first.c_str(), sai, SortingAlgorithms.size(), runs, test_runs, total_time);
						timer.start();
						sort.second.vsort(l.begin(), l.end(), vcmp());
						timer.stop();						

						double runtime = timer.getElapsedMS();

						if (runtime * 2.0 > max_time)
							sort.second.desc = L"skip";

						total_time += runtime;
						if (total_time > max_time)
							break;
					}
					
					Row row;
					row.data = {sort.second.name, n, timer.getElapsedMS(),
						0, 0, 0, 0,
						InitTypeValueNames[values], InitTypeOrderNames[order]};
					results.AddRow(row);

					sai++;
				}				
			}
			/*dummy->SortTableBy(ColumnId::runtime, true);
			dummy->SortTableBy(ColumnId::num_elements, false);
			dummy->PrintTableRows();*/

			auto rows = results.GetRows();
			std::map<std::wstring, std::map<unsigned, double>> sorts;
			for (int i = 0; i < rows.size(); i++) {
				auto sort_name = GET_COLUMN_DATA(ColumnId::name, rows[i].data);
				auto num_elements = GET_COLUMN_DATA(ColumnId::num_elements, rows[i].data);
				auto runtime = GET_COLUMN_DATA(ColumnId::runtime, rows[i].data);
				sorts[Visualizer::GetSortNameKey(sort_name)][num_elements] = runtime;
			}

			std::wofstream outfile;
			outfile.open("benchmark.txt");
			if (outfile.is_open()) {
			//write headers
				outfile << L"Number Of Elements" << '\t';
				for (auto & a : SortingAlgorithms)
					outfile << a.second.name << '\t';
				outfile << '\n';

				//write data
				for (int i = 0; i < sizes.size(); i++) {
					outfile << sizes[i] << '\t';
					for (auto & a : SortingAlgorithms) {
						auto pos = sorts[a.first].find(sizes[i]);
						if (pos != sorts[a.first].end()) {
							outfile << (*pos).second;
						}
						outfile << '\t';
					}
					outfile << '\n';
				}				
			}
			outfile.close();

#endif

		/*	for (auto & alg : SortingAlgorithms) {
				Visualizer* visualizer = new Visualizer(hwnd, g_hInst, (HMENU)g_vis_id_counter++,
					500,
					BarGraph,
					RainbowHSV,
					Regular,
					Shuffled,
					def_opts,
					SortingAlgorithms[alg.first]);
				Visualizer_HWNDS.push_back(visualizer->GetHWND());
			}*/

			CreateDialogParam(GetModuleHandle(NULL), MAKEINTRESOURCE(IDD_TABLEVIEW), GetParent(hwnd), (DLGPROC)Visualizer::SortRunData::Proc, (LPARAM)&Visualizer::SortTable);


		//	CREATE_VISUALIZER(1000, BarGraph, Gradient, Random, Shuffled, def_opts, sqrtsort);
		//	CREATE_VISUALIZER(1000, BarGraph, Gradient, Random, Shuffled, def_opts, neatsort);
		//	CREATE_VISUALIZER(1000, BarGraph, Gradient, Random, Shuffled, def_opts, melsort);
		//	CREATE_VISUALIZER(1000, BarGraph, Gradient, Random, Shuffled, def_opts, quickmergesort);
		//	CREATE_VISUALIZER(1000, BarGraph, Gradient, Random, Shuffled, def_opts, merge_insertion_sort);

			//CREATE_VISUALIZER(1000, BarGraph, HeatMap, Regular, Shuffled, def_opts, quickmergesort);
			CREATE_VISUALIZER(100, ScatterPlot, Exploding, Regular, Shuffled, def_opts, insertionsort);
			

	//		CREATE_VISUALIZER(100, DisparityDots, Rainbow, FewUnique, def_opts, radixsort_LSD_2);
		//	CREATE_VISUALIZER(10, DisparityDots, Rainbow, Random, def_opts, radixsort_LSD_2);

		//	CREATE_VISUALIZER(10, DisparityDots, Gradient, Random, def_opts, quicksort);
		//	CREATE_VISUALIZER(100, DisparityDots, Gradient, Random, def_opts, insertionsort);
			//CREATE_VISUALIZER(1000, DisparityDots, Rainbow, Regular, Random, def_opts, pancakesort);
		//	CREATE_VISUALIZER(13, ColorWheel, RainbowHSV, Regular, Random, def_opts, quicksort);
		//	CREATE_VISUALIZER(100, ColorWheel, RainbowHSV, Regular, Random, def_opts, quicksort);
		//	CREATE_VISUALIZER(1000, ColorWheel, RainbowHSV, Regular, Random, def_opts, quicksort);
		//	CREATE_VISUALIZER(10000, ColorWheel, RainbowHSV, Regular, Random, def_opts, quicksort);


		//	CREATE_VISUALIZER(1000, ColorWheel, RainbowHSV, Regular, Sorted, def_opts, rotater);


		//	CREATE_VISUALIZER(5, BarGraph, Gradient,  Regular, Random, def_opts, bozosort);
		//	CREATE_VISUALIZER(10, BarGraph, Gradient,  Regular, Random, def_opts, lexipermsort);
		//	CREATE_VISUALIZER(6, BarGraph, Gradient,  Regular, Random, def_opts, bogosort);
		//	CREATE_VISUALIZER(100, BarGraph, Gradient,  Regular, FewUnique, def_opts, slowsort);
		//	CREATE_VISUALIZER(100, BarGraph, Gradient,  Regular, FewUnique, def_opts, stoogesort);
			//CREATE_VISUALIZER(100, BarGraph, Gradient,  Regular, Random, def_opts, pancakesort);
			//CREATE_VISUALIZER(100, BarGraph, Gradient,  Regular, Random, def_opts, selectionsort);
			//CREATE_VISUALIZER(100, BarGraph, Gradient, Regular, Random, def_opts, doubleselectionsort);
			//CREATE_VISUALIZER(10000, BarGraph, Gradient,  Regular, Random, def_opts, bubblesort);
			//CREATE_VISUALIZER(100, BarGraph, Gradient,  Regular, Random, def_opts, cocktailshakersort);
			//CREATE_VISUALIZER(100, BarGraph, Gradient,  Regular, Random, def_opts, evenoddsort);
			//CREATE_VISUALIZER(100, BarGraph, Gradient,  Regular, Random, def_opts, cyclesort);
			//CREATE_VISUALIZER(100, BarGraph, RedWhiteBlue,  Regular, Random, Comparisons | PreSwaps | PostSwaps | Assignments, combsort);
			//CREATE_VISUALIZER(100, BarGraph, Gradient,  Regular, Random, def_opts, gnomesort);
			//CREATE_VISUALIZER(100, BarGraph, Gradient,  Regular, Random, def_opts, optimizedgnomesort);
			//CREATE_VISUALIZER(100, BarGraph, Gradient,  Regular, Random, def_opts, insertionsort);
			//CREATE_VISUALIZER(100, BarGraph, Gradient,  Regular, Random, def_opts, binaryinsertionsort);
			//CREATE_VISUALIZER(100, BarGraph, Gradient,  Regular, Random, def_opts, stdinsertionsort);
			//CREATE_VISUALIZER(100, BarGraph, Rainbow,  Regular, Random, def_opts, shellsort);
			//CREATE_VISUALIZER(10, BarGraph, Gradient,  Regular, Random, def_opts, weavemergesort);
			//CREATE_VISUALIZER(100, BarGraph, Gradient,  Regular, Random, def_opts, mergesort);
			//CREATE_VISUALIZER(10000, BarGraph, Gradient,  Regular, Random, def_opts, heapsort);
			//CREATE_VISUALIZER(100000, BarGraph, Gradient,  Regular, Random, def_opts, minheapsort);
			//CREATE_VISUALIZER(1000000, BarGraph, Gradient,  Regular, Random, def_opts, stdheapsort);
			//CREATE_VISUALIZER(100, BarGraph, Gradient,  Regular, Random, def_opts, binarytreesort);
			//CREATE_VISUALIZER(100, BarGraph, Gradient,  Regular, Random, def_opts, smoothsort);
			//CREATE_VISUALIZER(100, BarGraph, Gradient,  Regular, Random, def_opts, weakheapsort);
			//CREATE_VISUALIZER(100, BarGraph, Gradient,  Regular, Random, def_opts, radixsort_LSD_32);
			//CREATE_VISUALIZER(100, BarGraph, Gradient,  Regular, Random, def_opts, typedpigeonholesort);
			//CREATE_VISUALIZER(100, ScatterPlot, RainbowHSV,  Regular, Random, def_opts, quicksort);
//bad		//CREATE_VISUALIZER(1000, BarGraph, Gradient, Regular, Random, def_opts, gravitysort);

		//	CREATE_VISUALIZER(1000000, BarGraph, RainbowHSV, Regular, Shuffled, def_opts | Accesses, regionssort);

			//CREATE_VISUALIZER(1000, BarGraph, RainbowHSV, Regular, Shuffled, def_opts, vergeskasort);
			/*CREATE_VISUALIZER(1000, BarGraph, RainbowHSV, Regular, Shuffled, 0, vergeskasort);
			CREATE_VISUALIZER(1000, BarGraph, RainbowHSV, Regular, Shuffled, 0, vergeskasort);
			CREATE_VISUALIZER(1000, BarGraph, RainbowHSV, Regular, Shuffled, 0, vergeskasort);
			CREATE_VISUALIZER(1000, BarGraph, RainbowHSV, Regular, Shuffled, 0, vergeskasort);
			CREATE_VISUALIZER(1000, BarGraph, RainbowHSV, Regular, Shuffled, 0, vergeskasort);*/


			/*CREATE_VISUALIZER(1000000, BarGraph, RainbowHSV, Regular, Shuffled, def_opts | Accesses, skasort);
			CREATE_VISUALIZER(1000000, BarGraph, RainbowHSV, Regular, Shuffled, def_opts | Accesses, vergeskasort);
			CREATE_VISUALIZER(1000000, BarGraph, RainbowHSV, Regular, Shuffled, def_opts, std::sort);		
			CREATE_VISUALIZER(1000000, BarGraph, RainbowHSV, Regular, Shuffled, def_opts, vergesort);
			CREATE_VISUALIZER(1000000, BarGraph, RainbowHSV, Regular, Shuffled, def_opts, pdqsort);
			CREATE_VISUALIZER(1000000, BarGraph, RainbowHSV, Regular, Shuffled, def_opts, wikisort_fixedbuffer);
			CREATE_VISUALIZER(1000000, BarGraph, RainbowHSV, Regular, Shuffled, def_opts, grailsort_fixedbuffer);
			CREATE_VISUALIZER(1000000, BarGraph, RainbowHSV, Regular, Shuffled, def_opts, std::stable_sort);			
			CREATE_VISUALIZER(1000000, BarGraph, RainbowHSV, Regular, Shuffled, def_opts, timsort);
			CREATE_VISUALIZER(1000000, BarGraph, RainbowHSV, Regular, Shuffled, def_opts, dropmergesort);*/

			//CREATE_VISUALIZER(1000, BarGraph, Gradient, Regular, Random, def_opts, poplarsort);
			//CREATE_VISUALIZER(1000, BarGraph, RainbowHSV, Regular, Random, def_opts, inPlaceRadixLSDSortBase10);

		//	CREATE_VISUALIZER(100000, BarGraph, RainbowHSV, Regular, Shuffled, def_opts, skasort);
		//	CREATE_VISUALIZER(1000, Squares, RainbowHSV, FewUnique, PipeOrgan, def_opts, timsort);
			//CREATE_VISUALIZER(1000, BarGraph, RainbowHSV, Regular, FrayedStart, def_opts, timsort);
			//CREATE_VISUALIZER(1000, BarGraph, RainbowHSV, Regular, FrayedEnd, def_opts, timsort);
			//CREATE_VISUALIZER(1000, BarGraph, RainbowHSV, Regular, Random, def_opts, timsort);

			//NOT WORKING
			//			CREATE_VISUALIZER(1000, BarGraph, RainbowHSV, Regular, Random, def_opts, countingsort);
			//				CREATE_VISUALIZER(4, BarGraph, Gradient, Random, def_opts, bogobogosort);
				
				//CREATE_VISUALIZER(1000, BarGraph, RainbowHSV, Regular, Random, def_opts, softheapsort);

			break;
		}
		case WM_PAINT: {
			RECT rcclient;
			GetClientRect(hwnd, &rcclient);

			HDC hDC = GetDC(hwnd);

			HDC hDCmem = CreateCompatibleDC(hDC);

			HBITMAP hbmScreen = CreateCompatibleBitmap(hDC, rcclient.right, rcclient.bottom);
			HBITMAP hbmOldBitmap = (HBITMAP)SelectObject(hDCmem, hbmScreen);

			/////////////////////////////////////////////////////////////

			HBRUSH backbrush = CreateSolidBrush(RGB(10, 10, 10));
			FillRect(hDCmem, &rcclient, backbrush);
			DeleteObject(backbrush);

			if (IsDragging) {
				FrameRect(hDCmem, &SelectionRect, GetStockBrush(WHITE_BRUSH));
			}

			/////////////////////////////////////////////////////////////

			BitBlt(hDC, 0, 0, rcclient.right, rcclient.bottom, hDCmem, 0, 0, SRCCOPY);

			//cleanup
			SelectObject(hDCmem, hbmOldBitmap);
			DeleteObject(hbmScreen);

			DeleteDC(hDCmem);
			ReleaseDC(hwnd, hDC);

			break;
		}
		case WM_ERASEBKGND:{
			return TRUE;
		}
		case WM_COMMAND: {
			HWND ihwnd = (HWND)lParam;
			UINT iid = LOWORD(wParam);
			switch (HIWORD(wParam)) {
				case BN_CLICKED: {
					switch (iid) {
						case BTN_ADD: {
							Visualizer* activeVis = Visualizer::getVisualizer(Visualizer::Options::GetHWND());
							if (activeVis) {
								Visualizer* visualizer = new Visualizer(hwnd, g_hInst, (HMENU)g_vis_id_counter++, 
																		activeVis->GetSize(),
																		activeVis->GetVisualizationType(), activeVis->GetColorMode(),
																		activeVis->GetInitTypeValue(), activeVis->GetInitTypeOrder(),
																		activeVis->GetDrawOptions(),
																		SortingAlgorithms[activeVis->GetSortNameKey()]);
								visualizer->SetDrawSpeed(activeVis->GetDrawSpeed());
								Visualizer_HWNDS.push_back(visualizer->GetHWND());
							}
							else {
								CREATE_VISUALIZER(100, BarGraph, Gradient, Regular, Shuffled, DrawOption(Comparisons | Assignments), selectionsort);
							}

							Resize();
//							Redraw();

							break;
						}
						case BTN_REMOVE: {
							if (Visualizer_HWNDS.size() > 1) {
								HWND removeHWND = NULL;

								Visualizer* activeVis = Visualizer::getVisualizer(Visualizer::Options::GetHWND());
								if (activeVis)
									removeHWND = activeVis->GetHWND();
								else
									removeHWND = Visualizer_HWNDS[Visualizer_HWNDS.size() - 1];

								auto pos = find(Visualizer_HWNDS.begin(), Visualizer_HWNDS.end(), removeHWND);
								DestroyWindow(*pos);
								Visualizer_HWNDS.erase(pos);

								if (activeVis) {
									Visualizer::Options::ClearHWND();
								}

								Resize();
//								Redraw();
							}

							break;
						}
						case BTN_RUN_ALL: {
							for (unsigned i = 0; i < Visualizer_HWNDS.size(); i++) {
								Visualizer* vis = Visualizer::getVisualizer(Visualizer_HWNDS[i]);
								vis->RunSort();
							}

							break;
						}
					}
					break;
				}
			}
			break;
		}
		case WM_CHAR: {
			switch (wParam) {
				case VK_RETURN: {
					for (unsigned i = 0; i < Visualizer_HWNDS.size(); i++) {
						Visualizer* vis = Visualizer::getVisualizer(Visualizer_HWNDS[i]);
						vis->RunSort();
					}
					break;
				}
				case 'A': {
					if (GetAsyncKeyState(VK_CONTROL) < 0) {
						
					}

					break;
				}
			}
			break;
		}
		case WM_SIZE: {
			Resize();
//			Redraw();

			break;
		}
		case WM_LBUTTONDOWN: {
			IsDragging = true;
			SetCapture(hwnd);
			DragCount = 0;
			ClickDownPoint = {GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam)};
			
			break;
		}
		case WM_LBUTTONUP: {
			if (IsDragging) {
				ReleaseCapture();
				IsDragging = false;
				ClickUpPoint = {GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam)};
				SelectionRect = {0, 0, 0, 0};
				
				RedrawWindow(hwnd, NULL, NULL, RDW_INVALIDATE);
			}

			break;
		}
		case WM_RBUTTONUP: {

			std::vector<SortingAlgorithm> test_sorts = {
				//				TEST_SORT(pancakesort,								L"Pancake Sort"),
				//				TEST_SORT(selectionsort,							L"Selection Sort"),
				//				TEST_SORT(doubleselectionsort,						L"Double Selection Sort"),
				//				TEST_SORT(bubblesort,								L"Bubble Sort"),
				//				TEST_SORT(cocktailshakersort,						L"Cocktail Shaker Sort"),
				//				TEST_SORT(evenoddsort,								L"Even Odd Sort"),
				//				TEST_SORT(combsort,									L"Comb Sort"),
				//				TEST_SORT(cyclesort,								L"Cycle Sort"),
				//				TEST_SORT(gnomesort,								L"Gnome Sort"),
				//				TEST_SORT(optimizedgnomesort,						L"Gnome Sort (Optimized)"),
				//				TEST_SORT(insertionsort,							L"Insertion Sort"),
				//				TEST_SORT(binaryinsertionsort,						L"Binary Insertion Sort"),
				//				TEST_SORT(stdinsertionsort,							L"std::insertion_sort"),
				//			TEST_SORT(shellsort,								L"Shell Sort"),
				//				TEST_SORT(weavemergesort,							L"Weave Merge Sort"),
				//			TEST_SORT(mergesort,								L"Merge Sort"),
				TEST_SORT(timsort, L"Tim Sort"),
					TEST_SORT(tim::timsort, L"Tim Sort (Optimized)"),
					//			TEST_SORT(heapsort,									L"Heap Sort (Max)"),
					//			TEST_SORT(minheapsort,								L"Heap Sort (Min)"),
					//			TEST_SORT(stdheapsort,								L"std::heap_sort"),
					//			TEST_SORT(smoothsort,								L"Smooth Sort"),
					//			TEST_SORT(weakheapsort,								L"Weak Heap Sort"),
					//			TEST_SORT(binarytreesort,							L"Binary Tree Sort"),										
					//				TEST_SORT(radixsort_LSD_2,							L"Radix Sort (LSD Base 2)"),
					//				TEST_SORT(radixsort_LSD_4,							L"Radix Sort (LSD Base 4)"),
					//				TEST_SORT(radixsort_LSD_10,							L"Radix Sort (LSD Base 10)"),
					//				TEST_SORT(radixsort_LSD_16,							L"Radix Sort (LSD Base 16)"),
					//				TEST_SORT(radixsort_LSD_32,							L"Radix Sort (LSD Base 32)"),
					//				TEST_SORT(inPlaceRadixLSDSortBase2,					L"In-Place Radix Sort (LSD Base 2)"),
					//				TEST_SORT(inPlaceRadixLSDSortBase4,					L"In-Place Radix Sort (LSD Base 4)"),
					//				TEST_SORT(inPlaceRadixLSDSortBase10,				L"In-Place Radix Sort (LSD Base 10)"),
					//				TEST_SORT(inPlaceRadixLSDSortBase16,				L"In-Place Radix Sort (LSD Base 16)"),
					//				TEST_SORT(pigeonholesort,							L"Pigeon Hole Sort"),
					//			TEST_SORT(quicksort,								L"Quick Sort (Median of Three, Dual Pointer)"),
					//			TEST_SORT(std::stable_sort,							L"std::stable_sort"),
					TEST_SORT(std::sort, L"std::sort"),
					//			TEST_SORT(wikisort_nobuffer,						L"Wiki Sort (Buffer Size: 0)"),
					TEST_SORT(wikisort_fixedbuffer, L"Wiki Sort (Buffer Size: 512)"),
					//			TEST_SORT(wikisort_sqrtbuffer,						L"Wiki Sort (Buffer Size: sqrt(N / 2))"),
					//			TEST_SORT(wikisort_fullbuffer,						L"Wiki Sort (Buffer Size: (N / 2))"),
					//			TEST_SORT(grailsort_nobuffer,						L"Grail Sort (Buffer Size: 0)"),
					TEST_SORT(grailsort_fixedbuffer, L"Grail Sort (Buffer Size: 512)"),
					//			TEST_SORT(grailsort_fullbuffer,						L"Grail Sort (Buffer Size: N)"),
					TEST_SORT(vergesort, L"Verge Sort"),
					//				TEST_SORT(gravitysort,								L"Gravity Sort (Bead Sort)"),
					TEST_SORT(skasort, L"Ska Sort"),
					TEST_SORT(vergeskasort, L"Ska Verge Sort"),
					//			TEST_SORT(americanflagsort,							L"American Flag Sort (Serial In-place MSD Radix Sort)"),
					//			TEST_SORT(poplarsort,								L"Poplar Heap Sort"),
					TEST_SORT(dropmergesort, L"Drop Merge Sort"),
					//			TEST_SORT(patiencesort, 							L"Patience Sort"),
					//			TEST_SORT(boost::sort::block_indirect_sort, 		L"boost::block_indirect_sort (parallel)"),
					//			TEST_SORT(boost::sort::parallel_stable_sort, 		L"boost::parallel_stable_sort (parallel)"),
					//			TEST_SORT(boost::sort::sample_sort, 				L"boost::sample_sort (parallel)"),
					//			TEST_SORT(integer_sort, 							L"boost::spread_sort"),
					//			TEST_SORT(boost::sort::flat_stable_sort, 			L"boost::flat_stable_sort"),
					//			TEST_SORT(boost::sort::indirect_flat_stable_sort, 	L"boost::indirect_flat_stable_sort"),
					//			TEST_SORT(boost::sort::spinsort, 					L"boost::spinsort"),
					//			TEST_SORT(boost::sort::indirect_spinsort, 			L"boost::indirect_spinsort"),
					//			TEST_SORT(boost::sort::pdqsort_branchless, 			L"boost::pdqsort_branchless"),
					//			TEST_SORT(boost::sort::pdqsort,						L"boost::pdqsort"),						
			};

			std::thread a(BenchmarkOrdering, 1000000, InitTypeValue::Normal, 10, test_sorts);
			a.detach();

			for (unsigned i = 0; i < Visualizer_HWNDS.size(); i++) {
				Visualizer::AddSelectionHWND(Visualizer_HWNDS[i]);
			}
			break;
		}
		case WM_MOUSEMOVE: {
			if (!IsCursorInClient) {
				IsCursorInClient = true;
				TRACKMOUSEEVENT tme = {0};
				tme.cbSize = sizeof(tme);
				tme.dwFlags = TME_LEAVE;
				tme.hwndTrack = hwnd;
				TrackMouseEvent(&tme);
			}

			POINT pt = {GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam)};

			if (IsDragging) {
				DragCount++;

				RECT rcclient;
				GetClientRect(hwnd, &rcclient);

				SelectionRect.left = std::min(ClickDownPoint.x, pt.x); SelectionRect.left = rcclient.left > SelectionRect.left ? rcclient.left : SelectionRect.left;
				SelectionRect.right = std::max(ClickDownPoint.x, pt.x); SelectionRect.right = rcclient.right < SelectionRect.right ? rcclient.right : SelectionRect.right;
				SelectionRect.top = std::min(ClickDownPoint.y, pt.y); SelectionRect.top = rcclient.top > SelectionRect.top ? rcclient.top : SelectionRect.top;
				SelectionRect.bottom = std::max(ClickDownPoint.y, pt.y); SelectionRect.bottom = rcclient.bottom < SelectionRect.bottom ? rcclient.bottom : SelectionRect.bottom;
				
				RedrawWindow(hwnd, NULL, NULL, RDW_INVALIDATE);
			}

			break;
		}
		case WM_CLOSE:
		case WM_DESTROY: {
			EndDialog(hwnd, 0);
			break;
		}
		default: return FALSE;
	}
	return TRUE;
}


~-----------------------------------------------~
C:\Users\Josh\Documents\Visual Studio 2017\Projects\Sorting\Sorting\trace.cpp
~-----------------------------------------------~
#include "trace.h"
#include "Visualizer.h"


//ASSIGNMENT
TraceInt& TraceInt::operator=(const TraceInt& rhs) {
	this->value = rhs.value;
	this->sorted_index_ = rhs.sorted_index_;
	this->TV_ = rhs.TV_;
	if (TV_ && TV_->vis_ && TV_->vis_->options.draw_options & DrawOption::Assignments)
		TV_->vis_->Draw(this->index_, Visualizer::DrawEventType::Assignment);
	
	if (TV_) ++TV_->assignment_count;
	return *this;
}

//COMPARISON
bool TraceInt::operator<(const TraceInt& rhs) const {
	if (TV_ && TV_->vis_ && TV_->vis_->options.draw_options & DrawOption::Comparisons)
		TV_->vis_->Draw(this->index_, rhs.index_, Visualizer::DrawEventType::Comparison);
	if (TV_ ) ++TV_->compare_count;
	return this->value < rhs.value;
}

//COMPARISON
bool TraceInt::operator>(const TraceInt& rhs) const {
	if (TV_ && TV_->vis_ && TV_->vis_->options.draw_options & DrawOption::Comparisons)
		TV_->vis_->Draw(this->index_, rhs.index_, Visualizer::DrawEventType::Comparison);
	if (TV_) ++TV_->compare_count;
	return this->value < rhs.value;
}

//SWAP
void swap(TraceInt& lhs, TraceInt& rhs) {
	if (lhs.TV_ && lhs.TV_->vis_ && lhs.TV_->vis_->options.draw_options & DrawOption::PreSwaps)
		lhs.TV_->vis_->Draw(lhs.index_, rhs.index_, Visualizer::DrawEventType::Swap);
	if (lhs.TV_) ++lhs.TV_->swap_count;
	std::swap(lhs, rhs);
	if (lhs.TV_ && lhs.TV_->vis_ && lhs.TV_->vis_->options.draw_options & DrawOption::PostSwaps)
		lhs.TV_->vis_->Draw(lhs.index_, rhs.index_, Visualizer::DrawEventType::Swap);
}

//SWAP
void iter_swap(const TraceVector<TraceInt>::iterator& _Left, const TraceVector<TraceInt>::iterator& _Right) {
	//printf("swap(%d(%d), %d(%d))\n", left.pointer_, left.vec_[left.pointer_], right.pointer_, right.vec_[right.pointer_]);
	if (_Left.vis_ && _Left.vis_->options.draw_options & DrawOption::PreSwaps)
		_Left.vis_->Draw(_Left.pointer_, _Right.pointer_, Visualizer::DrawEventType::Swap);
	if (_Left.vis_) ++_Left.vis_->tv.swap_count;
	std::swap(*_Left, *_Right);
	if (_Left.vis_ && _Left.vis_->options.draw_options & DrawOption::PostSwaps)
		_Left.vis_->Draw(_Left.pointer_, _Right.pointer_, Visualizer::DrawEventType::Swap);
}






































~-----------------------------------------------~
C:\Users\Josh\Documents\Visual Studio 2017\Projects\Sorting\Sorting\visualizer.cpp
~-----------------------------------------------~
#include "Visualizer.h"

//#pragma comment(linker,"\"/manifestdependency:type='win32' \
//name='Microsoft.Windows.Common-Controls' version='6.0.0.0' \
//processorArchitecture='*' publicKeyToken='6595b64144ccf1df' language='*'\"")

#include <windowsx.h>
#include <commctrl.h>
#pragma comment(lib, "Comctl32.lib")
#include <map>
#include <algorithm>
#include <thread>
#include <mutex> 
#include <assert.h>
#include <fstream>
#include <ctime>
#include <iomanip>

#include "resource.h"
#include "cyclesort.h"

#define PI      3.14159265358979323846

#define CTB_VOLUME 1000

////////////////////////////////////////////////////////////////////////////////////////////////////////
//if you add an enum value you need to add it to its correct STRINGIFY_ENUM macro to add it to the gui//
////////////////////////////////////////////////////////////////////////////////////////////////////////

STRINGIFY_ENUM(DrawOption,None,Accesses,Comparisons,Assignments,PreSwaps,PostSwaps)
STRINGIFY_ENUM(InitTypeValue,Regular,FewUnique,VeryFewUnique,NoUnique,Random,Normal)
STRINGIFY_ENUM(InitTypeOrder,Shuffled,FrayedAscending,FrayedDescending,SawtoothAscending,SawtoothDescending,VeryNearSorted,Reversed,Sorted,PipeOrgan,FrayedFront,FrayedMiddle,FrayedEnd,RandomFront,RandomMiddle,RandomEnd,Alternating,WorstCaseQuickSortMedianOf3)

STRINGIFY_ENUM(VisualizationType,BarGraph,FullBarGraph,ScatterPlot,ColorWheel,HorizontalPyramid,DisparityDots,Squares)
STRINGIFY_ENUM(ColorMode,Rainbow,RainbowHSV,BlackAndWhite,RedWhiteBlue,Gradient,HeatMap,Exploding,Heap)

////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////


MIDISoundPlayer Visualizer::midi_sound_player(Instrument::Voice_Oohs);

ATOM register_visualizer_control() {
	WNDCLASS wnd = { 0 };
	wnd.lpszClassName = VISUALIZERCLASSNAME;
	wnd.style = CS_GLOBALCLASS;
	wnd.lpfnWndProc = (WNDPROC)Visualizer::Proc;
	return RegisterClass(&wnd);
}

COLORREF getRainbowColor(unsigned i, unsigned steps, double center = 128, double width = 127, double phase = 220/*120*/) {
	if (phase == NULL) phase = 0;
	static double pi = 3.14159265358979323846;
	double frequency = 2 * pi / (double)steps;

	double red = sin(frequency * i + (2 * pi / 3) + phase) * width + center;
	double green = sin(frequency * i + 0 + phase) * width + center;
	double blue = sin(frequency * i + (4 * pi / 3) + phase) * width + center;

	/*red += 55;
	green -= 55;
	blue -= 55;*/

	red = red > 255 ? 255 : red < 0 ? 0 : red;
	green = green > 255 ? 255 : green < 0 ? 0 : green;
	blue = blue > 255 ? 255 : blue < 0 ? 0 : blue;

	return RGB((BYTE)red, (BYTE)green, (BYTE)blue);
}

void HBITMAPBlitToHdc(HDC hdcDst, HBITMAP hbmSrc, int x, int y, int w, int h) {
	HDC hdcScreen = GetDC(NULL);
	HDC hdcSrc = CreateCompatibleDC(hdcScreen);

	HBITMAP hbmOld = static_cast<HBITMAP>(SelectObject(hdcSrc, hbmSrc));
	BitBlt(hdcDst, x, y, w, h, hdcSrc, 0, 0, SRCCOPY);

	if (hbmOld) SelectObject(hdcSrc, hbmOld);
	DeleteDC(hdcSrc);
	ReleaseDC(NULL, hdcScreen);
}

void DrawBorderedText(HDC hdc, const RECT& rc, const std::wstring& wstr, COLORREF bordercol, COLORREF textcol) {
	SetTextColor(hdc, bordercol);
	SetBkMode(hdc, TRANSPARENT);

	int height = rc.bottom - rc.top;

	const std::vector<std::pair<int, int>> shifts = { {-1, -1}, {1, 1}, {-1, 1}, {1, -1}, {-1, 0}, {1, 0}, {0, 1}, {0, -1},
													  {-2, -2}, {2, 2}, {-2, 2}, {2, -2}, {-2, 0}, {2, 0}, {0, 2}, {0, -2} };
	for (int i = 0; i < (height > 26 ? 16 : 8); i++) {
		RECT trc = { rc.left + shifts[i].first, rc.top + shifts[i].second, rc.right + shifts[i].first, rc.bottom + shifts[i].second };
		ExtTextOut(hdc, rc.left + shifts[i].first, rc.top + shifts[i].second, ETO_CLIPPED, &trc, wstr.c_str(), wstr.size(), NULL);
	}

	SetTextColor(hdc, textcol);

	ExtTextOut(hdc, rc.left, rc.top, ETO_CLIPPED, &rc, wstr.c_str(), wstr.size(), NULL);
}

//justify left: -1, center: 0, right: 1
void DrawBorderedTextOnNextLine(HDC hdc, const std::wstring& wtext, RECT* rc_last_line, COLORREF bordercol, COLORREF textcol, int justify = -1) {
	SIZE sz;
	GetTextExtentPoint32(hdc, wtext.c_str(), wtext.size(), &sz);
	if (justify < 0) *rc_last_line = { rc_last_line->left, rc_last_line->bottom, rc_last_line->left + sz.cx, rc_last_line->bottom + sz.cy };
	else if (justify > 0) *rc_last_line = { rc_last_line->right - sz.cx, rc_last_line->bottom, rc_last_line->right, rc_last_line->bottom + sz.cy };
	else *rc_last_line = { rc_last_line->left, rc_last_line->bottom, rc_last_line->left + sz.cx, rc_last_line->bottom + sz.cy };
	DrawBorderedText(hdc, *rc_last_line, wtext, bordercol, textcol);
}

void get_centered_text_rect(HDC hdc, const std::wstring& wstr, RECT& rc, RECT* outrect) {
	SIZE sz;
	GetTextExtentPoint32(hdc, wstr.c_str(), wstr.size(), &sz);
	outrect->left = rc.left + (((rc.right - rc.left) - sz.cx) / 2);
	outrect->right = outrect->left + sz.cx;
	outrect->top = rc.top + (((rc.bottom - rc.top) - sz.cy) / 2);
	outrect->bottom = outrect->top + sz.cy;
}

Visualizer::Visualizer(HWND parent, HINSTANCE hinst, HMENU id, 
					   unsigned size, VisualizationType visualization_type, ColorMode color_mode, 
					   InitTypeValue init_type_value, InitTypeOrder init_type_order, DrawOption draw_options, 
					   const SortingAlgorithm& sort) {
	this->hinst = hinst;
	this->id = id;
	this->options.size = size;

	options.visualization_type = visualization_type;
	options.color_mode = color_mode;
	options.init_type_value = init_type_value;	
	options.init_type_order = init_type_order;
	options.draw_options = draw_options;

	this->sort = sort;

	active_screen_mode = ScreenMode::SortVisualizer;

	tv.setVisualizer(this);

	hwnd = CreateWindow(VISUALIZERCLASSNAME, L"", WS_VISIBLE | WS_CHILD, 0, 0, 0, 0, parent, (HMENU)id, hinst, this);

	ScopedVar<InitTypeOrder> scoped_init_type(options.init_type_order, InitTypeOrder::Sorted);
	init();

	DrawScreen();
}

void Visualizer::SetSort(const SortingAlgorithm& sort) {
	if (!sort.sort) throw std::exception("Invalid sort");
	if (is_initializing || this->tv_state == SortState::Sorting) return;
	this->sort = sort;
}

void Visualizer::RunSort() {
	if (is_initializing || this->tv_state == SortState::Sorting) return;
	std::thread a{ [](Visualizer* vis) {
		vis->init();
		vis->test_sort();

		while (vis->tv_state != SortState::Sorted) {
			std::this_thread::sleep_for(std::chrono::milliseconds(10));
		}

		SortRunData run_data(vis->GetSortName(), vis->options.size, vis->GetRuntime(), 
						vis->tv.compare_count, vis->tv.assignment_count, vis->tv.swap_count, vis->tv.access_count, 
						vis->options.GetInitTypeValueName(), vis->options.GetInitTypeOrderName());
		
		static std::mutex SortMutex;
		std::lock_guard<std::mutex> lock(SortMutex);

		Visualizer::SortTable.AddRow(run_data);		
		
		std::wofstream file;
		file.open("sorts.xls", std::ios::app);

		file << vis->GetSortName() << '\t';

		file << L"best:" << vis->sort.best_case << ',';
		file << L"avg:" << vis->sort.average_case << ',';
		file << L"worst:" << vis->sort.worst_case << ',';
		file << L"space:" << vis->sort.space << ',';
		file << L"stable:" << (vis->sort.is_stable ? L"Yes" : L"No") << '\t';

		auto t = std::time(nullptr);
		auto tm = *std::localtime(&t);
		file << std::put_time(&tm, L"%d-%m-%Y %H:%M:%S") << '\t';

		file << vis->GetSize() << '\t';
		file << (std::to_wstring(vis->timer.getElapsedMS()) + L"ms") << '\t';

		file << vis->tv.compare_count << '\t';
		file << vis->tv.assignment_count << '\t';
		file << vis->tv.swap_count << '\t';
		file << vis->tv.access_count << '\n';

		file.close();

		vis->DrawScreen();
	}, this };
	a.detach();
}

void Visualizer::DrawScreen() {
	DrawScreen(this, 0);
}

std::vector<unsigned>* Visualizer::GetInitializedList()  {
	init();
	return &v;
}

void Visualizer::init() {
	if (is_initializing || tv_state == SortState::Sorting) return;
	ScopedVar<bool> scoped_is_initializing(is_initializing, true);

	srand(clock());

	ScopedVar<DrawOption> scoped_draw_options(options.draw_options, (DrawOption)(options.bdraw_initialization ? (options.draw_options == DrawOption::None ? DrawOption::None : DrawOption::Assignments | DrawOption::PostSwaps) : DrawOption::None));

	v.clear();
	tv.clear();

	v.reserve((size_t)options.size);
	tv.reserve((size_t)options.size);

	timer.reset();
	tv.reset_counts();

	tv_state = (options.init_type_order & InitTypeOrder::Sorted) ? SortState::Inorder : SortState::Unsorted;

	//intialize elements (this stage doesn't get drawn (push_back not access/swap))
	Initializer::InitValues(&tv, options.size, options.init_type_value);
	DrawScreen();	

	Initializer::InitOrder(&tv, options.size, options.init_type_order);

	//sort sorted_pointers for elements with same value (stable sort test / tv has elements with equal values) 
	if (options.init_type_value != InitTypeValue::Regular) {
		TraceVector<TraceInt> temp(tv.size());
		{
			ScopedVar<DrawOption> scoped_draw_options(this->options.draw_options, DrawOption::None);
			std::map<unsigned, std::vector<TraceInt>> values;
			for (unsigned i = 0; i < tv.size(); i++)
				values[tv[i].value].push_back(tv[i]);
			
			for (auto &val : values) {
				std::sort(val.second.begin(), val.second.end(), [](const TraceInt& a, const TraceInt& b) { return a.sorted_index_ < b.sorted_index_; });
				for (unsigned i = 0; i < val.second.size(); i++) {
					temp[val.second[i].index_] = val.second[i];
				}
			}
		}
		tv = temp;
	}

	//copy into vector<int>
	for (unsigned i = 0; i < tv.size(); i++)
		v.push_back(tv[i]);

	tv.reset_counts();

	//draw any pending skipped draws
	if (options.bfast_draw) {
		if (num_skipped < num_draw_skips) {
			ScopedVar<unsigned> scoped_num_draw_skips(num_draw_skips, num_skipped);
			Draw(0, 0, DrawEventType::DrawSkipped);
		}
	}
}

void Visualizer::test_sort() {
	if (tv_state == SortState::Sorting || is_initializing) return;
	tv_state = SortState::Sorting;
	
	DrawScreen();

	std::this_thread::sleep_for(std::chrono::milliseconds(700));

	tv.reset_counts();

	if (options.bBenchmark) {
		std::thread a([&]() {
			timer.reset();
			timer.start();
			sort(v.begin(), v.end(), vcmp());
			timer.stop();
			if (!sorted(v.begin(), v.end(), vcmp())) printf("SORT FAILED!!!!!\n");
			//	MessageBox(NULL, L"Sort Failed", L"Failure", MB_OK);
		});
		a.detach();
	}

	std::thread b([&]() {
		sort(tv.begin(), tv.end(), tvcmp());
		tv_state = SortState::Sorted;
		midi_sound_player.StopAllNotes();
		DrawScreen();
	});
	b.detach();

	/*ScopedVar<unsigned long long> scoped_access_count(this->tv.access_count, this->tv.access_count);
	ScopedVar<unsigned long long> scoped_assignment_count(this->tv.assignment_count, this->tv.assignment_count);
	ScopedVar<unsigned long long> scoped_compare_count(this->tv.compare_count, this->tv.compare_count);
	ScopedVar<unsigned long long> scoped_swap_count(this->tv.swap_count, this->tv.swap_count);
	if (!sorted(tv.begin(), tv.end(), tvcmp())) printf("SORT FAILED!!!!!\n");*/	
}

void Visualizer::Draw(const DrawEventInfo& draw_event_info) {
	while (screen.IsResizing()) 
		std::this_thread::sleep_for(std::chrono::milliseconds(1));

	if (options.draw_options && screen.w > 0 && screen.h > 0) {
		if (options.bfast_draw) {
			if (num_skipped < num_draw_skips) {
				//keep track of the changes to draw them later				
				if (isDrawEventOn(draw_event_info.draw_event_type) && isDrawEventSingle(draw_event_info.draw_event_type) && isDrawEventChange(draw_event_info.draw_event_type))
					skipped_draws[num_skipped] = draw_event_info;

				++num_skipped;
				return;//must return to skip DrawScreen call
			}
		}

		//play sound
		if (options.sound_on) {
			Range<unsigned> nums(0, (unsigned)tv.vec_.size() - 1);

			/*if (options.bfast_draw) {
				std::vector<unsigned> skipped_values;
				for (auto i = 0; i < skipped_draws.size() && i < 10; i++) {
					if (isDrawEventSingle(skipped_draws[i].draw_event_type)) {
						skipped_values.push_back(tv.vec_[skipped_draws[i].ptr1]);
						if (isDrawEventDouble(skipped_draws[i].draw_event_type)) {
							skipped_values.push_back(tv.vec_[skipped_draws[i].ptr2]);
						}
					}
				}
				Visualizer::Play(skipped_values, nums);
			}*/			

			if (isDrawEventSingle(draw_event_info.draw_event_type)) {
				Visualizer::Play(tv.vec_[draw_event_info.ptr1], nums);
				if (isDrawEventDouble(draw_event_info.draw_event_type)) {
					Visualizer::Play(tv.vec_[(size_t)draw_event_info.ptr2], nums);
				}
			}
		}

		DrawEventInfo cpy_draw_event_info = draw_event_info;
		DrawScreen(this, &cpy_draw_event_info);		

		//we drew everything, so reset num_skipped
		if (options.bfast_draw) {
			num_skipped = 0;
		}
	}
}

double Visualizer::GetDrawSpeed() { return options.draw_speed_factor; };

void Visualizer::SetDrawSpeed(double new_speed_factor) {
	options.draw_speed_factor = new_speed_factor;	
	Resize();
}

void Visualizer::Resize() {
	GetClientRect(hwnd, &rcclient);

	screen.Resize(rcclient.right, rcclient.bottom);
//	FillBackground();

	if (screen.w && screen.h) {
		if (options.bfast_draw) {
			int num_skips = (int)((double)tv.size() *  options.draw_speed_factor / (double)screen.w);
			skipped_draws.resize(num_skips);
			num_draw_skips = num_skips;
		}

		DrawScreen();
	}
	else {
		skipped_draws.clear();
		num_draw_skips = 0;
		num_skipped = 0;
	}
}

void Visualizer::Play(unsigned v, const Range<unsigned>& range) {
	static Range<unsigned> freqrange(Options::note_min_frequency, Options::note_max_frequency);
	if (v < range.min || v > range.max)
		return;
	int note = range.MapTo(v, freqrange);
	midi_sound_player.PlayNote(note, Options::note_on_velocity, Options::note_off_velocity, Options::note_duration);
}

void Visualizer::Play(std::vector<unsigned>& values, const Range<unsigned>& range) {
	static Range<unsigned> freqrange(Options::note_min_frequency, Options::note_max_frequency);
	std::vector<char> notes;
	for (auto & v : values) {
		if (v < range.min || v > range.max)
			continue;
		int note = range.MapTo(v, freqrange);
		notes.push_back(note);
	}
	midi_sound_player.PlayNotes(notes, Options::note_on_velocity, Options::note_off_velocity, Options::note_duration);
}

bool Visualizer::Options::is_initializing = false;
HWND Visualizer::Options::hwnd = NULL;
std::set<HWND> Visualizer::Options::hwnds_MultiSelected;
HWND Visualizer::Options::hwnd_SortingAlgorithm = NULL;
HWND Visualizer::Options::hwnd_VisualizationType = NULL;
HWND Visualizer::Options::hwnd_ColorMode = NULL;
HWND Visualizer::Options::hwnd_Instrument = NULL;
std::map<UINT, HWND> Visualizer::Options::hwnd_DrawOptions;//map control id to control hwnd
std::map<UINT, DrawOption> Visualizer::Options::id_DrawOptions;//map control id to drawoption enum val
HWND Visualizer::Options::hwnd_InitTypeValues;//map control id to control hwnd
std::map<UINT, InitTypeValue> Visualizer::Options::id_InitTypeValue;//map control id to InitTypeValue enum val
HWND Visualizer::Options::hwnd_InitTypeOrdering;//map control id to control hwnd
std::map<UINT, InitTypeOrder> Visualizer::Options::id_InitTypeOrder;//map control id to InitTypeOrder enum val
HWND Visualizer::Options::hwnd_Size = NULL;
HWND Visualizer::Options::hwnd_FastDraw = NULL;
HWND Visualizer::Options::hwnd_DrawSpeed = NULL;
HWND Visualizer::Options::hwnd_SleepTime = NULL;
HWND Visualizer::Options::hwnd_Complexity = NULL;
HWND Visualizer::Options::hwnd_Counts = NULL;
HWND Visualizer::Options::hwnd_Runtime = NULL;
HWND Visualizer::Options::hwnd_Sound = NULL;
HWND Visualizer::Options::hwnd_NoteMinFrequency = NULL;
HWND Visualizer::Options::hwnd_NoteMaxFrequency = NULL;
HWND Visualizer::Options::hwnd_NoteOnVelocity = NULL;
HWND Visualizer::Options::hwnd_NoteOffVelocity = NULL;
HWND Visualizer::Options::hwnd_NoteDuration = NULL;
CustomTrackbar Visualizer::Options::ctb_Volume("volume", WS_VISIBLE | WS_CHILD, 199, 280, 64, 20, CTB_VOLUME,
	0, 127, 0, 1, 3,
	0, 0, CTB_BORDER | CTB_SMOOTH | CTB_STAY, {
		RGB(10, 10, 10), RGB(50, 50, 50), RGB(0, 0, 0), RGB(20, 20, 20),								// background/border/window name idle/highlight
		RGB(0, 255, 0), RGB(240, 240, 240), RGB(0, 255, 0), RGB(240, 240, 240),							// left/right channel left/right highlight
		RGB(127, 127, 127), RGB(127, 127, 127), RGB(127, 127, 127), 									// thumb background: idle/hover/selected
		RGB(10, 10, 10), RGB(10, 10, 10), RGB(10, 10, 10),			 									// thumb border: idle/hover/selected
		RGB(127, 127, 127), RGB(127, 127, 127), RGB(127, 127, 127)},									// thumb text: idle/hover/selected							
		NULL, NULL);

bool Visualizer::Options::sound_on = false;
unsigned char Visualizer::Options::note_min_frequency = 50;
unsigned char Visualizer::Options::note_max_frequency = 120;
unsigned char Visualizer::Options::note_on_velocity = 70;
unsigned char Visualizer::Options::note_off_velocity = 0;
int Visualizer::Options::note_duration = 60;

HWND Visualizer::hwnd_Table;
HWND Visualizer::hwnd_LVSortTable;
Table<Visualizer::SortRunData> Visualizer::SortTable;
std::map<Visualizer::SortRunData::ColumnId, std::wstring> Visualizer::SortRunData::ColumnNames = {
	{ Visualizer::SortRunData::ColumnId::name, L"Sort" },
	{ Visualizer::SortRunData::ColumnId::num_elements, L"Elements" },
	{ Visualizer::SortRunData::ColumnId::runtime, L"Runtime" },
	{ Visualizer::SortRunData::ColumnId::compares, L"Comparisons" },
	{ Visualizer::SortRunData::ColumnId::assigns, L"Assignments" },
	{ Visualizer::SortRunData::ColumnId::swaps, L"Swaps" },
	{ Visualizer::SortRunData::ColumnId::accesses, L"Accesses" },
	{ Visualizer::SortRunData::ColumnId::values, L"Values" },
	{ Visualizer::SortRunData::ColumnId::ordering, L"Ordering" }
};

Visualizer::Options::Options() {}

void Visualizer::Options::SetDrawOptions(DrawOption draw_option) {
	draw_options = draw_option;
}

void  Visualizer::Options::SetInitType(InitTypeValue init_type_value, InitTypeOrder init_type_order) {
	this->init_type_value = init_type_value;
	this->init_type_order = init_type_order;
}

std::wstring Visualizer::Options::GetInitTypeValueName() {
	return InitTypeValueNames[init_type_value];
}

std::wstring Visualizer::Options::GetInitTypeOrderName() {
	return InitTypeOrderNames[init_type_order];
}

Visualizer* Visualizer::getVisualizer(HWND hwnd) {
	return (Visualizer*)GetWindowLongPtr(hwnd, GWLP_USERDATA);
}

void Visualizer::Options::InitOptions(Visualizer* vis) {	
	SetWindowLongPtr(hwnd, GWLP_USERDATA, (LONG_PTR)vis);

	SetWindowPos(hwnd, HWND_TOP, 0, 0, 0, 0, SWP_NOSIZE | SWP_NOMOVE);

	////////////////////INITIALIZE CONTROLS//////////////////////////////

	bool all_selected_are_same = true;

	//init sorting algorithm
	all_selected_are_same = true;
	for (auto & a : Visualizer::Options::hwnds_MultiSelected) 
		if (getVisualizer(a)->GetSortName() != vis->GetSortName()) 
			all_selected_are_same = false;
	ComboBox_SetCurSel(vis->options.hwnd_SortingAlgorithm, all_selected_are_same ? ComboBox_FindString(vis->options.hwnd_SortingAlgorithm, 0, vis->GetSortName().c_str()) : -1);

	//init visualization type
	all_selected_are_same = true;
	for (auto & a : Visualizer::Options::hwnds_MultiSelected)
		if (getVisualizer(a)->options.visualization_type != vis->options.visualization_type)
			all_selected_are_same = false;
	ComboBox_SetCurSel(vis->options.hwnd_VisualizationType, all_selected_are_same ? vis->options.visualization_type : -1);

	//init color mode
	all_selected_are_same = true;
	for (auto & a : Visualizer::Options::hwnds_MultiSelected)
		if (getVisualizer(a)->options.color_mode != vis->options.color_mode) 
			all_selected_are_same = false;
	ComboBox_SetCurSel(vis->options.hwnd_ColorMode, all_selected_are_same ? (int)vis->options.color_mode : -1);

	//init visualization options (values)
	all_selected_are_same = true;
	for (auto & a : Visualizer::Options::hwnds_MultiSelected)
		if (getVisualizer(a)->options.init_type_value != vis->options.init_type_value) 
			all_selected_are_same = false;
	ComboBox_SetCurSel(vis->options.hwnd_InitTypeValues, all_selected_are_same ? (int)vis->options.init_type_value : -1);
	
	//init visualization options (ordering)
	all_selected_are_same = true;
	for (auto & a : Visualizer::Options::hwnds_MultiSelected)
		if (getVisualizer(a)->options.init_type_order != vis->options.init_type_order) 
			all_selected_are_same = false;
	ComboBox_SetCurSel(vis->options.hwnd_InitTypeOrdering, all_selected_are_same ? (int)vis->options.init_type_order : -1);
	

	/////////////////init draw options////////////////////////////////
	auto init_draw_options = [&](UINT id, DrawOption opt) {
		vis->options.id_DrawOptions[id] = opt;
		vis->options.hwnd_DrawOptions[id] = GetDlgItem(hwnd, id);
		Button_SetCheck(vis->options.hwnd_DrawOptions[id], vis->options.draw_options & opt ? BST_CHECKED : BST_UNCHECKED);
	};
	init_draw_options(CBTN_ACCESSES, DrawOption::Accesses);
	init_draw_options(CBTN_COMPARISONS, DrawOption::Comparisons);
	init_draw_options(CBTN_ASSIGNMENTS, DrawOption::Assignments);
	init_draw_options(CBTN_PRE_SWAP, DrawOption::PreSwaps);
	init_draw_options(CBTN_POST_SWAP, DrawOption::PostSwaps);
	/////////////////end init draw options////////////////////////////////

	//init size edit
	//TODO handle selections with different elements count options (size)
	vis->options.hwnd_Size = GetDlgItem(hwnd, EDC_SIZE);
	all_selected_are_same = true;
	for (auto & a : Visualizer::Options::hwnds_MultiSelected)
		if (getVisualizer(a)->options.size != vis->options.size)
			all_selected_are_same = false;
	all_selected_are_same = true;
	Edit_SetText(vis->options.hwnd_Size, all_selected_are_same ? std::to_wstring(vis->options.size).c_str() : L"");

	//init fast draw checkbox
	vis->options.hwnd_FastDraw = GetDlgItem(hwnd, CBTN_FAST_DRAW);
	Button_SetCheck(vis->options.hwnd_FastDraw, vis->options.bfast_draw ? BST_CHECKED : BST_UNCHECKED);
	//init draw speed edit
	vis->options.hwnd_DrawSpeed = GetDlgItem(hwnd, EDC_DRAW_SPEED_FACTOR);
	Edit_SetText(vis->options.hwnd_DrawSpeed, std::to_wstring((int)vis->options.draw_speed_factor).c_str());
	Edit_Enable(vis->options.hwnd_DrawSpeed, vis->options.bfast_draw);
	//init sleep time edit
	vis->options.hwnd_SleepTime = GetDlgItem(hwnd, EDC_SLEEP_TIME);
	Edit_SetText(vis->options.hwnd_SleepTime, std::to_wstring(vis->options.sleep_time).c_str());

	//init complexity checkbox
	vis->options.hwnd_Complexity = GetDlgItem(hwnd, CBTN_COMPLEXITY);
	Button_SetCheck(vis->options.hwnd_Complexity, vis->options.show_complexity);

	//init counts checkbox
	vis->options.hwnd_Counts = GetDlgItem(hwnd, CBTN_COUNTS);
	Button_SetCheck(vis->options.hwnd_Counts, vis->options.show_counts);

	//init runtime checkbox
	vis->options.hwnd_Runtime = GetDlgItem(hwnd, CBTN_RUNTIME);
	Button_SetCheck(vis->options.hwnd_Runtime, vis->options.show_runtime);

	//init sound checkbox
	vis->options.hwnd_Sound = GetDlgItem(hwnd, CBTN_SOUND);
	Button_SetCheck(vis->options.hwnd_Sound, vis->options.sound_on);

	//init instrument name
	SendMessage(vis->options.hwnd_Instrument, CB_SETCURSEL, vis->midi_sound_player.GetInstrument() - 1, NULL);

	//init min frequency
	vis->options.hwnd_NoteMinFrequency = GetDlgItem(hwnd, EDC_MIN_FREQ);
	Edit_SetText(vis->options.hwnd_NoteMinFrequency, std::to_wstring(vis->options.note_min_frequency).c_str());

	//init max frequency
	vis->options.hwnd_NoteMaxFrequency = GetDlgItem(hwnd, EDC_MAX_FREQ);
	Edit_SetText(vis->options.hwnd_NoteMaxFrequency, std::to_wstring(vis->options.note_max_frequency).c_str());

	//init note on velocity
	vis->options.hwnd_NoteOnVelocity = GetDlgItem(hwnd, EDC_ON_VELOCITY);
	Edit_SetText(vis->options.hwnd_NoteOnVelocity, std::to_wstring(vis->options.note_on_velocity).c_str());

	//init note off velocity
	vis->options.hwnd_NoteOffVelocity = GetDlgItem(hwnd, EDC_OFF_VELOCITY);
	Edit_SetText(vis->options.hwnd_NoteOffVelocity, std::to_wstring(vis->options.note_off_velocity).c_str());

	//init note duration
	vis->options.hwnd_NoteDuration = GetDlgItem(hwnd, EDC_NOTE_DURATION);
	Edit_SetText(vis->options.hwnd_NoteDuration, std::to_wstring(vis->options.note_duration).c_str());
}

BOOL CALLBACK Visualizer::Options::Proc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam) {
	Visualizer* vis = getVisualizer(hwnd);

	switch (message) {
		case WM_INITDIALOG: {
			Visualizer::Options::hwnd = hwnd;

			Visualizer* vis = (Visualizer*)lParam;

			//add sorting algorithms to combobox
			vis->options.hwnd_SortingAlgorithm = GetDlgItem(hwnd, CB_ALGORITHMS);
			for (auto alg : SortingAlgorithms)
				SendMessage(vis->options.hwnd_SortingAlgorithm, CB_ADDSTRING, NULL, (LPARAM)alg.second.name.c_str());

			//add InitTypeValues to combobox
			vis->options.hwnd_InitTypeValues = GetDlgItem(hwnd, CB_INIT_VALUES);
			for (auto name : InitTypeValueNames)
				SendMessage(vis->options.hwnd_InitTypeValues, CB_ADDSTRING, NULL, (LPARAM)name.second.c_str());

			//add InitTypeOrders to combobox
			vis->options.hwnd_InitTypeOrdering = GetDlgItem(hwnd, CB_INIT_ORDER);
			for (auto name : InitTypeOrderNames)
				SendMessage(vis->options.hwnd_InitTypeOrdering, CB_ADDSTRING, NULL, (LPARAM)name.second.c_str());

			//add visualization types to combobox
			vis->options.hwnd_VisualizationType = GetDlgItem(hwnd, CB_VISUALIZATION_TYPE);
			for (auto name : VisualizationTypeNames)
				SendMessage(vis->options.hwnd_VisualizationType, CB_ADDSTRING, NULL, (LPARAM)name.second.c_str());

			//add color modes to combobox
			vis->options.hwnd_ColorMode = GetDlgItem(hwnd, CB_COLOR_MODE);
			for (auto name : ColorModeNames)
				SendMessage(vis->options.hwnd_ColorMode, CB_ADDSTRING, NULL, (LPARAM)name.second.c_str());

			//add instruments to combobox
			vis->options.hwnd_Instrument = GetDlgItem(hwnd, CB_INSTRUMENTS);
			for (auto name : InstrumentNames)
				SendMessage(vis->options.hwnd_Instrument, CB_ADDSTRING, NULL, (LPARAM)name.second.c_str());

			//create volume trackbar
			ctb_Volume.Create(hwnd);
			Visualizer::midi_sound_player.SetVolume((char)ctb_Volume.current_val);

			ScopedVar<bool> scoped_is_initializing(is_initializing, true);
			InitOptions(vis);

			break;
		}
		case WM_COMMAND: {
			HWND ihwnd = (HWND)lParam;
			UINT iid = LOWORD(wParam);
			switch (HIWORD(wParam)) {
				case BN_CLICKED: {
					switch (iid) {
						case CBTN_ACCESSES:
						case CBTN_COMPARISONS:
						case CBTN_ASSIGNMENTS:
						case CBTN_PRE_SWAP: 
						case CBTN_POST_SWAP: {
							vis->options.SetDrawOptions((DrawOption)(vis->options.draw_options ^ vis->options.id_DrawOptions[iid]));
							for (auto & a : Visualizer::Options::hwnds_MultiSelected) getVisualizer(a)->options.SetDrawOptions(vis->options.draw_options);
							break;
						}
						case CBTN_FAST_DRAW: {
							vis->options.bfast_draw = Button_GetCheck(vis->options.hwnd_FastDraw);
							for (auto & a : Visualizer::Options::hwnds_MultiSelected) getVisualizer(a)->options.bfast_draw = vis->options.bfast_draw;
							vis->SetDrawSpeed(vis->GetDrawSpeed());
							for (auto & a : Visualizer::Options::hwnds_MultiSelected) getVisualizer(a)->SetDrawSpeed(vis->GetDrawSpeed());
							
							Edit_Enable(vis->options.hwnd_DrawSpeed, vis->options.bfast_draw);
							break;
						}
						case CBTN_COMPLEXITY: {
							vis->options.show_complexity = Button_GetCheck(vis->options.hwnd_Complexity);
							for (auto & a : Visualizer::Options::hwnds_MultiSelected) getVisualizer(a)->options.show_complexity = vis->options.show_complexity;
							break;
						}
						case CBTN_COUNTS: {
							vis->options.show_counts = Button_GetCheck(vis->options.hwnd_Counts);
							for (auto & a : Visualizer::Options::hwnds_MultiSelected) getVisualizer(a)->options.show_counts = vis->options.show_counts;
							break;
						}
						case CBTN_RUNTIME: {
							vis->options.show_runtime = Button_GetCheck(vis->options.hwnd_Runtime);
							for (auto & a : Visualizer::Options::hwnds_MultiSelected) getVisualizer(a)->options.show_runtime = vis->options.show_runtime;
							break;
						}
						case CBTN_SOUND: {
							vis->options.sound_on = Button_GetCheck(vis->options.hwnd_Sound);
							break;
						}
					}
					break;
				}
				case CBN_SELCHANGE: {
					int iindex = SendMessage(ihwnd, CB_GETCURSEL, NULL, NULL);
					std::wstring itext(255, L'\0');
					SendMessage(ihwnd, CB_GETLBTEXT, iindex, (LPARAM)&itext[0]);
					itext.erase(itext.find(L'\0'));
					switch (iid) {
						case CB_ALGORITHMS: {
							if (vis->is_initializing || vis->tv_state == SortState::Sorting) {
								int pos = ComboBox_FindString(ihwnd, 0, vis->GetSortName().c_str());
								if (pos == CB_ERR) throw(std::exception("Sort not found!"));
								ComboBox_SetCurSel(ihwnd, pos);
								MessageBeep(MB_OK);
							}
							else {
								vis->SetSort(SortingAlgorithms[GetSortNameKey(itext)]);
								for (auto & a : Visualizer::Options::hwnds_MultiSelected) getVisualizer(a)->SetSort(SortingAlgorithms[GetSortNameKey(itext)]);
							}
							break;
						}
						case CB_INIT_VALUES: {
							if (vis->is_initializing || vis->tv_state == SortState::Sorting) {
								MessageBeep(MB_OK);
								ComboBox_SetCurSel(ihwnd, vis->options.init_type_value);
							}
							else {
								vis->options.SetInitType((InitTypeValue)iindex);
								for (auto & a : Visualizer::Options::hwnds_MultiSelected) getVisualizer(a)->options.SetInitType(vis->GetInitTypeValue());
								
								ScopedVar<DrawOption> scoped_draw_options(vis->options.draw_options, DrawOption::None);
								vis->init();
								for (auto & a : Visualizer::Options::hwnds_MultiSelected) {//thread this???
									auto v = getVisualizer(a);
									ScopedVar<DrawOption> scoped(v->options.draw_options, DrawOption::None);
									v->init();
								}
							}
							break;
						}
						case CB_INIT_ORDER: {
							if (vis->is_initializing || vis->tv_state == SortState::Sorting) {
								MessageBeep(MB_OK);
								ComboBox_SetCurSel(ihwnd, vis->options.init_type_order);
							}
							else {
								vis->options.SetInitType((InitTypeOrder)iindex);
								for (auto & a : Visualizer::Options::hwnds_MultiSelected) getVisualizer(a)->options.SetInitType(vis->GetInitTypeOrder());

								ScopedVar<DrawOption> scoped_draw_options(vis->options.draw_options, DrawOption::None);
								vis->init();
								for (auto & a : Visualizer::Options::hwnds_MultiSelected) {//thread this???
									auto v = getVisualizer(a);
									ScopedVar<DrawOption> scoped(v->options.draw_options, DrawOption::None);
									v->init();
								}
							}
							break;
						}
						case CB_VISUALIZATION_TYPE: {
							vis->options.visualization_type = (VisualizationType)iindex;
							for (auto & a : Visualizer::Options::hwnds_MultiSelected) getVisualizer(a)->options.visualization_type = vis->options.visualization_type;
							break;
						}
						case CB_COLOR_MODE: {
							vis->options.color_mode = (ColorMode)iindex;
							for (auto & a : Visualizer::Options::hwnds_MultiSelected) getVisualizer(a)->options.color_mode = vis->options.color_mode;
							break;
						}
						case CB_INSTRUMENTS: {
							vis->midi_sound_player.SetInstrument((unsigned char)iindex);
							break;
						}
					}
					break;
				}
				case EN_CHANGE: {
					static bool block_change = false;
					if (block_change) {
					//	block_change = false;
						break;
					}
					std::wstring text(12, L'\0');
					text.resize(Edit_GetText(ihwnd, &text[0], 12));
					switch (iid) {
						case EDC_SIZE: {					
							if (vis->is_initializing || vis->tv_state == SortState::Sorting) {
								ScopedVar<bool> scoped_block_change(block_change, true);
								int start, end;
								SendMessage(ihwnd, EM_GETSEL, (WPARAM)&start, (LPARAM)&end);								
								SetWindowText(ihwnd, std::to_wstring(vis->options.size).c_str());
								SendMessage(ihwnd, EM_SETSEL, (WPARAM)start - 1, (LPARAM)end - 1);							
								MessageBeep(MB_OK);

								break;
							}

							static int min_val = 5;
							static int max_val = 10000000;
							int n = _wtoi(text.c_str());
							if (n < min_val) n = min_val;
							if (n > max_val) n = max_val;
							if (n != _wtoi(text.c_str())) {
								/*ScopedVar<bool> scoped_block_change(block_change, true);
								int start, end;
								SendMessage(ihwnd, EM_GETSEL, (WPARAM)&start, (LPARAM)&end);
								SetWindowText(ihwnd, std::to_wstring(n).c_str());
								SendMessage(ihwnd, EM_SETSEL, (WPARAM)start - 1, (LPARAM)end - 1);*/
								MessageBeep(MB_OK);
							}
							if (n != vis->options.size) {
								vis->options.size = n;
								for (auto & a : Visualizer::Options::hwnds_MultiSelected) getVisualizer(a)->options.size = vis->options.size;
						
								ScopedVar<DrawOption> scoped_draw_options(vis->options.draw_options, DrawOption::None);
								vis->init();
								vis->Resize();

								for (auto & a : Visualizer::Options::hwnds_MultiSelected) { 
									auto v = getVisualizer(a);
									ScopedVar<DrawOption> scoped(v->options.draw_options, DrawOption::None);
									v->init();
									v->Resize();
								}

							}

							break;
						}
						case EDC_DRAW_SPEED_FACTOR: {
							vis->options.draw_speed_factor = vis->options.default_draw_speed = _wtoi(text.c_str());
							for (auto & a : Visualizer::Options::hwnds_MultiSelected) getVisualizer(a)->options.draw_speed_factor = vis->options.draw_speed_factor;

							if (is_initializing) break;

							vis->Resize();
							for (auto & a : Visualizer::Options::hwnds_MultiSelected) getVisualizer(a)->Resize();

							break;
						}
						case EDC_SLEEP_TIME: {
							vis->options.sleep_time = _wtoi(text.c_str());
							for (auto & a : Visualizer::Options::hwnds_MultiSelected) getVisualizer(a)->options.sleep_time = vis->options.sleep_time;
							break;
						}
						case EDC_MIN_FREQ: { 
							vis->options.note_min_frequency = _wtoi(text.c_str());
							break; 
						}
						case EDC_MAX_FREQ: { 
							vis->options.note_max_frequency = _wtoi(text.c_str());
							break; 
						}
						case EDC_ON_VELOCITY: {
							vis->options.note_on_velocity = _wtoi(text.c_str());
							break;
						}
						case EDC_OFF_VELOCITY: {
							vis->options.note_off_velocity = _wtoi(text.c_str());
							break; 
						}
						case EDC_NOTE_DURATION: { 
							vis->options.note_duration = _wtoi(text.c_str());
							break; 
						}
					}
					break;
				}
				case CTB_CHANGE: {
					switch (iid) {
						case CTB_VOLUME: {
							Visualizer::midi_sound_player.SetVolume((char)ctb_Volume.current_val);

							vis->options.sound_on = (bool)ctb_Volume.current_val;

							if (ctb_Volume.current_val == 0) {								
								ctb_Volume.tcolor_scheme.border = RGB(255, 0, 0);
								ctb_Volume.tcolor_scheme.window_name_idle = RGB(255, 0, 0);
								ctb_Volume.tcolor_scheme.window_name_highlight = RGB(200, 0, 0);
							}
							else {								
								double min_deg = 0.0; //0 is red
								double max_deg = 120.0; //120 is green
								double value = (double)ctb_Volume.current_val / (double)ctb_Volume.max_val;
								double H = value * (max_deg - min_deg) + min_deg;

								COLORREF color = HSVtoRGB(H, 1.0, 1.0);

								ctb_Volume.tcolor_scheme.left_channel_idle = color;
								ctb_Volume.tcolor_scheme.left_channel_highlight = color;
								ctb_Volume.tcolor_scheme.border = RGB(0, 0, 0);
								ctb_Volume.tcolor_scheme.window_name_idle = RGB(0, 0, 0);
								ctb_Volume.tcolor_scheme.window_name_highlight = RGB(20, 20, 20);
							}
							break;
						}
					}
				}
			}
			if (is_initializing) break;

			vis->DrawScreen();
			for (auto & a : Visualizer::Options::hwnds_MultiSelected) getVisualizer(a)->DrawScreen();

			break;
		}
		case WM_CLOSE:
		case WM_DESTROY:{
			//save handles of selected visualizer
			HWND oldvis = Visualizer::Options::hwnd;		

			//save handles of multi selected visualizers
			std::vector<HWND> multi_hwnds;
			multi_hwnds.reserve(Visualizer::Options::hwnds_MultiSelected.size());
			for (auto & a : Visualizer::Options::hwnds_MultiSelected)
				multi_hwnds.push_back(a);

			//empty out selections
			Visualizer::Options::hwnd = NULL;
			Visualizer::Options::hwnds_MultiSelected.clear();

			//redraw selected screens (now marked as unselected)
			getVisualizer(oldvis)->DrawScreen();
			for (auto & a : multi_hwnds)
				getVisualizer(a)->DrawScreen();

			EndDialog(hwnd, 0);
		}
		default: return FALSE;
	}
	return TRUE;
}

void Visualizer::SortRunData::SortByColumnProc(ColumnId col_id, bool is_ascending) {
	SortRunLVCompareProcInfo srlvcpi = {col_id, is_ascending};
	ListView_SortItems(hwnd_LVSortTable, SortRunLVCompareProc, &srlvcpi);
}

void Visualizer::SortRunData::RowAddedProc(const Visualizer::SortRunData& row) {
	LVITEM lvi = {0};
	lvi.mask = LVIF_TEXT | LVIF_PARAM;
	lvi.cchTextMax = 240;
	lvi.iItem = 0;
	lvi.iSubItem = 0;
	lvi.lParam = (LPARAM)&row;

	unsigned col_id = 0;

	std::wstring ws = GetColumnDataAsString(row, SortRunData::ColumnId(col_id));
	lvi.pszText = const_cast<LPWSTR>(&ws[0]);
	int pos = ListView_InsertItem(hwnd_LVSortTable, &lvi);

	for (col_id = 1; col_id < row.GetColumnCount(); ++col_id) {
		ws = GetColumnDataAsString(row, SortRunData::ColumnId(col_id));
		lvi.pszText = const_cast<LPWSTR>(&ws[0]);
		ListView_SetItemText(hwnd_LVSortTable, pos, col_id, lvi.pszText);
	}	

	//Print(row);
}

int CALLBACK SortRunLVCompareProc(LPARAM lParam1, LPARAM lParam2, LPARAM lParamSort) {
	Visualizer::SortRunData* a = (Visualizer::SortRunData*)lParam1;
	Visualizer::SortRunData* b = (Visualizer::SortRunData*)lParam2;
	SortRunLVCompareProcInfo* info = (SortRunLVCompareProcInfo*)lParamSort;

	if (!a || !b || !info) return 0;

	bool less = Visualizer::SortRunData::CompareByColumn(*a, *b, info->col_id, info->is_ascending);

	return less ? -1 : 1;
}

BOOL CALLBACK Visualizer::SortRunData::Proc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam) {
	switch (message) {
		case WM_INITDIALOG: {
			hwnd_Table = hwnd;

			hwnd_LVSortTable = GetDlgItem(hwnd, LV_SORT_TABLE);

			SendMessage(hwnd_LVSortTable, LVM_SETEXTENDEDLISTVIEWSTYLE, 0, LVS_EX_FULLROWSELECT);

			LVCOLUMN col;
			col.mask = LVCF_TEXT | LVCF_WIDTH;

			auto insert_listview_column = [&col](HWND hwnd_ListView, ColumnId col_id, int width) {
				col.cx = width;

				std::wstring ws = SortRunData::GetColumnName(col_id);
				LPWSTR lpwstr = new wchar_t[ws.size() + 1];
				std::copy(ws.begin(), ws.end(), lpwstr);
				lpwstr[ws.size()] = '\0';
				col.pszText = lpwstr;

				ListView_InsertColumn(hwnd_ListView, (int)col_id, &col);
			};

			insert_listview_column(hwnd_LVSortTable, ColumnId::name, 220);
			insert_listview_column(hwnd_LVSortTable, ColumnId::num_elements, 70);
			insert_listview_column(hwnd_LVSortTable, ColumnId::runtime, 90);
			insert_listview_column(hwnd_LVSortTable, ColumnId::compares, 70);
			insert_listview_column(hwnd_LVSortTable, ColumnId::swaps, 70);
			insert_listview_column(hwnd_LVSortTable, ColumnId::assigns, 70);
			insert_listview_column(hwnd_LVSortTable, ColumnId::accesses, 70);
			insert_listview_column(hwnd_LVSortTable, ColumnId::values, 100);
			insert_listview_column(hwnd_LVSortTable, ColumnId::ordering, 100);

			break;
		}
		case WM_NOTIFY: {
			LPNMHDR hdr = (LPNMHDR)lParam;
			switch (hdr->code) {
				case LVN_COLUMNCLICK: {
					NMLISTVIEW* pListView = (NMLISTVIEW*)lParam;

					static int last_col = -1;
					static bool is_ascending = true;
					if (last_col != pListView->iSubItem) 
						is_ascending = true;
					else 
						is_ascending = !is_ascending;

					SortRunLVCompareProcInfo info;
					info.col_id = Visualizer::SortRunData::ColumnId(pListView->iSubItem);
					info.is_ascending = is_ascending;

					ListView_SortItems(hwnd_LVSortTable, SortRunLVCompareProc, &info);

					last_col = pListView->iSubItem;

					break;
				}
			}

			break;
		}
		case WM_CLOSE:
		case WM_DESTROY: {
			EndDialog(hwnd, 0);
		}
		default: return FALSE;
	}

	return TRUE;
}

LRESULT CALLBACK Visualizer::Proc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam) {
	Visualizer* vis = Visualizer::getVisualizer(hwnd);
	
	switch (message) {
		case WM_NCCREATE: {
			vis = (Visualizer*)(((LPCREATESTRUCT)lParam)->lpCreateParams);
			vis->hwnd = hwnd;
			SetWindowLongPtr(hwnd, GWLP_USERDATA, (LONG_PTR)vis);

			break;
		}
		case WM_PAINT: {
			DrawScreen(vis, (DrawEventInfo*)wParam);

			break;
		}
	/*	case WM_ERASEBKGND: {
			return TRUE;
		}*/
		case WM_SYSCOMMAND: {
			switch (wParam) {
				case SC_MAXIMIZE:
				case SC_MINIMIZE: {
					vis->Resize();
					vis->DrawScreen();
					break;
				}
			}

			break;
		}
		case WM_MOUSEMOVE: {
			if (!vis->mouse_in_client) {
				vis->mouse_in_client = true;
				TRACKMOUSEEVENT me;
				me.cbSize = sizeof(TRACKMOUSEEVENT);
				me.dwFlags = TME_LEAVE;
				me.hwndTrack = hwnd;
				me.dwHoverTime = 0;
				TrackMouseEvent(&me);

				vis->DrawScreen();
			}
			break;
		}
		case WM_MOUSELEAVE: 
		case WM_LBUTTONDOWN: 
		case WM_LBUTTONUP: {
			if (message == WM_MOUSELEAVE) {				
				vis->mouse_in_client = false;

				if (vis->options.draw_speed_factor != vis->options.GetDefaultDrawSpeed())
					vis->SetDrawSpeed(vis->options.GetDefaultDrawSpeed());

				vis->DrawScreen();				
			}
			else if (message == WM_LBUTTONDOWN) {
				if (vis->active_screen_mode == ScreenMode::SortVisualizer) {
					if (vis->is_initializing || vis->tv_state == SortState::Sorting) {
						vis->SetDrawSpeed(vis->options.GetClickedDrawSpeed());
					}
					else if (vis->options.draw_speed_factor != vis->options.GetDefaultDrawSpeed())
						vis->SetDrawSpeed(vis->options.GetDefaultDrawSpeed());
				}
			}
			else if (message == WM_LBUTTONUP) {
				if (vis->active_screen_mode == ScreenMode::SortVisualizer) {
					if (vis->is_initializing || vis->tv_state == SortState::Sorting) {
						vis->SetDrawSpeed(vis->options.GetDefaultDrawSpeed());
					}
					else {
						if (vis->options.draw_speed_factor != vis->options.GetDefaultDrawSpeed())
							vis->SetDrawSpeed(vis->options.GetDefaultDrawSpeed());
						else {
						//	vis->init();
							vis->RunSort();
						}
					}
				}
			}
			break;
		}
		case WM_RBUTTONUP: {
			if (vis->active_screen_mode == ScreenMode::SortVisualizer) {
				/*SetWindowLongPtr(vis->GetHWND(), GWLP_WNDPROC, (LONG)vis->chart.Proc);
				LPCREATESTRUCT lpcreate = new CREATESTRUCT();
				lpcreate->lpCreateParams = &vis->chart;
				SendMessage(hwnd, WM_NCCREATE, NULL, (LPARAM)&lpcreate);				
				delete lpcreate;*/
				
				if (Visualizer::Options::hwnd == NULL) {
					CreateDialogParam(GetModuleHandle(NULL), MAKEINTRESOURCE(IDD_OPTIONS), GetParent(hwnd), (DLGPROC)Options::Proc, (LPARAM)vis);
				}
				else {
					if (Visualizer::Options::hwnd != hwnd && GetAsyncKeyState(VK_CONTROL) < 0) {
						if (Visualizer::Options::hwnds_MultiSelected.find(hwnd) == Visualizer::Options::hwnds_MultiSelected.end())
							Visualizer::Options::hwnds_MultiSelected.insert(hwnd);
						else
							Visualizer::Options::hwnds_MultiSelected.erase(hwnd);

						Visualizer::Options::InitOptions(getVisualizer(Visualizer::Options::hwnd));

						vis->DrawScreen();
					}
					else {
						//save handles of multi selected visualizers (to redraw them later)
						std::vector<HWND> multi_hwnds;
						for (auto & a : Visualizer::Options::hwnds_MultiSelected)
							multi_hwnds.push_back(a);

						Visualizer::Options::hwnds_MultiSelected.clear();

						//redraw selected screens (now marked as unselected)
						for (auto & a : multi_hwnds)
							getVisualizer(a)->DrawScreen();

						Visualizer* oldvis = getVisualizer(Options::hwnd);
						Options::InitOptions(vis);
						if (oldvis) oldvis->DrawScreen();
						ShowWindow(oldvis->options.hwnd, SW_SHOWNORMAL);
					}
				}
			}
			
			break;
		}
		case WM_SIZE: {
			vis->Resize();

			break;
		}
		case WM_CLOSE:
		case WM_DESTROY: {				
			if (vis) {
				delete vis;
				vis = 0;
			}
			break;
		}
	}

	return DefWindowProc(hwnd, message, wParam, lParam);
}

void Visualizer::reset_last_draw() {
	last_draw.ptr1 = 0;
	last_draw.ptr2 = 0;
	last_draw.draw_event_type = DrawEventType::NoDraw;
	last_draw_value.ptr1 = 0;
	last_draw_value.ptr2 = 0;
}

bool Visualizer::isCursorInClient() {
	RECT rcclient;
	GetClientRect(hwnd, &rcclient);
	return PtInRect(&rcclient, getclientcursorpos(hwnd));
}

void Visualizer::FillBackground() {
	COLORREF* p = (COLORREF*)screen.GetData(), i, size = screen.bmp_size / sizeof(*p);
	for (i = 0; i < size; ++i) p[i] = screen.back_color;
}

COLORREF Visualizer::GetColor(const std::vector<TraceInt>* arr, unsigned i, const DrawEventInfo* draw_event_info, void* param) {
	COLORREF col = RGB(0,0,0);

	bool is_leftptr = isDrawEventSingle(draw_event_info->draw_event_type) ? i == draw_event_info->ptr1 : false;
	bool is_rightptr = isDrawEventDouble(draw_event_info->draw_event_type) ? i == draw_event_info->ptr2 : false;

	if (draw_event_info->draw_event_type == DrawEventType::NoDraw) return screen.back_color;

	if (options.color_mode == ColorMode::Rainbow) {
		if (is_leftptr || is_rightptr)
			return RGB(255, 255, 255);//white
		else {
			return getRainbowColor((unsigned)arr->at(i).sorted_index_, (unsigned)arr->size());//rainbow
		}
	}
	if (options.color_mode == ColorMode::RainbowHSV) {
		if (is_leftptr || is_rightptr)
			return RGB(255, 255, 255);//white
		else {
			double min_deg = 0.0;
			double max_deg = 360.0;
			double value = (double)arr->at(i).sorted_index_ / (double)arr->size();
			double H = value * (max_deg - min_deg) + min_deg;
			return HSVtoRGB(H, 1.0, 1.0);			
		}
	}
	else if (options.color_mode == ColorMode::BlackAndWhite) {
		if (is_leftptr || is_rightptr)
			return RGB(127, 127, 127);//gray
		else 
			return RGB(255, 255, 255);//white
	}
	else if (options.color_mode == ColorMode::RedWhiteBlue) {
		COLORREF leftcol, rightcol, defcol;
		leftcol = rightcol = defcol = RGB(255, 255, 255);//white
		if (draw_event_info->draw_event_type == DrawEventType::Swap) {
			leftcol = RGB(0, 255, 0);//green
			rightcol = RGB(0, 255, 0);//green
		}
		else if (draw_event_info->draw_event_type == DrawEventType::Assignment) {
			leftcol = RGB(255, 255, 0);//yellow
			rightcol = RGB(255, 255, 0);//yellow
		}
		else if (draw_event_info->draw_event_type == DrawEventType::Comparison) {
			leftcol = RGB(0, 0, 255);//blue
			rightcol = RGB(255, 0, 0);//red
		}
		else if (draw_event_info->draw_event_type == DrawEventType::Access) {
			leftcol = RGB(127, 127, 127);//gray
			rightcol = RGB(127, 127, 127);//gray
		}
		return is_leftptr ? leftcol : is_rightptr ? rightcol : defcol;
	}
	else if (options.color_mode == ColorMode::Gradient) {
		if (is_leftptr || is_rightptr)
			return RGB(200, 200, 200);//light gray
		else {
			Range<int> range = { 0, (int)arr->size() - 1 };
			unsigned dist = uint_diff(arr->at(i).sorted_index_, arr->at(i).index_);

			//if element is in place color it a special color
			if (dist == 0)
				return RGB(0, 127, 255);//"pure" blue (Azure)
			
			//calc color gradient based on distance from sorted position (blue[close] -> red[far])
			double min_deg = 240.0; //240 is blue hue
			double max_deg = 360.0; //360 is red		
			double value = (double)dist / (double)arr->size();
			double H = value * (max_deg - min_deg) + min_deg;

			return HSVtoRGB(H, 1.0, 1.0);
		}
	}
	else if (options.color_mode == ColorMode::Exploding) {		
		static std::map<size_t, size_t> access;

		if (is_leftptr || is_rightptr) {
			const int decay_rate = 2;
			for (auto & a : access)
				a.second -= a.second < decay_rate ? a.second : decay_rate;
			access[i] = arr->size();
		}

		double min_deg = 0.0;
		double max_deg = 360.0;
		double value = (double)access[i] / (double)arr->size();
		if (value) {
			double H = value * (max_deg - min_deg) + min_deg;
			return HSVtoRGB(H, 1.0, 1.0);
		}
		else 
			return HSVtoRGB(0, 0.0, 1.0);
	}
	else if (options.color_mode == ColorMode::Heap) {
		int height = floor(log2(i + 1)) + 1;
		int max_height = floor(log2(arr->size())) + 1;

		double min_deg = 0.0;
		double max_deg = 360.0;
		double value = (double)height / (double)max_height;
		double H = value * (max_deg - min_deg) + min_deg;

		return HSVtoRGB(H, 1.0, 1.0);
	}
	else if (options.color_mode == ColorMode::HeatMap) {	
		static std::map<size_t, size_t> access;

		if (is_leftptr || is_rightptr) {
			const int decay_rate = 1;
			for (auto & a : access)
				a.second -= a.second < decay_rate ? a.second : decay_rate;
			access[i] = std::min(access[i] + arr->size() / 5, arr->size());
		}

		double min_deg = 0.0;
		double max_deg = 120.0;
		double value = 1.0 - (double)access[i] / (double)arr->size();
		double H = value * (max_deg - min_deg) + min_deg;
		return HSVtoRGB(H, 1.0, 1.0);
	}

	throw std::exception("Unhandled/unimplemented ColorMode case");

	return col;
}

void Visualizer::DrawScreenText(Visualizer* vis, HWND hwnd, HDC hDCmem) {
	RECT rcclient;
	GetClientRect(hwnd, &rcclient);

	//draw initializing text while initializing
	if (vis->is_initializing) {
		int font_size = std::max((int)rcclient.bottom / 15, 14);
		HFONT initializing_font = CreateFont(font_size, 0, 0, 0, FW_EXTRABOLD, 0, 0, 0, 0, 0, 0, NONANTIALIASED_QUALITY, 0, L"Arial");
		DeleteObject(SelectObject(hDCmem, initializing_font));

		std::wstring wstr = L"initializing...";

		RECT rc;
		get_centered_text_rect(hDCmem, wstr, rcclient, &rc);

		DrawBorderedText(hDCmem, rc, wstr, RGB(0, 0, 0), RGB(255, 255, 255));

		DeleteFont(initializing_font);
	}

	//draw info text to screen
	{
		int font_size = std::max((int)rcclient.bottom / 30, 12);
		HFONT screen_font = CreateFont(font_size, 0, 0, 0, FW_NORMAL, 0, 0, 0, 0, 0, 0, ANTIALIASED_QUALITY, 0, L"Verdana");
		DeleteObject(SelectObject(hDCmem, screen_font));

		std::wstring wtext;
		RECT rctextlocation;
		SIZE sz;

		int xoff = 5;
		int yoff = 3;

		COLORREF textcolor = RGB(255, 255, 255);
		COLORREF bordercolor = RGB(0, 0, 0);

		/////////////////////////////////////////////////////////////////
		auto format_num_with_commas = [](std::wstring num) -> std::wstring {
			int pos = num.length() - 3;
			while (pos > 0) {
				num.insert(pos, L",");
				pos -= 3;
			}
			return num;
		};

		//draw sort name
		wtext = vis->sort.name
			+ L" (" + format_num_with_commas(std::to_wstring(vis->options.size)) + L" Elements ["
			+ vis->options.GetInitTypeValueName() + L" Values, "
			+ vis->options.GetInitTypeOrderName() + L" List])";
		GetTextExtentPoint32(hDCmem, wtext.c_str(), wtext.size(), &sz);
		rctextlocation = {xoff, yoff, sz.cx + xoff, sz.cy + yoff};
		DrawBorderedText(hDCmem, rctextlocation, wtext, bordercolor, textcolor);

		bool BST_INDETERMINATE_COND = vis->tv_state == SortState::Sorted || vis->isCursorInClient();
		if (vis->options.show_counts) {
			if (vis->options.show_counts == BST_CHECKED || BST_INDETERMINATE_COND) {
				//draw comparison count
				wtext = L"Comparisons: " + format_num_with_commas(std::to_wstring(vis->tv.compare_count));
				DrawBorderedTextOnNextLine(hDCmem, wtext, &rctextlocation, bordercolor, textcolor);

				//draw access count
				wtext = L"Accesses: " + format_num_with_commas(std::to_wstring(vis->tv.access_count));
				DrawBorderedTextOnNextLine(hDCmem, wtext, &rctextlocation, bordercolor, textcolor);

				//draw assignment count
				wtext = L"Assignments: " + format_num_with_commas(std::to_wstring(vis->tv.assignment_count));
				DrawBorderedTextOnNextLine(hDCmem, wtext, &rctextlocation, bordercolor, textcolor);

				//draw swap count
				wtext = L"Swaps: " + format_num_with_commas(std::to_wstring(vis->tv.swap_count));
				DrawBorderedTextOnNextLine(hDCmem, wtext, &rctextlocation, bordercolor, textcolor);
			}
		}

		//draw runtime
		if (vis->options.show_runtime) {
			if (vis->options.show_runtime == BST_CHECKED || BST_INDETERMINATE_COND) {
				if (true || vis->tv_state == SortState::Sorted) {
					double runtimems = vis->timer.getElapsedMS();
					wtext = (runtimems > 0.0 ? L"Runtime: " + std::to_wstring(runtimems) + L"ms" : vis->tv_state == SortState::Sorting ? L"Sorting..." : L"");
					DrawBorderedTextOnNextLine(hDCmem, wtext, &rctextlocation, bordercolor, textcolor);
				}
				else if (vis->tv_state == SortState::Sorting) {
					wtext = L"Sorting...";
					DrawBorderedTextOnNextLine(hDCmem, wtext, &rctextlocation, bordercolor, textcolor);
				}
				else if (vis->is_initializing) {
					wtext = L"Initializing...";
					DrawBorderedTextOnNextLine(hDCmem, wtext, &rctextlocation, bordercolor, textcolor);
				}
			}
		}

		//////////////////////////////////////////////////////////////////

		//Draw Complexity (on right size, right justified)
		if (vis->options.show_complexity) {
			if (vis->options.show_complexity == BST_CHECKED || BST_INDETERMINATE_COND) {
				wtext = L"Complexity";
				GetTextExtentPoint32(hDCmem, wtext.c_str(), wtext.size(), &sz);
				rctextlocation = {rcclient.right - xoff - sz.cx, yoff, rcclient.right - xoff, sz.cy + yoff};
				DrawBorderedText(hDCmem, rctextlocation, wtext, RGB(0, 0, 0), RGB(255, 255, 255));

				static std::vector<std::wstring> TimeComplexityRanks = {L"O(n)", L"O(n log n)", L"O(n log\u00B2 n)", L"colorfiller", L"O(n\u00B2)"};
				static std::vector<std::wstring> SpaceComplexityRanks = {L"O(1)", L"O(log n)", L"O(n)"};

				//red to green
				auto GetComplexityColor = [](std::wstring complexity, const std::vector<std::wstring>& ComplexityRanks, COLORREF defaultcolor) -> COLORREF {
					//check if its one of the badsorts and just make the color red
					if (complexity == L"O(n^(log n))" || complexity == L"O(n!)" || complexity == L"O(n^2.7095)" ||
						complexity == L"O((n + 1)!)" || complexity == L"O(\u221E)")
						return RGB(255, 0, 0);

					//space complexity is n^2 make color red
					if (ComplexityRanks.size() == 3 && complexity == L"O(n\u00B2)") return RGB(255, 0, 0);

					auto pos = std::find(ComplexityRanks.begin(), ComplexityRanks.end(), complexity);
					if (pos == ComplexityRanks.end())
						return defaultcolor;

					double value = 1.0 - ((double)std::distance(ComplexityRanks.begin(), pos)) / (double)(ComplexityRanks.size() - 1);
					//value[0.0 - 1.0] * 120 picks a hue between 0.0(red) and 120.0(green)
					double H = value * 120, S = 1.0, V = 1.0;
					return HSVtoRGB(H, S, V);
				};

				std::wstring complexityStr = L"";
				COLORREF ComplexityColor;

				//draw best case
				complexityStr = vis->sort.best_case;
				wtext = L" Best: " + complexityStr;
				ComplexityColor = GetComplexityColor(complexityStr, TimeComplexityRanks, textcolor);
				DrawBorderedTextOnNextLine(hDCmem, wtext, &rctextlocation, bordercolor, ComplexityColor, 1);

				//draw average case
				complexityStr = vis->sort.average_case;
				wtext = L" Average: " + complexityStr;
				ComplexityColor = GetComplexityColor(complexityStr, TimeComplexityRanks, textcolor);
				DrawBorderedTextOnNextLine(hDCmem, wtext, &rctextlocation, bordercolor, ComplexityColor, 1);

				//draw worst case
				complexityStr = vis->sort.worst_case;
				wtext = L" Worst: " + complexityStr;
				ComplexityColor = GetComplexityColor(complexityStr, TimeComplexityRanks, textcolor);
				DrawBorderedTextOnNextLine(hDCmem, wtext, &rctextlocation, bordercolor, ComplexityColor, 1);

				//draw space
				complexityStr = vis->sort.space;
				wtext = L" Space: " + complexityStr;
				ComplexityColor = GetComplexityColor(complexityStr, SpaceComplexityRanks, textcolor);
				DrawBorderedTextOnNextLine(hDCmem, wtext, &rctextlocation, bordercolor, ComplexityColor, 1);

				//draw stable
				wtext = std::wstring(L" Stable: ") + (vis->sort.is_stable ? L"Yes" : L"No");
				DrawBorderedTextOnNextLine(hDCmem, wtext, &rctextlocation, bordercolor, (vis->sort.is_stable ? RGB(0, 255, 0) : RGB(255, 0, 0)), 1);
			}
		}

		DeleteFont(screen_font);
	}
}

void Visualizer::DrawScreen(Visualizer* vis, DrawEventInfo* draw_event_info) {
	//We access the internal tracevector array directly, so we don't have to worry about changing any of our counts during drawing stage
	/*ScopedVar<unsigned int> scoped_compare_count(vis->tv.compare_count, vis->tv.compare_count);
	ScopedVar<unsigned int> scoped_access_count(vis->tv.access_count, vis->tv.access_count);
	ScopedVar<unsigned int> scoped_assignment_count(vis->tv.assignment_count, vis->tv.assignment_count);
	ScopedVar<unsigned int> scoped_swap_count(vis->tv.swap_count, vis->tv.swap_count);*/

	HWND hwnd = vis->GetHWND();

	Benchmark bm;
	bm.start();

	RECT rcclient;
	GetClientRect(hwnd, &rcclient);

	if (!rcclient.right || !rcclient.bottom) return;

	HDC hdc = GetDC(hwnd);

	HDC hdcmem = CreateCompatibleDC(hdc);

	HBITMAP hbmScreen, hbmOldBitmap;
	hbmScreen = CreateCompatibleBitmap(hdc, rcclient.right, rcclient.bottom);
	hbmOldBitmap = (HBITMAP)SelectObject(hdcmem, hbmScreen);

	//draw screen
	if (vis->active_screen_mode == ScreenMode::SortVisualizer) {

		bool no_draw_event_info = draw_event_info ? false : true;
		if (no_draw_event_info) draw_event_info = new DrawEventInfo{0, 0, DrawEventType::Redraw};
		if (vis->tv.vec_.size()) {
			switch (vis->options.visualization_type) {
				case VisualizationType::BarGraph:
				case VisualizationType::FullBarGraph:
				case VisualizationType::HorizontalPyramid: DrawBarGraph(vis, hwnd, hdcmem, draw_event_info); break;
				case VisualizationType::ScatterPlot: DrawScatterPlot(vis, hwnd, hdcmem, draw_event_info); break;
				case VisualizationType::DisparityDots: DrawDisparityDots(vis, hwnd, hdcmem, draw_event_info); break;
				case VisualizationType::ColorWheel: DrawColorWheel(vis, hwnd, hdcmem, draw_event_info); break;
				case VisualizationType::Squares: DrawSquares(vis, hwnd, hdcmem, draw_event_info); break;
			}
		}
		if (no_draw_event_info) delete draw_event_info;

		DrawScreenText(vis, hwnd, hdcmem);
	}

	//highlight options selection
	if (vis == getVisualizer(Options::hwnd)) {
		COLORREF framecolor = RGB(0, 255, 0);
		HBRUSH framebrush = CreateSolidBrush(framecolor);
		RECT framerect = rcclient;
		FrameRect(hdcmem, &framerect, framebrush);
		InflateRect(&framerect, -1, -1);
		FrameRect(hdcmem, &framerect, framebrush);
		InflateRect(&framerect, -1, -1);
		FrameRect(hdcmem, &framerect, framebrush);
		DeleteObject(framebrush);
	}
	else if (Visualizer::Options::hwnds_MultiSelected.find(hwnd) != Visualizer::Options::hwnds_MultiSelected.end()) {
		COLORREF framecolor = RGB(0, 0, 255);
		HBRUSH framebrush = CreateSolidBrush(framecolor);
		RECT framerect = rcclient;
		FrameRect(hdcmem, &framerect, framebrush);
		InflateRect(&framerect, -1, -1);
		FrameRect(hdcmem, &framerect, framebrush);
		InflateRect(&framerect, -1, -1);
		FrameRect(hdcmem, &framerect, framebrush);
		DeleteObject(framebrush);
	}

	//draw the screen
	BitBlt(hdc, 0, 0, rcclient.right, rcclient.bottom, hdcmem, 0, 0, SRCCOPY);

	//cleanup
	SelectObject(hdcmem, hbmOldBitmap);
	DeleteObject(hbmScreen);

	DeleteDC(hdcmem);
	ReleaseDC(hwnd, hdc);

	bm.stop();
//	printf("%d           \r", bm.getElapsed());
}

void Visualizer::DrawBarGraph(Visualizer* vis, HWND hwnd, HDC hdc, DrawEventInfo* draw_event_info) {
	std::vector<TraceInt>* arr = &vis->tv.vec_;

	double wf = (double)vis->screen.w / (double)arr->size();
	double hf = ((double)vis->screen.h / (double)arr->size());

	auto DrawBar = [&](unsigned i) {
		if (i >= arr->size()) return;
		unsigned bar_height = (unsigned)(hf * (double)(arr->at(i)));

		unsigned x_start = (unsigned)std::ceil(wf * (double)i);
		unsigned x_end = std::max((unsigned)std::ceil(wf * (double)(i + 1)), x_start + 1);

		unsigned y_start = 0;//bottom
		unsigned y_end = 0;//top
		if (vis->options.visualization_type == VisualizationType::BarGraph) {
			y_start = vis->screen.h - 1;
			y_end = vis->screen.h - bar_height;
		}
		else if (vis->options.visualization_type == VisualizationType::HorizontalPyramid) {
			y_end = (vis->screen.h - bar_height + 1) / 2;
			y_start = y_end + bar_height;
		}
		else if (vis->options.visualization_type == VisualizationType::FullBarGraph) {
			y_start = vis->screen.h - 1;
			y_end = 0;
		}

		COLORREF bar_color = vis->GetColor(arr, i, draw_event_info);

		/*RECT bar_rect = { x_start, y_end, x_end, y_start };
		RECT back_rect = { x_start, 0, x_end, y_end};
		HBRUSH back_brush = CreateSolidBrush(vis->screen.back_color);
		HBRUSH bar_brush = CreateSolidBrush(bar_color);
		FillRect(hdc, &back_rect, back_brush);		
		FillRect(hdc, &bar_rect, bar_brush);
		DeleteObject(back_brush);
		DeleteObject(bar_brush);*/
		
		for (unsigned y = 0; y < vis->screen.h; ++y) {
			for (unsigned x = x_start; x < x_end && x < vis->screen.w; ++x) {
				int pos = y * vis->screen.stride + x * 4;

				COLORREF col = (y <= y_start && y > y_end) ? bar_color : vis->screen.back_color;
				
				if (vis->screen.GetData()) {
					vis->screen.SetData(pos + 2, GetRValue(col));
					vis->screen.SetData(pos + 1, GetGValue(col));
					vis->screen.SetData(pos + 0, GetBValue(col));
				}
			}
		}
	};

	///////////////////////////////////////////////////////////////////////////////////////
	//nothing specific to draw so draw the whole thing (no highlights)
	if (true || draw_event_info->draw_event_type == DrawEventType::Redraw) {
		vis->reset_last_draw();
		vis->num_skipped = 0;

		//only paint once per column of pixels (step over the rest, they would just get painted over anyways)
		double step = std::max((double)arr->size() / (double)vis->screen.w, 1.0);
		unsigned count = std::min(arr->size(), (unsigned)vis->screen.w);
		for (unsigned i = 0; i < count; ++i) {
			DrawBar((unsigned)((double)i * step));			
		}
	}
	else { //only draw the changes
		//draw anything that was skipped and draw only once per pixel column
		if (vis->options.bfast_draw && vis->num_skipped > 0) {
			ScopedVar<Visualizer::DrawEventType> scoped_draw_event_type(draw_event_info->draw_event_type, DrawEventType::DrawSkipped);
	
			//number of skipped draws exceeds the number of pixel columns?
			if (vis->num_skipped >= vis->screen.w) {
				//TODO fix draw gaps
				long double step = (double)arr->size() / ((double)vis->screen.w * 1.0);// * 1.5 seems to fix draw gaps (?caused by precision error?)
				
				//crush each each index into its pixel column(s)
				std::set<unsigned> cols;
				for (unsigned i = 0; i < vis->skipped_draws.size(); i++) {
					cols.insert((unsigned)((long double)vis->skipped_draws[i].ptr1 / step));
					if (isDrawEventDouble(vis->skipped_draws[i].draw_event_type))
						cols.insert((unsigned)((long double)vis->skipped_draws[i].ptr2 / step));
				}
				//draw each pixel column(s)
				for (auto a : cols)
					DrawBar((unsigned)(step * (long double)a));
			}
			else {
				for (unsigned i = 0; i < vis->skipped_draws.size(); i++) {
					DrawBar(vis->skipped_draws[i].ptr1);
					if (isDrawEventDouble(vis->skipped_draws[i].draw_event_type))
						DrawBar(vis->skipped_draws[i].ptr2);
				}
			}
		}

		//draw current change
		if (isDrawEventSingle(draw_event_info->draw_event_type)) {
			DrawBar(draw_event_info->ptr1);
			if (isDrawEventDouble(draw_event_info->draw_event_type)) {
				DrawBar(draw_event_info->ptr2);
			}
		}
		
		//redraw last change
		if (isDrawEventSingle(vis->last_draw.draw_event_type)) {
			{
				ScopedVar<DrawEventType> scoped_last_draw_draw_event_type(vis->last_draw.draw_event_type, DrawEventType::DrawSkipped);
				DrawBar(vis->last_draw.ptr1);
			}
			if (isDrawEventDouble(vis->last_draw.draw_event_type)) {
				ScopedVar<DrawEventType> scoped_last_draw_draw_event_type(vis->last_draw.draw_event_type, DrawEventType::DrawSkipped);
				DrawBar(vis->last_draw.ptr2);
			}
		}	

		vis->last_draw.ptr1 = draw_event_info->ptr1;
		vis->last_draw.ptr2 = draw_event_info->ptr2;
		vis->last_draw.draw_event_type = draw_event_info->draw_event_type;
	}

	///////////////////////////////////////////////////////////////////////////////////////

	BITMAPINFOHEADER bmih = { sizeof(BITMAPINFOHEADER), (int)((long long)vis->screen.w), (int)(-(long long)vis->screen.h), 1, 32, BI_RGB, 0, 0, 0, 0, 0 };
	BITMAPINFO bmi = { bmih, 0, 0, 0, 0 };
	HBITMAP hbmp = CreateDIBitmap(hdc, &bmih, CBM_INIT, vis->screen.GetData(), &bmi, DIB_RGB_COLORS);
	HBITMAPBlitToHdc(hdc, hbmp, 0, 0, vis->screen.w, vis->screen.h);
	DeleteObject(hbmp);

	if (vis->options.sleep_time) std::this_thread::sleep_for(std::chrono::milliseconds(vis->options.sleep_time));
}

void Visualizer::DrawScatterPlot(Visualizer* vis, HWND hwnd, HDC hdc, DrawEventInfo* draw_event_info) {
	std::vector<TraceInt>* arr = &vis->tv.vec_;

	///////////////////////////////////////////////////////////////////////////////////////

	double wf = (double)vis->screen.w / (double)arr->size();
	double hf = (double)vis->screen.h / (double)arr->size();

	const double dot_w = 2.0;
	static unsigned floor_dot_w = (unsigned)floor(dot_w / 2.0);
	static unsigned ceil_dot_w = (unsigned)ceil(dot_w / 2.0);

	auto DrawDot = [&](unsigned i) {
		unsigned ypos = (unsigned)(hf * (double)arr->at(i));		

		long long x_start = (int)(wf * (double)i) - floor_dot_w;
		long long x_end = (int)(wf * (double)i) + ceil_dot_w;

		long long y_start = vis->screen.h - ypos - floor_dot_w - 1;//top
		long long y_end = vis->screen.h - ypos + ceil_dot_w;//bottom

		x_start = x_start < 0 ? 0 : x_start;
		x_end = x_end > vis->screen.w ? vis->screen.w: x_end;

		y_start = y_start < 0 ? 0 : y_start;
		y_end = y_end > vis->screen.h ? vis->screen.h: y_end;

		COLORREF dot_color = vis->GetColor(arr, i, draw_event_info);

		for (unsigned y = y_start; y < y_end; ++y) {
			for (unsigned x = x_start; x <= x_end; ++x) {
				int pos = y * vis->screen.stride + x * 4 + vis->screen.stride + 4;
				
			//	COLORREF col = (y <= y_start && y > y_end) ? dot_color : vis->back_color;
				
				vis->screen.SetData(pos + 2, GetRValue(dot_color));
				vis->screen.SetData(pos + 1, GetGValue(dot_color));
				vis->screen.SetData(pos + 0, GetBValue(dot_color));
			}
		}
	};

	auto RedrawDot = [&](unsigned i, unsigned v) {		
		unsigned ypos = (unsigned)(hf * (double)v);

		unsigned x_start = std::max((int)(wf * (double)i) - floor_dot_w, 0u);
		unsigned x_end = std::min((int)(wf * (double)i) + ceil_dot_w, (unsigned)vis->screen.w);

		unsigned y_start = std::max(vis->screen.h - ypos - floor_dot_w - 1, 0u);//top
		unsigned y_end = std::min(vis->screen.h - ypos + ceil_dot_w, (unsigned)vis->screen.h);//bottom

		COLORREF dot_color = RGB(255, 0, 0);//vis->back_color;// vis->GetColor(arr, i, draw_event_info);

		for (unsigned y = y_start; y < y_end; ++y) {
			for (unsigned x = x_start; x <= x_end; ++x) {
				int pos = y * vis->screen.stride + x * 4 + vis->screen.stride + 4;

				//	COLORREF col = (y <= y_start && y > y_end) ? dot_color : vis->back_color;

				vis->screen.SetData(pos + 2, GetRValue(dot_color));
				vis->screen.SetData(pos + 1, GetGValue(dot_color));
				vis->screen.SetData(pos + 0, GetBValue(dot_color));
			}
		}
	};

	///////////////////////////////////////////////////////////////////////////////////////
	//nothing specific to draw so draw the whole thing (no highlights)
	if (draw_event_info->draw_event_type == DrawEventType::Redraw) {
		vis->reset_last_draw();

		vis->FillBackground();

		double step = (double)arr->size() / (double)vis->screen.w;
		double size = (double)arr->size();
		//for (double i = 0.0; i < size; i += step)
		for (unsigned i = 0; i < arr->size(); i++)
			DrawDot((unsigned)i);
	}
	else { //only draw changes
		if (vis->options.bfast_draw && vis->num_skipped > 0) {
			ScopedVar<Visualizer::DrawEventType> scoped_draw_event_type(draw_event_info->draw_event_type, DrawEventType::DrawSkipped);

			double step = std::max((double)arr->size() / (double)vis->screen.w, 1.0);
			//crush each each index into its pixel column(s)
			std::set<unsigned> cols;
			for (unsigned i = 0; i < vis->skipped_draws.size(); i++) {
				cols.insert((unsigned)((double)vis->skipped_draws[i].ptr1 / step));
				if (isDrawEventDouble(vis->skipped_draws[i].draw_event_type))
					cols.insert((unsigned)((double)vis->skipped_draws[i].ptr2 / step));
			}
			
			for (auto a : cols) {
				unsigned i = (unsigned)(step * (double)a);
				DrawDot(i);
			}
		}

		//draw current change
		if (isDrawEventSingle(draw_event_info->draw_event_type)) {
			DrawDot(draw_event_info->ptr1);
			if (isDrawEventDouble(draw_event_info->draw_event_type)) {
				DrawDot(draw_event_info->ptr2);
			}
		}

		//redraw last change
		if (isDrawEventSingle(vis->last_draw.draw_event_type)) {				
			RedrawDot(vis->last_draw.ptr1, vis->last_draw_value.ptr1);			
			if (isDrawEventDouble(vis->last_draw.draw_event_type)) {				
				RedrawDot(vis->last_draw.ptr2, vis->last_draw_value.ptr2);
			}
		}

		vis->last_draw.ptr1 = draw_event_info->ptr1;
		vis->last_draw.ptr2 = draw_event_info->ptr2;
		vis->last_draw.draw_event_type = draw_event_info->draw_event_type;
		vis->last_draw_value.ptr1 = arr->at(draw_event_info->ptr1);
		vis->last_draw_value.ptr2 = arr->at(draw_event_info->ptr2);	
	}

	///////////////////////////////////////////////////////////////////////////////////////

	BITMAPINFOHEADER bmih = { sizeof(BITMAPINFOHEADER), (int)((long long)vis->screen.w), (int)(-(long long)vis->screen.h), 1, 32, BI_RGB, 0, 0, 0, 0, 0 };
	BITMAPINFO bmi = { bmih, 0, 0, 0, 0 };
	HBITMAP hbmp = CreateDIBitmap(hdc, &bmih, CBM_INIT, vis->screen.GetData(), &bmi, DIB_RGB_COLORS);
	HBITMAPBlitToHdc(hdc, hbmp, 0, 0, vis->screen.w, vis->screen.h);
	DeleteObject(hbmp);

	if (vis->options.sleep_time) std::this_thread::sleep_for(std::chrono::milliseconds(vis->options.sleep_time));
}

void Visualizer::DrawColorWheel(Visualizer* vis, HWND hwnd, HDC hdc, DrawEventInfo* draw_event_info) {
	std::vector<TraceInt>* arr = &vis->tv.vec_;

	///////////////////////////////////////////////////////////////////////////////////////

	double wf = (double)vis->screen.w / (double)arr->size();
	double hf = (double)vis->screen.h / (double)arr->size();

	double diameter = (double)arr->size();
	double radius = diameter / 2.1;
	double center = diameter / 2.0;

	double wr = (double)vis->screen.w / 2.0, hr = (double)vis->screen.h / 2.0;
	double perimeter = (2.0 * PI) * (3.0 * (wr + hr) - sqrt((3.0 * wr + hr) * (wr + 3.0 * hr)));

	Range<double> indexes(0.0, (double)arr->size());
	Range<double> arcs(0.0, perimeter);
	static Range<double> degrees(0.0, 360.0);
	static Range<double> radians(0.0, 2.0 * PI);

	auto DrawArc = [&](unsigned i) {
		double theta_s;
		double theta_e;

		if (indexes.max > arcs.max) {
			unsigned arc = (unsigned)indexes.MapTo((double)i, arcs);
			theta_s = arcs.MapTo((double)arc, radians);
			theta_e = arcs.MapTo((double)(arc + 1.0), radians);
		}
		else {
			theta_s = indexes.MapTo((double)i, radians);
			theta_e = indexes.MapTo((double)(i + 1.0), radians);
		}

		POINT c = {center * wf, center * hf};
		POINT p1, p2;

		p1.x = (long)(wf * (center + radius * cos(theta_s)));
		p1.y = vis->screen.h - (long)(hf * (center + radius * sin(theta_s)));

		p2.x = (long)(wf * (center + radius * cos(theta_e)));
		p2.y = vis->screen.h - (long)(hf * (center + radius * sin(theta_e)));

		/*auto lrfml = Sort3(c.x, p1.x, p2.x);
		auto tbfml = Sort3(c.y, p1.y, p2.y);*/

		COLORREF arc_color = vis->GetColor(arr, i, draw_event_info);

		HPEN hPen = CreatePen(PS_SOLID, 1, arc_color);
		HPEN hOldPen = SelectPen(hdc, hPen);
		HBRUSH hBrush = CreateSolidBrush(arc_color);
		HBRUSH hOldBrush = SelectBrush(hdc, hBrush);	
		POINT vertices[] = {p1, p2, c};
		Polygon(hdc, vertices, 3);	
		SelectBrush(hdc, hOldBrush);
		DeleteObject(hBrush);
		SelectPen(hdc, hOldPen);
		DeleteObject(hPen);	
	};

	if (true || draw_event_info->draw_event_type == DrawEventType::Redraw) {
		vis->reset_last_draw();

	//	vis->FillBackground();

		double dsize = (double)arr->size();
		double step = dsize / perimeter;
	
		if (dsize > perimeter) 
			for (double i = 0.0; i < dsize; i += step) 
				DrawArc((unsigned)i);
		else 
			for (unsigned i = 0; i < arr->size(); ++i) 
				DrawArc(i);	
	}
	else {
		//draw anything that was skipped and draw only once per arc
		if (vis->options.bfast_draw && vis->num_skipped > 0) {
			ScopedVar<Visualizer::DrawEventType> scoped_draw_event_type(draw_event_info->draw_event_type, DrawEventType::DrawSkipped);

			//number is skipped draws exceeds the number of pixel columns
			//if (vis->num_skipped >= vis->w) {
			//	long double step = (double)arr->size() / ((double)vis->w * 1.5);// * 1.5 seems to fix draw gaps (?caused by precision error?)

			//	//crush each each index into its pixel column(s)
			//	std::set<unsigned> cols;
			//	for (unsigned i = 0; i < vis->skipped_draws.size(); i++) {
			//		cols.insert((unsigned)((long double)vis->skipped_draws[i].ptr1 / step));
			//		if (isDrawEventDouble(vis->skipped_draws[i].draw_event_type))
			//			cols.insert((unsigned)((long double)vis->skipped_draws[i].ptr2 / step));
			//	}
			//	//draw each pixel column(s)
			//	for (auto a : cols)
			//		DrawBar((unsigned)(step * (long double)a));
			//}
			//else {
				for (unsigned i = 0; i < vis->skipped_draws.size(); i++) {
					DrawArc(vis->skipped_draws[i].ptr1);
					if (isDrawEventDouble(vis->skipped_draws[i].draw_event_type))
						DrawArc(vis->skipped_draws[i].ptr2);
				}
			/*}*/
		}


		//draw current change
		if (isDrawEventSingle(draw_event_info->draw_event_type)) {
			DrawArc(draw_event_info->ptr1);
			if (isDrawEventDouble(draw_event_info->draw_event_type)) {
				DrawArc(draw_event_info->ptr2);
			}
		}

		//redraw last change
		if (isDrawEventSingle(vis->last_draw.draw_event_type)) {
			{
				ScopedVar<DrawEventType> scoped_last_draw_draw_event_type(vis->last_draw.draw_event_type, DrawEventType::DrawSkipped);
				DrawArc(vis->last_draw.ptr1);
			}
			if (isDrawEventDouble(vis->last_draw.draw_event_type)) {
				ScopedVar<DrawEventType> scoped_last_draw_draw_event_type(vis->last_draw.draw_event_type, DrawEventType::DrawSkipped);
				DrawArc(vis->last_draw.ptr2);
			}
		}

		vis->last_draw.ptr1 = draw_event_info->ptr1;
		vis->last_draw.ptr2 = draw_event_info->ptr2;
		vis->last_draw.draw_event_type = draw_event_info->draw_event_type;
		vis->last_draw_value.ptr1 = arr->at(draw_event_info->ptr1);
		vis->last_draw_value.ptr2 = arr->at(draw_event_info->ptr2);
	}

	///////////////////////////////////////////////////////////////////////////////////////

	/*BITMAPINFOHEADER bmih = {sizeof(BITMAPINFOHEADER), (int)((long long)vis->w), (int)(-(long long)vis->h), 1, 32, BI_RGB, 0, 0, 0, 0, 0};
	BITMAPINFO bmi = {bmih, 0, 0, 0, 0};
	HBITMAP hbmp = CreateDIBitmap(hdc, &bmih, CBM_INIT, vis->bmp_screen, &bmi, DIB_RGB_COLORS);
	HBITMAPBlitToHdc(hdc, hbmp, 0, 0, vis->w, vis->h);
	DeleteObject(hbmp);*/

	if (vis->options.sleep_time) std::this_thread::sleep_for(std::chrono::milliseconds(vis->options.sleep_time));
}

void Visualizer::DrawDisparityDots(Visualizer* vis, HWND hwnd, HDC hdc, DrawEventInfo* draw_event_info) {
	std::vector<TraceInt>* arr = &vis->tv.vec_;

	///////////////////////////////////////////////////////////////////////////////////////

	double wf = (double)vis->screen.w / (double)arr->size();
	double hf = (double)vis->screen.h / (double)arr->size();

	Range<double> nums(1.0, (double)arr->size());
	static Range<double> radians(0.0, 2.0 * PI);

	double diameter = (double)arr->size();
	double center = diameter / 2.0;

	auto DrawDot = [&](unsigned i) {	
		double dist = (double)uint_diff(arr->at(i).sorted_index_, i);
		dist = std::max(dist, diameter - dist);
		double radius = dist / 2.1;		
		double theta = nums.MapTo((double)i, radians);

		unsigned x = (unsigned)(wf * (center + radius * cos(theta)));
		unsigned y = vis->screen.h - (unsigned)(hf * (center + radius * sin(theta)));

		unsigned x_start = x - 2;//left
		unsigned x_end = x + 1;//right

		unsigned y_start = vis->screen.h - y + 1;//bottom
		unsigned y_end = vis->screen.h - y - 2;//top

		COLORREF dot_color = vis->GetColor(arr, i, draw_event_info);

		for (unsigned y = y_start; y > y_end; --y) {
			for (unsigned x = x_start; x <= x_end; ++x) {
				unsigned pos = y * vis->screen.stride + x * 4 + vis->screen.stride + 4;

				vis->screen.SetData(pos + 2, GetRValue(dot_color));
				vis->screen.SetData(pos + 1, GetGValue(dot_color));
				vis->screen.SetData(pos + 0, GetBValue(dot_color));
			}
		}
	};

	auto ReDrawDotArea = [&](unsigned i/*, unsigned v*/) {
		double t = nums.MapTo((double)i, radians);

		double dist = (double)uint_diff(arr->at(i).sorted_index_, arr->at(i).index_) / 2.0;
		double d = (double)(arr->size() - 1);
		double r = (d - dist) / 2.1;//may be negative
		double center = d / 2.0;
		unsigned x = (unsigned)(wf * (center + r * cos(t)));
		unsigned y = vis->screen.h - (unsigned)(hf * (center + r * sin(t)));

		unsigned x_start = x - 2;
		unsigned x_end = x + 1;

		unsigned y_start = vis->screen.h - y + 1;//bottom
		unsigned y_end = vis->screen.h - y - 2;//top

		for (unsigned y = y_start; y > y_end; --y) {
			for (unsigned x = x_start; x <= x_end; ++x) {
				unsigned pos = y * vis->screen.stride + x * 4 + vis->screen.stride + 4;

				/*vis->bmp_screen[pos + 2] = GetRValue(vis->back_color);
				vis->bmp_screen[pos + 1] = GetGValue(vis->back_color);
				vis->bmp_screen[pos + 0] = GetBValue(vis->back_color);*/

				vis->screen.SetData(pos + 2, GetRValue(RGB(255, 0, 0)));
				vis->screen.SetData(pos + 1, GetGValue(RGB(255, 0, 0)));
				vis->screen.SetData(pos + 0, GetBValue(RGB(255, 0, 0)));
			}
		}
	};

	if (true || draw_event_info->draw_event_type == DrawEventType::Redraw) {
		vis->reset_last_draw();

		vis->FillBackground();

		for (unsigned i = 0; i < arr->size(); i++) {
			DrawDot(i);
		}
	}
	else {
		//draw current change
		if (isDrawEventSingle(draw_event_info->draw_event_type)) {
			DrawDot(draw_event_info->ptr1);
			if (isDrawEventDouble(draw_event_info->draw_event_type)) {
				DrawDot(draw_event_info->ptr2);
			}
		}	

		//redraw last change
		if (isDrawEventSingle(vis->last_draw.draw_event_type)) {
			{
				ScopedVar<DrawEventType> scoped_last_draw_draw_event_type(vis->last_draw.draw_event_type, DrawEventType::DrawSkipped);
				ReDrawDotArea(vis->last_draw.ptr1);
			}
			if (isDrawEventDouble(vis->last_draw.draw_event_type)) {
				ScopedVar<DrawEventType> scoped_last_draw_draw_event_type(vis->last_draw.draw_event_type, DrawEventType::DrawSkipped);
				ReDrawDotArea(vis->last_draw.ptr2);
			}
		}

		vis->last_draw.ptr1 = draw_event_info->ptr1;
		vis->last_draw.ptr2 = draw_event_info->ptr2;
		vis->last_draw.draw_event_type = draw_event_info->draw_event_type;
		vis->last_draw_value.ptr1 = arr->at(draw_event_info->ptr1);
		vis->last_draw_value.ptr2 = arr->at(draw_event_info->ptr2);
	}

	///////////////////////////////////////////////////////////////////////////////////////

	BITMAPINFOHEADER bmih = { sizeof(BITMAPINFOHEADER), (int)((long long)vis->screen.w), (int)(-(long long)vis->screen.h), 1, 32, BI_RGB, 0, 0, 0, 0, 0 };
	BITMAPINFO bmi = { bmih, 0, 0, 0, 0 };
	HBITMAP hbmp = CreateDIBitmap(hdc, &bmih, CBM_INIT, vis->screen.GetData(), &bmi, DIB_RGB_COLORS);
	HBITMAPBlitToHdc(hdc, hbmp, 0, 0, vis->screen.w, vis->screen.h);
	DeleteObject(hbmp);

	if (vis->options.sleep_time) std::this_thread::sleep_for(std::chrono::milliseconds(vis->options.sleep_time));
}

void Visualizer::DrawSquares(Visualizer* vis, HWND hwnd, HDC hdc, DrawEventInfo* draw_event_info) {
	std::vector<TraceInt>* arr = &vis->tv.vec_;

	///////////////////////////////////////////////////////////////////////////////////////

	double wf = (double)vis->screen.w / (double)arr->size();
	double hf = (double)vis->screen.h / (double)arr->size();

	const double dot_w = 2.0;
	static unsigned floor_dot_w = (unsigned)floor(dot_w / 2.0);
	static unsigned ceil_dot_w = (unsigned)ceil(dot_w / 2.0);

	auto DrawDot = [&](unsigned i) {
		unsigned ypos = (unsigned)(hf * (double)arr->at(i));

		long long x_start = (int)(wf * (double)i) - floor_dot_w;
		long long x_end = (int)(wf * (double)i) + ceil_dot_w;

		long long y_start = vis->screen.h - ypos - floor_dot_w - 1;//top
		long long y_end = vis->screen.h - ypos + ceil_dot_w;//bottom

		x_start = x_start < 0 ? 0 : x_start;
		x_end = x_end > vis->screen.w ? vis->screen.w : x_end;

		y_start = y_start < 0 ? 0 : y_start;
		y_end = y_end > vis->screen.h ? vis->screen.h : y_end;

		COLORREF dot_color = vis->GetColor(arr, i, draw_event_info);

		for (unsigned y = y_start; y < y_end; ++y) {
			for (unsigned x = x_start; x <= x_end; ++x) {
				int pos = y * vis->screen.stride + x * 4 + vis->screen.stride + 4;

				//	COLORREF col = (y <= y_start && y > y_end) ? dot_color : vis->back_color;

				vis->screen.SetData(pos + 2, GetRValue(dot_color));
				vis->screen.SetData(pos + 1, GetGValue(dot_color));
				vis->screen.SetData(pos + 0, GetBValue(dot_color));
			}
		}
	};

	auto DrawSquare = [&](unsigned i) {

	};

	if (true || draw_event_info->draw_event_type == DrawEventType::Redraw) {
		vis->reset_last_draw();
	
		if (arr->size() > vis->screen.w * vis->screen.h) {
			double dsize = (double)arr->size();
			double step = dsize / (double)(vis->screen.w * vis->screen.h);
			for (double i = 0.0; i < dsize; i += step)
				DrawSquare((unsigned)i);
		}
		else
			for (unsigned i = 0; i < arr->size(); ++i)
				DrawSquare(i);
	}
	else { //only draw changes
		//if (vis->options.bfast_draw && vis->num_skipped > 0) {
		//	ScopedVar<Visualizer::DrawEventType> scoped_draw_event_type(draw_event_info->draw_event_type, DrawEventType::DrawSkipped);

		//	double step = std::max((double)arr->size() / (double)vis->w, 1.0);
		//	//crush each each index into its pixel column(s)
		//	std::set<unsigned> cols;
		//	for (unsigned i = 0; i < vis->skipped_draws.size(); i++) {
		//		cols.insert((unsigned)((double)vis->skipped_draws[i].ptr1 / step));
		//		if (isDrawEventDouble(vis->skipped_draws[i].draw_event_type))
		//			cols.insert((unsigned)((double)vis->skipped_draws[i].ptr2 / step));
		//	}

		//	for (auto a : cols) {
		//		unsigned i = (unsigned)(step * (double)a);
		//		DrawDot(i);
		//	}
		//}

		////draw current change
		//if (isDrawEventSingle(draw_event_info->draw_event_type)) {
		//	DrawDot(draw_event_info->ptr1);
		//	if (isDrawEventDouble(draw_event_info->draw_event_type)) {
		//		DrawDot(draw_event_info->ptr2);
		//	}
		//}

		////redraw last change
		//if (isDrawEventSingle(vis->last_draw.draw_event_type)) {
		//	RedrawDot(vis->last_draw.ptr1, vis->last_draw_value.ptr1);
		//	if (isDrawEventDouble(vis->last_draw.draw_event_type)) {
		//		RedrawDot(vis->last_draw.ptr2, vis->last_draw_value.ptr2);
		//	}
		//}

		vis->last_draw.ptr1 = draw_event_info->ptr1;
		vis->last_draw.ptr2 = draw_event_info->ptr2;
		vis->last_draw.draw_event_type = draw_event_info->draw_event_type;
		vis->last_draw_value.ptr1 = arr->at(draw_event_info->ptr1);
		vis->last_draw_value.ptr2 = arr->at(draw_event_info->ptr2);
	}

	///////////////////////////////////////////////////////////////////////////////////////

	BITMAPINFOHEADER bmih = {sizeof(BITMAPINFOHEADER), (int)((long long)vis->screen.w), (int)(-(long long)vis->screen.h), 1, 32, BI_RGB, 0, 0, 0, 0, 0};
	BITMAPINFO bmi = {bmih, 0, 0, 0, 0};
	HBITMAP hbmp = CreateDIBitmap(hdc, &bmih, CBM_INIT, vis->screen.GetData(), &bmi, DIB_RGB_COLORS);
	HBITMAPBlitToHdc(hdc, hbmp, 0, 0, vis->screen.w, vis->screen.h);
	DeleteObject(hbmp);

	if (vis->options.sleep_time) std::this_thread::sleep_for(std::chrono::milliseconds(vis->options.sleep_time));
}


~-----------------------------------------------~
C:\Users\Josh\Documents\Visual Studio 2017\Projects\Sorting\Sorting\resource.rc
~-----------------------------------------------~












































~-----------------------------------------------~
C:\Users\Josh\Documents\Visual Studio 2017\Projects\Sorting\Sorting\Sorting - Copy.rc
~-----------------------------------------------~
// Microsoft Visual C++ generated resource script.
//
#include "resource.h"

#define APSTUDIO_READONLY_SYMBOLS
/////////////////////////////////////////////////////////////////////////////
//
// Generated from the TEXTINCLUDE 2 resource.
//
#include  "winres.h"

/////////////////////////////////////////////////////////////////////////////
#undef APSTUDIO_READONLY_SYMBOLS

/////////////////////////////////////////////////////////////////////////////
// English (United States) resources

#if !defined(AFX_RESOURCE_DLL) || defined(AFX_TARG_ENU)
LANGUAGE LANG_ENGLISH, SUBLANG_ENGLISH_US
#pragma code_page(1252)

#ifdef APSTUDIO_INVOKED
/////////////////////////////////////////////////////////////////////////////
//
// TEXTINCLUDE
//

1 TEXTINCLUDE 
BEGIN
    "resource.h\0"
END

2 TEXTINCLUDE 
BEGIN
    "#include  ""winres.h""\r\n"
    "\0"
END

3 TEXTINCLUDE 
BEGIN
    "\r\n"
    "\0"
END

#endif    // APSTUDIO_INVOKED


/////////////////////////////////////////////////////////////////////////////
//
// Dialog
//

IDD_DIALOG DIALOGEX 0, 0, 500, 300
STYLE DS_SETFONT | DS_CENTER | WS_MINIMIZEBOX | WS_MAXIMIZEBOX | WS_CAPTION | WS_SYSMENU | WS_THICKFRAME
EXSTYLE WS_EX_OVERLAPPEDWINDOW | WS_EX_APPWINDOW
CAPTION "Sorting Algorithm Visualizer"
FONT 8, "MS  Shell  Dlg", 400, 0, 0x1
BEGIN
    PUSHBUTTON      "Run All",BTN_RUN_ALL,458,279,35,14
    PUSHBUTTON      "Add",BTN_ADD,458,239,35,14
    PUSHBUTTON      "Remove",BTN_REMOVE,458,258,35,14
END

IDD_OPTIONS DIALOGEX 0, 0, 293, 146
STYLE DS_SETFONT | DS_MODALFRAME | DS_SETFOREGROUND | DS_FIXEDSYS | DS_CENTER | WS_MINIMIZEBOX | WS_POPUP | WS_VISIBLE | WS_CAPTION | WS_SYSMENU
CAPTION "Options"
FONT 8, "MS Shell Dlg", 400, 0, 0x1
BEGIN
    CONTROL         "Sorting Algorithm:",IDC_STATIC,"Static",SS_LEFTNOWORDWRAP | WS_GROUP,7,5,58,8
    COMBOBOX        CB_ALGORITHMS,5,14,116,175,CBS_DROPDOWNLIST | WS_VSCROLL | WS_TABSTOP
    LTEXT           "Visualization Type:",IDC_STATIC,6,36,60,8
    COMBOBOX        CB_VISUALIZATION_TYPE,5,44,116,72,CBS_DROPDOWNLIST | WS_VSCROLL | WS_TABSTOP
    LTEXT           "Color Mode:",IDC_STATIC,5,59,40,8
    COMBOBOX        CB_COLOR_MODE,5,67,116,104,CBS_DROPDOWNLIST | WS_VSCROLL | WS_TABSTOP
    GROUPBOX        "Initialization Options:",IDC_STATIC,180,5,106,112
    LTEXT           "Values:",IDC_STATIC,185,16,24,8
    CONTROL         "Regular",RDO_REGULAR,"Button",BS_AUTORADIOBUTTON,183,24,41,10
    CONTROL         "Few Unique",RDO_FEW_UNIQUE,"Button",BS_AUTORADIOBUTTON,183,34,53,10
    CONTROL         "Very Few Unique",RDO_VERY_FEW_UNIQUE,"Button",BS_AUTORADIOBUTTON,183,43,70,10
    CONTROL         "Random",RDO_VALUE_RANDOM,"Button",BS_AUTORADIOBUTTON,248,24,42,10
	CONTROL         "Normal", RDO_NORMAL, "Button", BS_AUTORADIOBUTTON, 248, 34, 38, 10
    LTEXT           "Ordering:",IDC_STATIC,183,52,32,8
    CONTROL         "Random",RDO_ORDER_RANDOM,"Button",BS_AUTORADIOBUTTON,183,62,42,10
    CONTROL         "Near Sorted",RDO_NEAR_SORTED,"Button",BS_AUTORADIOBUTTON,183,72,55,10
    CONTROL         "Reversed",RDO_REVERSED,"Button",BS_AUTORADIOBUTTON,183,82,47,10
    CONTROL         "Near Sorted and Reversed",RDO_NEAR_SORTED_REVERSED,
                    "Button",BS_AUTORADIOBUTTON,183,92,101,10
    CONTROL         "Sorted",RDO_SORTED,"Button",BS_AUTORADIOBUTTON,183,102,37,10
    GROUPBOX        "Draw Options",IDC_STATIC,2,27,122,88
    CONTROL         "Accesses",CBTN_ACCESSES,"Button",BS_AUTOCHECKBOX | WS_TABSTOP,9,83,45,10
    CONTROL         "Comparisons",CBTN_COMPARISONS,"Button",BS_AUTOCHECKBOX | WS_TABSTOP,9,93,57,10
    CONTROL         "Assignments",CBTN_ASSIGNMENTS,"Button",BS_AUTOCHECKBOX | WS_TABSTOP,9,103,56,10
    CONTROL         "Pre Swap",CBTN_PRE_SWAP,"Button",BS_AUTOCHECKBOX | WS_TABSTOP,71,83,46,10
    CONTROL         "Post Swap",CBTN_POST_SWAP,"Button",BS_AUTOCHECKBOX | WS_TABSTOP,71,93,49,10
    CONTROL         "Sound",CBTN_SOUND,"Button",BS_AUTOCHECKBOX | WS_DISABLED | WS_TABSTOP,128,127,36,10
    CONTROL         "Fast Draw",CBTN_FAST_DRAW,"Button",BS_AUTOCHECKBOX | WS_TABSTOP,127,29,49,10
    LTEXT           "Draw Speed:",IDC_STATIC,128,40,42,8
    EDITTEXT        EDC_DRAW_SPEED_FACTOR,128,49,25,12,ES_AUTOHSCROLL | ES_NUMBER
    LTEXT           "Sleep Time(ms):",IDC_STATIC,128,62,52,8
    EDITTEXT        EDC_SLEEP_TIME,128,71,25,12,ES_AUTOHSCROLL | ES_NUMBER
    LTEXT           "# of Elements:",IDC_STATIC,126,4,48,8
    EDITTEXT        EDC_SIZE,126,14,51,12,ES_AUTOHSCROLL | ES_NUMBER
    CONTROL         "Runtime",CBTN_RUNTIME,"Button",BS_AUTO3STATE | WS_TABSTOP,127,105,42,10
    CONTROL         "Complexity",CBTN_COMPLEXITY,"Button",BS_AUTO3STATE | WS_TABSTOP,127,85,51,10
    CONTROL         "Counts",CBTN_COUNTS,"Button",BS_AUTO3STATE | WS_TABSTOP,127,95,39,10
    LTEXT           "Instrument:",IDC_STATIC,7,117,39,8
    COMBOBOX        CB_INSTRUMENTS,5,126,116,117,CBS_DROPDOWNLIST | WS_VSCROLL | WS_TABSTOP
    LTEXT           "Min",IDC_STATIC,225,117,12,8
    EDITTEXT        EDC_MIN_FREQ,219,125,19,14,ES_AUTOHSCROLL | ES_NUMBER
    LTEXT           "Max",IDC_STATIC,241,117,14,8
    EDITTEXT        EDC_MAX_FREQ,239,125,19,14,ES_AUTOHSCROLL | ES_NUMBER
    LTEXT           "Velocity",IDC_STATIC,168,117,26,8
    EDITTEXT        EDC_ON_VELOCITY,169,125,22,14,ES_AUTOHSCROLL | ES_NUMBER
    LTEXT           "Release",IDC_STATIC,193,117,26,8
    EDITTEXT        EDC_OFF_VELOCITY,194,125,22,14,ES_AUTOHSCROLL | ES_NUMBER
    LTEXT           "Duration",IDC_STATIC,260,117,28,8
    EDITTEXT        EDC_NOTE_DURATION,262,125,23,14,ES_AUTOHSCROLL | ES_NUMBER
END


/////////////////////////////////////////////////////////////////////////////
//
// DESIGNINFO
//

#ifdef APSTUDIO_INVOKED
GUIDELINES DESIGNINFO
BEGIN
    IDD_DIALOG, DIALOG
    BEGIN
        LEFTMARGIN, 7
        RIGHTMARGIN, 493
        TOPMARGIN, 7
        BOTTOMMARGIN, 293
    END

    IDD_OPTIONS, DIALOG
    BEGIN
        LEFTMARGIN, 7
        RIGHTMARGIN, 286
        TOPMARGIN, 7
        BOTTOMMARGIN, 139
    END
END
#endif    // APSTUDIO_INVOKED


/////////////////////////////////////////////////////////////////////////////
//
// AFX_DIALOG_LAYOUT
//

IDD_DIALOG AFX_DIALOG_LAYOUT
BEGIN
    0
END

IDD_OPTIONS AFX_DIALOG_LAYOUT
BEGIN
    0
END

#endif    // English (United States) resources
/////////////////////////////////////////////////////////////////////////////



#ifndef APSTUDIO_INVOKED
/////////////////////////////////////////////////////////////////////////////
//
// Generated from the TEXTINCLUDE 3 resource.
//


/////////////////////////////////////////////////////////////////////////////
#endif    // not APSTUDIO_INVOKED


























~-----------------------------------------------~
C:\Users\Josh\Documents\Visual Studio 2017\Projects\Sorting\Sorting\Sorting.rc
~-----------------------------------------------~
// Microsoft Visual C++ generated resource script.
//
#include "resource.h"

#define APSTUDIO_READONLY_SYMBOLS
/////////////////////////////////////////////////////////////////////////////
//
// Generated from the TEXTINCLUDE 2 resource.
//
#include  "winres.h"

/////////////////////////////////////////////////////////////////////////////
#undef APSTUDIO_READONLY_SYMBOLS

/////////////////////////////////////////////////////////////////////////////
// English (United States) resources

#if !defined(AFX_RESOURCE_DLL) || defined(AFX_TARG_ENU)
LANGUAGE LANG_ENGLISH, SUBLANG_ENGLISH_US
#pragma code_page(1252)

#ifdef APSTUDIO_INVOKED
/////////////////////////////////////////////////////////////////////////////
//
// TEXTINCLUDE
//

1 TEXTINCLUDE 
BEGIN
    "resource.h\0"
END

2 TEXTINCLUDE 
BEGIN
    "#include  ""winres.h""\r\n"
    "\0"
END

3 TEXTINCLUDE 
BEGIN
    "\r\n"
    "\0"
END

#endif    // APSTUDIO_INVOKED


/////////////////////////////////////////////////////////////////////////////
//
// Dialog
//

IDD_DIALOG DIALOGEX 0, 0, 500, 300
STYLE DS_SETFONT | DS_CENTER | WS_MINIMIZEBOX | WS_MAXIMIZEBOX | WS_CLIPCHILDREN | WS_CAPTION | WS_SYSMENU | WS_THICKFRAME
EXSTYLE WS_EX_OVERLAPPEDWINDOW | WS_EX_APPWINDOW
CAPTION "Sorting Algorithm Visualizer"
FONT 8, "MS  Shell  Dlg", 400, 0, 0x1
BEGIN
    PUSHBUTTON      "Run All",BTN_RUN_ALL,458,279,35,14
    PUSHBUTTON      "Add",BTN_ADD,458,239,35,14
    PUSHBUTTON      "Remove",BTN_REMOVE,458,258,35,14
END

IDD_OPTIONS DIALOGEX 0, 0, 189, 220
STYLE DS_SETFONT | DS_MODALFRAME | DS_SETFOREGROUND | DS_FIXEDSYS | DS_CENTER | WS_MINIMIZEBOX | WS_POPUP | WS_VISIBLE | WS_CAPTION | WS_SYSMENU
CAPTION "Options"
FONT 8, "MS Shell Dlg", 400, 0, 0x1
BEGIN
    CONTROL         "Sorting Algorithm:",IDC_STATIC,"Static",SS_LEFTNOWORDWRAP | WS_GROUP,7,3,58,8
    COMBOBOX        CB_ALGORITHMS,5,12,122,215,CBS_DROPDOWNLIST | CBS_SORT | WS_VSCROLL | WS_TABSTOP
    LTEXT           "Visualization Type:",IDC_STATIC,11,74,60,8
    COMBOBOX        CB_VISUALIZATION_TYPE,11,83,101,137,CBS_DROPDOWNLIST | WS_VSCROLL | WS_TABSTOP
    LTEXT           "Color Mode:",IDC_STATIC,10,97,40,8
    COMBOBOX        CB_COLOR_MODE,11,106,101,104,CBS_DROPDOWNLIST | WS_VSCROLL | WS_TABSTOP
    GROUPBOX        "Initialization Options:",IDC_STATIC,7,27,173,37
    LTEXT           "Values:",IDC_STATIC,11,36,24,8
    LTEXT           "Ordering:",IDC_STATIC,95,36,32,8
    GROUPBOX        "Draw Options:",IDC_STATIC,7,65,174,88
    CONTROL         "Accesses",CBTN_ACCESSES,"Button",BS_AUTOCHECKBOX | WS_TABSTOP,11,121,45,10
    CONTROL         "Comparisons",CBTN_COMPARISONS,"Button",BS_AUTOCHECKBOX | WS_TABSTOP,11,131,57,10
    CONTROL         "Assignments",CBTN_ASSIGNMENTS,"Button",BS_AUTOCHECKBOX | WS_TABSTOP,11,141,56,10
    CONTROL         "Pre Swap",CBTN_PRE_SWAP,"Button",BS_AUTOCHECKBOX | WS_TABSTOP,67,121,46,10
    CONTROL         "Post Swap",CBTN_POST_SWAP,"Button",BS_AUTOCHECKBOX | WS_TABSTOP,67,131,49,10
    CONTROL         "Sound",CBTN_SOUND,"Button",BS_AUTOCHECKBOX | NOT WS_VISIBLE | WS_DISABLED | WS_TABSTOP,136,173,36,10
    CONTROL         "Fast Draw",CBTN_FAST_DRAW,"Button",BS_AUTOCHECKBOX | WS_TABSTOP,127,78,49,10,WS_EX_RIGHT
    LTEXT           "Speed:",IDC_STATIC,116,93,24,8
    EDITTEXT        EDC_DRAW_SPEED_FACTOR,151,91,25,12,ES_AUTOHSCROLL | ES_NUMBER
    LTEXT           "Delay(ms):",IDC_STATIC,116,106,36,8
    EDITTEXT        EDC_SLEEP_TIME,151,105,25,12,ES_AUTOHSCROLL | ES_NUMBER
    LTEXT           "# of Elements:",IDC_STATIC,129,2,48,8
    EDITTEXT        EDC_SIZE,131,12,51,12,ES_AUTOHSCROLL | ES_NUMBER
    CONTROL         "Runtime",CBTN_RUNTIME,"Button",BS_AUTO3STATE | WS_TABSTOP,127,140,42,10
    CONTROL         "Complexity",CBTN_COMPLEXITY,"Button",BS_AUTO3STATE | WS_TABSTOP,127,120,51,10
    CONTROL         "Counts",CBTN_COUNTS,"Button",BS_AUTO3STATE | WS_TABSTOP,127,130,39,10
    LTEXT           "Instrument:",IDC_STATIC,15,163,39,8
    COMBOBOX        CB_INSTRUMENTS,13,172,116,117,CBS_DROPDOWNLIST | WS_VSCROLL | WS_TABSTOP
    LTEXT           "Min",IDC_STATIC,79,185,12,8
    EDITTEXT        EDC_MIN_FREQ,73,193,19,14,ES_AUTOHSCROLL | ES_NUMBER
    LTEXT           "Max",IDC_STATIC,99,185,14,8
    EDITTEXT        EDC_MAX_FREQ,97,193,19,14,ES_AUTOHSCROLL | ES_NUMBER
    LTEXT           "Velocity",IDC_STATIC,13,185,26,8
    EDITTEXT        EDC_ON_VELOCITY,15,193,22,14,ES_AUTOHSCROLL | ES_NUMBER
    LTEXT           "Release",IDC_STATIC,44,185,26,8
    EDITTEXT        EDC_OFF_VELOCITY,44,193,22,14,ES_AUTOHSCROLL | ES_NUMBER
    LTEXT           "Duration",IDC_STATIC,123,185,28,8
    EDITTEXT        EDC_NOTE_DURATION,125,193,23,14,ES_AUTOHSCROLL | ES_NUMBER
    GROUPBOX        "Sound Options:",IDC_STATIC,7,154,173,59
    COMBOBOX        CB_INIT_VALUES,11,46,81,178,CBS_DROPDOWNLIST | WS_VSCROLL | WS_TABSTOP
    COMBOBOX        CB_INIT_ORDER,95,46,82,176,CBS_DROPDOWNLIST | WS_VSCROLL | WS_TABSTOP
END

IDD_TABLEVIEW DIALOGEX 0, 0, 593, 336
STYLE DS_SETFONT | DS_MODALFRAME | DS_FIXEDSYS | WS_MINIMIZEBOX | WS_POPUP | WS_VISIBLE | WS_CAPTION | WS_SYSMENU
CAPTION "Sort Results"
FONT 8, "MS Shell Dlg", 400, 0, 0x1
BEGIN
    CONTROL         "",LV_SORT_TABLE,"SysListView32",LVS_REPORT | LVS_ALIGNLEFT | WS_BORDER | WS_TABSTOP,7,7,579,322
END


/////////////////////////////////////////////////////////////////////////////
//
// DESIGNINFO
//

#ifdef APSTUDIO_INVOKED
GUIDELINES DESIGNINFO
BEGIN
    IDD_DIALOG, DIALOG
    BEGIN
        LEFTMARGIN, 7
        RIGHTMARGIN, 493
        TOPMARGIN, 7
        BOTTOMMARGIN, 293
    END

    IDD_OPTIONS, DIALOG
    BEGIN
        LEFTMARGIN, 7
        RIGHTMARGIN, 182
        TOPMARGIN, 7
        BOTTOMMARGIN, 213
    END

    IDD_TABLEVIEW, DIALOG
    BEGIN
        LEFTMARGIN, 7
        RIGHTMARGIN, 586
        TOPMARGIN, 7
        BOTTOMMARGIN, 329
    END
END
#endif    // APSTUDIO_INVOKED


/////////////////////////////////////////////////////////////////////////////
//
// AFX_DIALOG_LAYOUT
//

IDD_DIALOG AFX_DIALOG_LAYOUT
BEGIN
    0
END

IDD_OPTIONS AFX_DIALOG_LAYOUT
BEGIN
    0
END

IDD_TABLEVIEW AFX_DIALOG_LAYOUT
BEGIN
    0
END

#endif    // English (United States) resources
/////////////////////////////////////////////////////////////////////////////



#ifndef APSTUDIO_INVOKED
/////////////////////////////////////////////////////////////////////////////
//
// Generated from the TEXTINCLUDE 3 resource.
//


/////////////////////////////////////////////////////////////////////////////
#endif    // not APSTUDIO_INVOKED






